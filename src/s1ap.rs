#![allow(non_camel_case_types)]
#![allow(dead_code)]
use asn1_codecs::Asn1Choice;
use entropic::prelude::*;
use asn1_codecs::aper::AperCodec;

pub const ID_ADDITIONAL_GUTI: u16 = 224;

pub const ID_ADDITIONAL_CS_FALLBACK_INDICATOR: u16 = 187;

pub const ID_ADDITIONAL_RRM_PRIORITY_INDEX: u16 = 299;

pub const ID_AERIAL_U_ESUBSCRIPTION_INFORMATION: u16 = 277;

pub const ID_ASSISTANCE_DATA_FOR_PAGING: u16 = 211;

pub const ID_BEARER_TYPE: u16 = 233;

pub const ID_BEARERS_SUBJECT_TO_EARLY_STATUS_TRANSFER_ITEM: u16 = 322;

pub const ID_BEARERS_SUBJECT_TO_STATUS_TRANSFER_ITEM: u16 = 89;

pub const ID_BLUETOOTH_MEASUREMENT_CONFIGURATION: u16 = 284;

pub const ID_BROADCAST_CANCELLED_AREA_LIST: u16 = 141;

pub const ID_BROADCAST_COMPLETED_AREA_LIST: u16 = 120;

pub const ID_CE_MODE_B_RESTRICTED: u16 = 271;

pub const ID_CE_MODE_B_SUPPORT_INDICATOR: u16 = 242;

pub const ID_CN_DOMAIN: u16 = 109;

pub const ID_CN_TYPE_RESTRICTIONS: u16 = 282;

pub const ID_CS_FALLBACK_INDICATOR: u16 = 108;

pub const ID_CSG_ID: u16 = 127;

pub const ID_CSG_ID_LIST: u16 = 128;

pub const ID_CSG_MEMBERSHIP_INFO: u16 = 226;

pub const ID_CSG_MEMBERSHIP_STATUS: u16 = 146;

pub const ID_CAUSE: u16 = 2;

pub const ID_CELL_ACCESS_MODE: u16 = 145;

pub const ID_CELL_IDENTIFIER_AND_CE_LEVEL_FOR_CE_CAPABLE_U_ES: u16 = 212;

pub const ID_CELL_TRAFFIC_TRACE: u8 = 42;

pub const ID_CONCURRENT_WARNING_MESSAGE_INDICATOR: u16 = 142;

pub const ID_CONNECTEDENG_NB_LIST: u16 = 291;

pub const ID_CONNECTEDENG_NB_TO_ADD_LIST: u16 = 292;

pub const ID_CONNECTEDENG_NB_TO_REMOVE_LIST: u16 = 293;

pub const ID_CONNECTION_ESTABLISHMENT_INDICATION: u8 = 54;

pub const ID_CONTEXTAT_SOURCE: u16 = 300;

pub const ID_CORRELATION_ID: u16 = 156;

pub const ID_COVERAGE_LEVEL: u16 = 250;

pub const ID_CRITICALITY_DIAGNOSTICS: u16 = 58;

pub const ID_DAPS_REQUEST_INFO: u16 = 317;

pub const ID_DAPS_RESPONSE_INFO_ITEM: u16 = 319;

pub const ID_DAPS_RESPONSE_INFO_LIST: u16 = 318;

pub const ID_DCN_ID: u16 = 246;

pub const ID_DL_CP_SECURITY_INFORMATION: u16 = 253;

pub const ID_DLCOUNT_VALUE_EXTENDED: u16 = 180;

pub const ID_DLCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 218;

pub const ID_DLNASPDU_DELIVERY_ACK_REQUEST: u16 = 249;

pub const ID_DATA_FORWARDING_NOT_POSSIBLE: u16 = 143;

pub const ID_DATA_CODING_SCHEME: u16 = 118;

pub const ID_DATA_SIZE: u16 = 304;

pub const ID_DEACTIVATE_TRACE: u8 = 26;

pub const ID_DEFAULT_PAGING_DRX: u16 = 137;

pub const ID_DIRECT_FORWARDING_PATH_AVAILABILITY: u16 = 79;

pub const ID_DOWNLINK_PACKET_LOSS_RATE: u16 = 273;

pub const ID_DOWNLINK_S1CDMA2000TUNNELLING: u8 = 19;

pub const ID_E_RAB_ADMITTED_ITEM: u16 = 20;

pub const ID_E_RAB_ADMITTED_LIST: u16 = 18;

pub const ID_E_RAB_DATA_FORWARDING_ITEM: u16 = 14;

pub const ID_E_RAB_FAILED_TO_BE_RELEASED_LIST: u16 = 103;

pub const ID_E_RAB_FAILED_TO_MODIFY_LIST: u16 = 32;

pub const ID_E_RAB_FAILED_TO_MODIFY_LIST_BEARER_MOD_CONF: u16 = 205;

pub const ID_E_RAB_FAILED_TO_RELEASE_LIST: u16 = 34;

pub const ID_E_RAB_FAILED_TO_RESUME_ITEM_RESUME_REQ: u16 = 236;

pub const ID_E_RAB_FAILED_TO_RESUME_ITEM_RESUME_RES: u16 = 238;

pub const ID_E_RAB_FAILED_TO_RESUME_LIST_RESUME_REQ: u16 = 235;

pub const ID_E_RAB_FAILED_TO_RESUME_LIST_RESUME_RES: u16 = 237;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_BEARER_SU_RES: u16 = 29;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_CTXT_SU_RES: u16 = 48;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_HO_REQ_ACK: u16 = 19;

pub const ID_E_RAB_FAILEDTO_SETUP_ITEM_HO_REQ_ACK: u16 = 21;

pub const ID_E_RAB_INFORMATION_LIST_ITEM: u16 = 78;

pub const ID_E_RAB_ITEM: u16 = 35;

pub const ID_E_RAB_MODIFICATION_INDICATION: u8 = 50;

pub const ID_E_RAB_MODIFY: u8 = 6;

pub const ID_E_RAB_MODIFY_ITEM_BEARER_MOD_CONF: u16 = 204;

pub const ID_E_RAB_MODIFY_ITEM_BEARER_MOD_RES: u16 = 37;

pub const ID_E_RAB_MODIFY_LIST_BEARER_MOD_CONF: u16 = 203;

pub const ID_E_RAB_MODIFY_LIST_BEARER_MOD_RES: u16 = 31;

pub const ID_E_RAB_NOT_TO_BE_MODIFIED_ITEM_BEARER_MOD_IND: u16 = 202;

pub const ID_E_RAB_NOT_TO_BE_MODIFIED_LIST_BEARER_MOD_IND: u16 = 201;

pub const ID_E_RAB_RELEASE: u8 = 7;

pub const ID_E_RAB_RELEASE_INDICATION: u8 = 8;

pub const ID_E_RAB_RELEASE_ITEM: u16 = 38;

pub const ID_E_RAB_RELEASE_ITEM_BEARER_REL_COMP: u16 = 15;

pub const ID_E_RAB_RELEASE_ITEM_HO_CMD: u16 = 49;

pub const ID_E_RAB_RELEASE_LIST_BEARER_REL_COMP: u16 = 69;

pub const ID_E_RAB_RELEASED_LIST: u16 = 110;

pub const ID_E_RAB_SETUP: u8 = 5;

pub const ID_E_RAB_SETUP_ITEM_BEARER_SU_RES: u16 = 39;

pub const ID_E_RAB_SETUP_ITEM_CTXT_SU_RES: u16 = 50;

pub const ID_E_RAB_SETUP_LIST_BEARER_SU_RES: u16 = 28;

pub const ID_E_RAB_SETUP_LIST_CTXT_SU_RES: u16 = 51;

pub const ID_E_RAB_SUBJECTTO_DATA_FORWARDING_LIST: u16 = 12;

pub const ID_E_RAB_TO_BE_MODIFIED_ITEM_BEARER_MOD_IND: u16 = 200;

pub const ID_E_RAB_TO_BE_MODIFIED_ITEM_BEARER_MOD_REQ: u16 = 36;

pub const ID_E_RAB_TO_BE_MODIFIED_LIST_BEARER_MOD_IND: u16 = 199;

pub const ID_E_RAB_TO_BE_MODIFIED_LIST_BEARER_MOD_REQ: u16 = 30;

pub const ID_E_RAB_TO_BE_RELEASED_LIST: u16 = 33;

pub const ID_E_RAB_TO_BE_RELEASED_LIST_BEARER_MOD_CONF: u16 = 210;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_BEARER_SU_REQ: u16 = 17;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_CTXT_SU_REQ: u16 = 52;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_HO_REQ: u16 = 27;

pub const ID_E_RAB_TO_BE_SETUP_LIST_BEARER_SU_REQ: u16 = 16;

pub const ID_E_RAB_TO_BE_SETUP_LIST_CTXT_SU_REQ: u16 = 24;

pub const ID_E_RAB_TO_BE_SETUP_LIST_HO_REQ: u16 = 53;

pub const ID_E_RAB_TO_BE_SWITCHED_DL_ITEM: u16 = 23;

pub const ID_E_RAB_TO_BE_SWITCHED_DL_LIST: u16 = 22;

pub const ID_E_RAB_TO_BE_SWITCHED_UL_ITEM: u16 = 94;

pub const ID_E_RAB_TO_BE_SWITCHED_UL_LIST: u16 = 95;

pub const ID_E_RAB_USAGE_REPORT_ITEM: u16 = 267;

pub const ID_E_RA_BTO_RELEASE_LIST_HO_CMD: u16 = 13;

pub const ID_E_UTRAN_TRACE_ID: u16 = 86;

pub const ID_ECGI_LIST_FOR_RESTART: u16 = 182;

pub const ID_EDT_SESSION: u16 = 281;

pub const ID_EN_DCSON_CONFIGURATION_TRANSFER_ECT: u16 = 294;

pub const ID_EN_DCSON_CONFIGURATION_TRANSFER_MCT: u16 = 295;

pub const ID_ENB_CONFIGURATION_UPDATE: u8 = 29;

pub const ID_EUTRAN_CGI: u16 = 100;

pub const ID_EUTRAN_ROUND_TRIP_DELAY_ESTIMATION_INFO: u16 = 140;

pub const ID_EMERGENCY_AREA_ID_LIST_FOR_RESTART: u16 = 190;

pub const ID_EMERGENCY_INDICATOR: u16 = 326;

pub const ID_END_INDICATION: u16 = 280;

pub const ID_ENHANCED_COVERAGE_RESTRICTED: u16 = 251;

pub const ID_ERROR_INDICATION: u8 = 15;

pub const ID_ETHERNET_TYPE: u16 = 305;

pub const ID_EXPECTED_UE_BEHAVIOUR: u16 = 196;

pub const ID_EXTENDED_REPETITION_PERIOD: u16 = 144;

pub const ID_GERA_NTO_LTEHO_INFORMATION_RES: u16 = 55;

pub const ID_GUMMEI_ID: u16 = 75;

pub const ID_GUMMEI_LIST: u16 = 154;

pub const ID_GUMMEI_TYPE: u16 = 170;

pub const ID_GW_TRANSPORT_LAYER_ADDRESS: u16 = 155;

pub const ID_GW_CONTEXT_RELEASE_INDICATION: u16 = 164;

pub const ID_GLOBAL_ENB_ID: u16 = 59;

pub const ID_HO_CAUSE: u16 = 168;

pub const ID_HANDOVER_CANCEL: u8 = 4;

pub const ID_HANDOVER_FLAG: u16 = 266;

pub const ID_HANDOVER_NOTIFICATION: u8 = 2;

pub const ID_HANDOVER_PREPARATION: u8 = 0;

pub const ID_HANDOVER_RESOURCE_ALLOCATION: u8 = 1;

pub const ID_HANDOVER_RESTRICTION_LIST: u16 = 41;

pub const ID_HANDOVER_SUCCESS: u8 = 64;

pub const ID_HANDOVER_TYPE: u16 = 1;

pub const ID_IAB_AUTHORIZED: u16 = 301;

pub const ID_IAB_NODE_INDICATION: u16 = 302;

pub const ID_IAB_SUPPORTED: u16 = 303;

pub const ID_IM_SVOICE_EP_SFALLBACKFROM5_G: u16 = 296;

pub const ID_INFORMATION_ON_RECOMMENDED_CELLS_AND_EN_BS_FOR_PAGING: u16 = 213;

pub const ID_INITIAL_CONTEXT_SETUP: u8 = 9;

pub const ID_INTER_SYSTEM_INFORMATION_TRANSFER_TYPE_EDT: u16 = 121;

pub const ID_INTER_SYSTEM_INFORMATION_TRANSFER_TYPE_MDT: u16 = 122;

pub const ID_INTERSYSTEM_MEASUREMENT_CONFIGURATION: u16 = 311;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_ECT: u16 = 310;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_MCT: u16 = 309;

pub const ID_KILL: u8 = 43;

pub const ID_KILL_ALL_WARNING_MESSAGES: u16 = 191;

pub const ID_LHN_ID: u16 = 186;

pub const ID_LP_PA_PDU: u16 = 147;

pub const ID_LTE_M_INDICATION: u16 = 272;

pub const ID_LAST_NG_RANPLMN_IDENTITY: u16 = 290;

pub const ID_LOCATION_REPORT: u8 = 33;

pub const ID_LOCATION_REPORTING_CONTROL: u8 = 31;

pub const ID_LOCATION_REPORTING_FAILURE_INDICATION: u8 = 32;

pub const ID_LOGGED_MBSFNMDT: u16 = 197;

pub const ID_M3_CONFIGURATION: u16 = 171;

pub const ID_M4_CONFIGURATION: u16 = 172;

pub const ID_M5_CONFIGURATION: u16 = 173;

pub const ID_M6_CONFIGURATION: u16 = 220;

pub const ID_M7_CONFIGURATION: u16 = 221;

pub const ID_MDT_LOCATION_INFO: u16 = 174;

pub const ID_MDT_CONFIGURATION: u16 = 162;

pub const ID_MDT_CONFIGURATION_NR: u16 = 316;

pub const ID_MME_GROUP_ID: u16 = 223;

pub const ID_MME_UE_S1AP_ID: u16 = 0;

pub const ID_MME_UE_S1AP_ID_2: u16 = 158;

pub const ID_MMECP_RELOCATION_INDICATION: u8 = 61;

pub const ID_MME_CONFIGURATION_TRANSFER: u8 = 41;

pub const ID_MME_CONFIGURATION_UPDATE: u8 = 30;

pub const ID_MME_DIRECT_INFORMATION_TRANSFER: u8 = 38;

pub const ID_MME_EARLY_STATUS_TRANSFER: u8 = 66;

pub const ID_MME_RELAY_SUPPORT_INDICATOR: u16 = 163;

pub const ID_MME_STATUS_TRANSFER: u8 = 25;

pub const ID_MM_ENAME: u16 = 61;

pub const ID_MS_CLASSMARK2: u16 = 132;

pub const ID_MS_CLASSMARK3: u16 = 133;

pub const ID_MANAGEMENT_BASED_MDT_ALLOWED: u16 = 165;

pub const ID_MANAGEMENT_BASED_MDTPLMN_LIST: u16 = 177;

pub const ID_MASKED_IMEISV: u16 = 192;

pub const ID_MESSAGE_IDENTIFIER: u16 = 111;

pub const ID_MOBILITY_INFORMATION: u16 = 175;

pub const ID_MUTING_AVAILABILITY_INDICATION: u16 = 207;

pub const ID_MUTING_PATTERN_INFORMATION: u16 = 208;

pub const ID_NAS_DOWNLINK_COUNT: u16 = 126;

pub const ID_NAS_PDU: u16 = 26;

pub const ID_NAS_DELIVERY_INDICATION: u8 = 57;

pub const ID_NAS_NON_DELIVERY_INDICATION: u8 = 16;

pub const ID_NAS_SECURITY_PARAMETERSFROM_E_UTRAN: u16 = 135;

pub const ID_NAS_SECURITY_PARAMETERSTO_E_UTRAN: u16 = 136;

pub const ID_NB_IO_T_DEFAULT_PAGING_DRX: u16 = 234;

pub const ID_NB_IO_T_PAGING_E_DRX_INFORMATION: u16 = 239;

pub const ID_NB_IO_T_PAGING_DRX: u16 = 324;

pub const ID_NB_IO_T_RLF_REPORT_CONTAINER: u16 = 313;

pub const ID_NB_IO_T_UE_IDENTITY_INDEX_VALUE: u16 = 244;

pub const ID_NRUE_SECURITY_CAPABILITIES: u16 = 269;

pub const ID_NRUE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 307;

pub const ID_NRV2X_SERVICES_AUTHORIZED: u16 = 306;

pub const ID_N_RRESTRICTIONIN5_GS: u16 = 287;

pub const ID_N_RRESTRICTIONIN_EP_SAS_SECONDARY_RAT: u16 = 261;

pub const ID_NOTIFY_SOURCEE_NB: u16 = 320;

pub const ID_NUMBEROF_BROADCAST_REQUEST: u16 = 115;

pub const ID_OVERLOAD_RESPONSE: u16 = 101;

pub const ID_OVERLOAD_START: u8 = 34;

pub const ID_OVERLOAD_STOP: u8 = 35;

pub const ID_PC5_QO_S_PARAMETERS: u16 = 308;

pub const ID_PS_SERVICE_NOT_AVAILABLE: u16 = 150;

pub const ID_PS_CELL_INFORMATION: u16 = 288;

pub const ID_PWS_FAILURE_INDICATION: u8 = 51;

pub const ID_PWS_RESTART_INDICATION: u8 = 49;

pub const ID_PW_SFAILED_ECGI_LIST: u16 = 222;

pub const ID_PAGING: u8 = 10;

pub const ID_PAGING_E_DRX_INFORMATION: u16 = 227;

pub const ID_PAGING_PRIORITY: u16 = 151;

pub const ID_PATH_SWITCH_REQUEST: u8 = 3;

pub const ID_PENDING_DATA_INDICATION: u16 = 283;

pub const ID_PRIVACY_INDICATOR: u16 = 166;

pub const ID_PRIVATE_MESSAGE: u8 = 39;

pub const ID_PRO_SE_AUTHORIZED: u16 = 195;

pub const ID_PRO_SE_U_ETO_NETWORK_RELAYING: u16 = 216;

pub const ID_RAT_TYPE: u16 = 232;

pub const ID_RRC_ESTABLISHMENT_CAUSE: u16 = 134;

pub const ID_RRC_RESUME_CAUSE: u16 = 245;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_EXTENDED: u16 = 181;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_PDCP_S_NLENGTH18: u16 = 219;

pub const ID_RECOMMENDED_CELL_ITEM: u16 = 214;

pub const ID_RECOMMENDED_ENB_ITEM: u16 = 215;

pub const ID_REGISTERED_LAI: u16 = 159;

pub const ID_RELATIVE_MME_CAPACITY: u16 = 87;

pub const ID_RELAY_NODE_INDICATOR: u16 = 160;

pub const ID_REPETITION_PERIOD: u16 = 114;

pub const ID_REQUEST_TYPE: u16 = 98;

pub const ID_REQUEST_TYPE_ADDITIONAL_INFO: u16 = 298;

pub const ID_REROUTE_NAS_REQUEST: u8 = 52;

pub const ID_RESET: u8 = 14;

pub const ID_RESET_TYPE: u16 = 92;

pub const ID_RETRIEVE_UE_INFORMATION: u8 = 58;

pub const ID_ROUTING_ID: u16 = 148;

pub const ID_S_TMSI: u16 = 96;

pub const ID_S1_MESSAGE: u16 = 225;

pub const ID_S1_SETUP: u8 = 17;

pub const ID_SIPTO_CORRELATION_ID: u16 = 183;

pub const ID_SIPTO_L_GW_TRANSPORT_LAYER_ADDRESS: u16 = 184;

pub const ID_SON_INFORMATION_REPORT: u16 = 206;

pub const ID_SON_CONFIGURATION_TRANSFER_ECT: u16 = 129;

pub const ID_SON_CONFIGURATION_TRANSFER_MCT: u16 = 130;

pub const ID_SRVCCHO_INDICATION: u16 = 125;

pub const ID_SRVCC_OPERATION_NOT_POSSIBLE: u16 = 243;

pub const ID_SRVCC_OPERATION_POSSIBLE: u16 = 124;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT: u8 = 62;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT_ITEM: u16 = 265;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT_LIST: u16 = 264;

pub const ID_SECONDARY_RAT_DATA_USAGE_REQUEST: u16 = 268;

pub const ID_SECURITY_CONTEXT: u16 = 40;

pub const ID_SECURITY_KEY: u16 = 73;

pub const ID_SERIAL_NUMBER: u16 = 112;

pub const ID_SERVED_DC_NS: u16 = 247;

pub const ID_SERVED_GUMME_IS: u16 = 105;

pub const ID_SERVED_PLM_NS: u16 = 63;

pub const ID_SIGNALLING_BASED_MDTPLMN_LIST: u16 = 178;

pub const ID_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER: u16 = 104;

pub const ID_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER_SECONDARY: u16 = 138;

pub const ID_SOURCE_ID: u16 = 3;

pub const ID_SOURCE_MME_GUMMEI: u16 = 157;

pub const ID_SOURCE_MME_UE_S1AP_ID: u16 = 88;

pub const ID_SOURCE_NODE_ID: u16 = 312;

pub const ID_SUBSCRIBER_PROFILE_I_DFOR_RFP: u16 = 106;

pub const ID_SUBSCRIPTION_BASED_UE_DIFFERENTIATION_INFO: u16 = 278;

pub const ID_SUPPORTED_T_AS: u16 = 64;

pub const ID_SYNCHRONISATION_INFORMATION: u16 = 209;

pub const ID_TAI: u16 = 67;

pub const ID_TAI_ITEM: u16 = 47;

pub const ID_TAI_LIST: u16 = 46;

pub const ID_TAI_LIST_FOR_RESTART: u16 = 188;

pub const ID_TARGET_TO_SOURCE_TRANSPARENT_CONTAINER: u16 = 123;

pub const ID_TARGET_TO_SOURCE_TRANSPARENT_CONTAINER_SECONDARY: u16 = 139;

pub const ID_TARGET_ID: u16 = 4;

pub const ID_TIME_SYNCHRONISATION_INFO: u16 = 149;

pub const ID_TIME_UE_STAYED_IN_CELL_ENHANCED_GRANULARITY: u16 = 167;

pub const ID_TIME_SINCE_SECONDARY_NODE_RELEASE: u16 = 297;

pub const ID_TIME_TO_WAIT: u16 = 65;

pub const ID_TRACE_ACTIVATION: u16 = 25;

pub const ID_TRACE_COLLECTION_ENTITY_IP_ADDRESS: u16 = 131;

pub const ID_TRACE_COLLECTION_ENTITY_URI: u16 = 325;

pub const ID_TRACE_FAILURE_INDICATION: u8 = 28;

pub const ID_TRACE_START: u8 = 27;

pub const ID_TRAFFIC_LOAD_REDUCTION_INDICATION: u16 = 161;

pub const ID_TRANSPORT_INFORMATION: u16 = 185;

pub const ID_TUNNEL_INFORMATION_FOR_BBF: u16 = 176;

pub const ID_UE_APPLICATION_LAYER_MEASUREMENT_CAPABILITY: u16 = 263;

pub const ID_UE_LEVEL_QO_S_PARAMETERS: u16 = 252;

pub const ID_UE_RETENTION_INFORMATION: u16 = 228;

pub const ID_UE_S1AP_I_DS: u16 = 99;

pub const ID_UE_USAGE_TYPE: u16 = 230;

pub const ID_UE_ASSOCIATED_LOGICAL_S1_CONNECTION_ITEM: u16 = 91;

pub const ID_UE_ASSOCIATED_LOGICAL_S1_CONNECTION_LIST_RES_ACK: u16 = 93;

pub const ID_UE_APP_LAYER_MEAS_CONFIG: u16 = 262;

pub const ID_UE_CAPABILITY_INFO_INDICATION: u8 = 22;

pub const ID_UE_CAPABILITY_INFO_REQUEST: u16 = 275;

pub const ID_UE_CONTEXT_MODIFICATION: u8 = 21;

pub const ID_UE_CONTEXT_MODIFICATION_INDICATION: u8 = 53;

pub const ID_UE_CONTEXT_RELEASE: u8 = 23;

pub const ID_UE_CONTEXT_RELEASE_REQUEST: u8 = 18;

pub const ID_UE_CONTEXT_RESUME: u8 = 56;

pub const ID_UE_CONTEXT_SUSPEND: u8 = 55;

pub const ID_UE_IDENTITY_INDEX_VALUE: u16 = 80;

pub const ID_UE_INFORMATION_TRANSFER: u8 = 59;

pub const ID_UE_PAGING_ID: u16 = 43;

pub const ID_UE_RADIO_CAPABILITY: u16 = 74;

pub const ID_UE_RADIO_CAPABILITY_NR_FORMAT: u16 = 315;

pub const ID_UE_RADIO_CAPABILITY_FOR_PAGING: u16 = 198;

pub const ID_UE_RADIO_CAPABILITY_ID: u16 = 314;

pub const ID_UE_RADIO_CAPABILITY_ID_MAPPING: u8 = 63;

pub const ID_UE_RADIO_CAPABILITY_MATCH: u8 = 48;

pub const ID_UE_SECURITY_CAPABILITIES: u16 = 107;

pub const ID_UE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 248;

pub const ID_UE_USER_PLANE_C_IO_T_SUPPORT_INDICATOR: u16 = 241;

pub const ID_UL_CP_SECURITY_INFORMATION: u16 = 254;

pub const ID_ULCOUNT_VALUE_EXTENDED: u16 = 179;

pub const ID_ULCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 217;

pub const ID_UTRA_NTO_LTEHO_INFORMATION_RES: u16 = 57;

pub const ID_UNLICENSED_SPECTRUM_RESTRICTION: u16 = 270;

pub const ID_UPLINK_PACKET_LOSS_RATE: u16 = 274;

pub const ID_UPLINK_S1CDMA2000TUNNELLING: u8 = 20;

pub const ID_USER_LOCATION_INFORMATION: u16 = 189;

pub const ID_V2X_SERVICES_AUTHORIZED: u16 = 240;

pub const ID_VOICE_SUPPORT_MATCH_INDICATOR: u16 = 169;

pub const ID_WLAN_MEASUREMENT_CONFIGURATION: u16 = 285;

pub const ID_WUS_ASSISTANCE_INFORMATION: u16 = 323;

pub const ID_WARNING_AREA_COORDINATES: u16 = 286;

pub const ID_WARNING_AREA_LIST: u16 = 113;

pub const ID_WARNING_MESSAGE_CONTENTS: u16 = 119;

pub const ID_WARNING_SECURITY_INFO: u16 = 117;

pub const ID_WARNING_TYPE: u16 = 116;

pub const ID_WRITE_REPLACE_WARNING: u8 = 36;

pub const ID_CDMA2000_HO_REQUIRED_INDICATION: u16 = 84;

pub const ID_CDMA2000_HO_STATUS: u16 = 83;

pub const ID_CDMA2000_ONE_XRAND: u16 = 97;

pub const ID_CDMA2000_ONE_XSRVCC_INFO: u16 = 102;

pub const ID_CDMA2000_PDU: u16 = 70;

pub const ID_CDMA2000_RAT_TYPE: u16 = 71;

pub const ID_CDMA2000_SECTOR_ID: u16 = 72;

pub const ID_DOWNLINK_NAS_TRANSPORT: u8 = 11;

pub const ID_DOWNLINK_NON_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 46;

pub const ID_DOWNLINK_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 44;

pub const ID_E_NB_EARLY_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 321;

pub const ID_E_NB_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 90;

pub const ID_E_NB_UE_S1AP_ID: u16 = 8;

pub const ID_E_NBCP_RELOCATION_INDICATION: u8 = 60;

pub const ID_E_NB_CONFIGURATION_TRANSFER: u8 = 40;

pub const ID_E_NB_DIRECT_INFORMATION_TRANSFER: u8 = 37;

pub const ID_E_NB_EARLY_STATUS_TRANSFER: u8 = 65;

pub const ID_E_NB_INDIRECT_X2_TRANSPORT_LAYER_ADDRESSES: u16 = 193;

pub const ID_E_NB_STATUS_TRANSFER: u8 = 24;

pub const ID_E_NBX2_EXTENDED_TRANSPORT_LAYER_ADDRESSES: u16 = 153;

pub const ID_E_N_BNAME: u16 = 60;

pub const ID_EXTENDED_UE_IDENTITY_INDEX_VALUE: u16 = 231;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_DL: u16 = 257;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_UL: u16 = 258;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_DL: u16 = 255;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_UL: u16 = 256;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_DL: u16 = 259;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_UL: u16 = 260;

pub const ID_INITIAL_UE_MESSAGE: u8 = 12;

pub const ID_PAGING_DRX: u16 = 44;

pub const ID_SERVICE_TYPE: u16 = 276;

pub const ID_U_E_HISTORY_INFORMATION_FROM_THE_UE: u16 = 194;

pub const ID_U_EAGGREGATE_MAXIMUM_BITRATE: u16 = 66;

pub const ID_UPLINK_NAS_TRANSPORT: u8 = 13;

pub const ID_UPLINK_NON_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 47;

pub const ID_UPLINK_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 45;

pub const ID_X2_TNL_CONFIGURATION_INFO: u16 = 152;

pub const MAX_EARFCN: i64 = 262143;

pub const MAX_NARFCN: i64 = 32;

pub const MAX_PRIVATE_I_ES: i64 = 65535;

pub const MAX_PROTOCOL_EXTENSIONS: i64 = 65535;

pub const MAX_PROTOCOL_I_ES: i64 = 65535;

pub const MAX_RS_INDEX_CELL_QUAL: i64 = 16;

pub const MAXNOOF_BPLM_NS: i64 = 6;

pub const MAXNOOF_BLUETOOTH_NAME: i64 = 4;

pub const MAXNOOF_CS_GS: i64 = 256;

pub const MAXNOOF_CELL_ID: i64 = 65535;

pub const MAXNOOF_CELL_I_DFOR_MDT: i64 = 32;

pub const MAXNOOF_CELL_I_DFOR_QMC: i64 = 32;

pub const MAXNOOF_CELLIN_EAI: i64 = 65535;

pub const MAXNOOF_CELLIN_TAI: i64 = 65535;

pub const MAXNOOF_CELLINE_NB: i64 = 256;

pub const MAXNOOF_CELLSFOR_RESTART: i64 = 256;

pub const MAXNOOF_CELLSIN_UE_HISTORY_INFO: i64 = 16;

pub const MAXNOOF_CELLSINE_NB: i64 = 256;

pub const MAXNOOF_CONNECTEDENG_N_BS: i64 = 256;

pub const MAXNOOF_DC_NS: i64 = 32;

pub const MAXNOOF_E_RA_BS: i64 = 256;

pub const MAXNOOF_EPLM_NS: i64 = 15;

pub const MAXNOOF_EPLM_NS_PLUS_ONE: i64 = 16;

pub const MAXNOOF_EMERGENCY_AREA_ID: i64 = 65535;

pub const MAXNOOF_ERRORS: i64 = 256;

pub const MAXNOOF_FORB_LA_CS: i64 = 4096;

pub const MAXNOOF_FORB_TA_CS: i64 = 4096;

pub const MAXNOOF_GROUP_I_DS: i64 = 65535;

pub const MAXNOOF_IRAT_REPORTING_CELLS: i64 = 128;

pub const MAXNOOF_INDIVIDUAL_S1_CONNECTIONS_TO_RESET: i64 = 256;

pub const MAXNOOF_MBSFN_AREA_MDT: i64 = 8;

pub const MAXNOOF_MDTPLM_NS: i64 = 16;

pub const MAXNOOF_MME_CS: i64 = 256;

pub const MAXNOOF_PC5_QO_S_FLOWS: i64 = 2048;

pub const MAXNOOF_PLM_NFOR_QMC: i64 = 16;

pub const MAXNOOF_PLM_NS_PER_MME: i64 = 32;

pub const MAXNOOF_RA_TS: i64 = 8;

pub const MAXNOOF_RECOMMENDED_CELLS: i64 = 16;

pub const MAXNOOF_RECOMMENDED_EN_BS: i64 = 16;

pub const MAXNOOF_RESTART_EMERGENCY_AREA_I_DS: i64 = 256;

pub const MAXNOOF_RESTART_TA_IS: i64 = 2048;

pub const MAXNOOF_TA_CS: i64 = 256;

pub const MAXNOOF_TA_IFOR_WARNING: i64 = 65535;

pub const MAXNOOF_TA_IS: i64 = 256;

pub const MAXNOOF_T_AFOR_MDT: i64 = 8;

pub const MAXNOOF_T_AFOR_QMC: i64 = 8;

pub const MAXNOOF_WLAN_NAME: i64 = 4;

pub const MAXNOOFCANDIDATE_CELLS: i64 = 16;

pub const MAXNOOFE_NBX2_EXT_TL_AS: i64 = 16;

pub const MAXNOOFE_NBX2GTPTL_AS: i64 = 16;

pub const MAXNOOFE_NBX2TL_AS: i64 = 2;

pub const MAXNOOFFREQUENCIES: i64 = 64;

pub const MAXNOOFTIMEPERIODS: i64 = 2;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ActivatedCellsList(pub Vec<ActivatedCellsList_Item>);
impl entropic::Entropic for ActivatedCellsList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ActivatedCellsList_Item::from_finite_entropy(source)?);
        }
        Ok(ActivatedCellsList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ActivatedCellsList_Item {
    pub cell_id: ActivatedCellsList_ItemCell_ID,
}
impl entropic::Entropic for ActivatedCellsList_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id: ActivatedCellsList_ItemCell_ID = __entropic_internal_source.entropic()?;
        Ok(Self { cell_id })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Additional_GUTI {
    pub gummei: GUMMEI,
    pub m_tmsi: M_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Additional_GUTIIE_Extensions>,
}
impl entropic::Entropic for Additional_GUTI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let gummei: GUMMEI = __entropic_internal_source.entropic()?;
        let m_tmsi: M_TMSI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Additional_GUTIIE_Extensions> = None;
        Ok(Self {
            gummei,
            m_tmsi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.gummei.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.m_tmsi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AdditionalCSFallbackIndicator(pub u8);
impl AdditionalCSFallbackIndicator {
    pub const NO_RESTRICTION: u8 = 0u8;
    pub const RESTRICTION: u8 = 1u8;
}
impl entropic::Entropic for AdditionalCSFallbackIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(AdditionalCSFallbackIndicator(
            source.get_uniform_range(0..=1)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct AdditionalRRMPriorityIndex(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for AdditionalRRMPriorityIndex {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(32..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(AdditionalRRMPriorityIndex(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 32);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AerialUEsubscriptionInformation(pub u8);
impl AerialUEsubscriptionInformation {
    pub const ALLOWED: u8 = 0u8;
    pub const NOT_ALLOWED: u8 = 1u8;
}
impl entropic::Entropic for AerialUEsubscriptionInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(AerialUEsubscriptionInformation(
            source.get_uniform_range(0..=1)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: Pre_emptionCapability,
    pub pre_emption_vulnerability: Pre_emptionVulnerability,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions>,
}
impl entropic::Entropic for AllocationAndRetentionPriority {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let priority_level: PriorityLevel = __entropic_internal_source.entropic()?;
        let pre_emption_capability: Pre_emptionCapability =
            __entropic_internal_source.entropic()?;
        let pre_emption_vulnerability: Pre_emptionVulnerability =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions> = None;
        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .priority_level
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pre_emption_capability
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pre_emption_vulnerability
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum AreaScopeOfMDT {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(AreaScopeOfMDT_pLMNWide),
    #[asn(key = 0, extended = true)]
    TAIBased(TAIBasedMDT),
}
impl asn1_codecs::Asn1Choice for AreaScopeOfMDT {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            AreaScopeOfMDT::CellBased(_) => 0u128.try_into().unwrap(),
            AreaScopeOfMDT::TABased(_) => 1u128.try_into().unwrap(),
            AreaScopeOfMDT::PLMNWide(_) => 2u128.try_into().unwrap(),
            AreaScopeOfMDT::TAIBased(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum AreaScopeOfQMC {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedQMC),
    #[asn(key = 1, extended = false)]
    TABased(TABasedQMC),
    #[asn(key = 2, extended = false)]
    TAIBased(TAIBasedQMC),
    #[asn(key = 3, extended = false)]
    PLMNAreaBased(PLMNAreaBasedQMC),
}
impl asn1_codecs::Asn1Choice for AreaScopeOfQMC {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            AreaScopeOfQMC::CellBased(_) => 0u128.try_into().unwrap(),
            AreaScopeOfQMC::TABased(_) => 1u128.try_into().unwrap(),
            AreaScopeOfQMC::TAIBased(_) => 2u128.try_into().unwrap(),
            AreaScopeOfQMC::PLMNAreaBased(_) => 3u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForCECapableUEs {
    pub cell_identifier_and_ce_level_for_ce_capable_u_es: CellIdentifierAndCELevelForCECapableUEs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForCECapableUEsIE_Extensions>,
}
impl entropic::Entropic for AssistanceDataForCECapableUEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_identifier_and_ce_level_for_ce_capable_u_es : CellIdentifierAndCELevelForCECapableUEs = __entropic_internal_source . entropic () ? ;
        let ie_extensions: Option<AssistanceDataForCECapableUEsIE_Extensions> = None;
        Ok(Self {
            cell_identifier_and_ce_level_for_ce_capable_u_es,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cell_identifier_and_ce_level_for_ce_capable_u_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct AssistanceDataForPaging {
    #[asn(optional_idx = 0)]
    pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
    #[asn(optional_idx = 1)]
    pub assistance_data_for_ce_capable_u_es: Option<AssistanceDataForCECapableUEs>,
    #[asn(optional_idx = 2)]
    pub paging_attempt_information: Option<PagingAttemptInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<AssistanceDataForPagingIE_Extensions>,
}
impl entropic::Entropic for AssistanceDataForPaging {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells> =
            __entropic_internal_source.entropic()?;
        let assistance_data_for_ce_capable_u_es: Option<AssistanceDataForCECapableUEs> =
            __entropic_internal_source.entropic()?;
        let paging_attempt_information: Option<PagingAttemptInformation> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<AssistanceDataForPagingIE_Extensions> = None;
        Ok(Self {
            assistance_data_for_recommended_cells,
            assistance_data_for_ce_capable_u_es,
            paging_attempt_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .assistance_data_for_recommended_cells
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .assistance_data_for_ce_capable_u_es
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .paging_attempt_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForRecommendedCells {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions>,
}
impl entropic::Entropic for AssistanceDataForRecommendedCells {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let recommended_cells_for_paging: RecommendedCellsForPaging =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions> = None;
        Ok(Self {
            recommended_cells_for_paging,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .recommended_cells_for_paging
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct BPLMNs(pub Vec<PLMNidentity>);
impl entropic::Entropic for BPLMNs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(6, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNidentity::from_finite_entropy(source)?);
        }
        Ok(BPLMNs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(6, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BearerType(pub u8);
impl BearerType {
    pub const NON_IP: u8 = 0u8;
}
impl entropic::Entropic for BearerType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(BearerType(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Bearers_SubjectToEarlyStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    pub dlcount_pdcp_s_nlength: DLCOUNT_PDCP_SNlength,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions>,
}
impl entropic::Entropic for Bearers_SubjectToEarlyStatusTransfer_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let dlcount_pdcp_s_nlength: DLCOUNT_PDCP_SNlength =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            dlcount_pdcp_s_nlength,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dlcount_pdcp_s_nlength
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Bearers_SubjectToEarlyStatusTransferList(
    pub Vec<Bearers_SubjectToEarlyStatusTransferList_Entry>,
);
impl entropic::Entropic for Bearers_SubjectToEarlyStatusTransferList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Bearers_SubjectToEarlyStatusTransferList_Entry::from_finite_entropy(source)?);
        }
        Ok(Bearers_SubjectToEarlyStatusTransferList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Bearers_SubjectToStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    pub ul_coun_tvalue: COUNTvalue,
    pub dl_coun_tvalue: COUNTvalue,
    #[asn(optional_idx = 0)]
    pub receive_statusof_ulpdcpsd_us: Option<ReceiveStatusofULPDCPSDUs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Bearers_SubjectToStatusTransfer_ItemIE_Extensions>,
}
impl entropic::Entropic for Bearers_SubjectToStatusTransfer_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let ul_coun_tvalue: COUNTvalue = __entropic_internal_source.entropic()?;
        let dl_coun_tvalue: COUNTvalue = __entropic_internal_source.entropic()?;
        let receive_statusof_ulpdcpsd_us: Option<ReceiveStatusofULPDCPSDUs> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Bearers_SubjectToStatusTransfer_ItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            ul_coun_tvalue,
            dl_coun_tvalue,
            receive_statusof_ulpdcpsd_us,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_coun_tvalue
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_coun_tvalue
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .receive_statusof_ulpdcpsd_us
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Bearers_SubjectToStatusTransferList(pub Vec<Bearers_SubjectToStatusTransferList_Entry>);
impl entropic::Entropic for Bearers_SubjectToStatusTransferList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Bearers_SubjectToStatusTransferList_Entry::from_finite_entropy(source)?);
        }
        Ok(Bearers_SubjectToStatusTransferList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10000000000")]
pub struct BitRate(pub u64);
impl entropic::Entropic for BitRate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(BitRate(source.get_uniform_range(0..=10000000000)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=10000000000 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasConfig(pub u8);
impl BluetoothMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl entropic::Entropic for BluetoothMeasConfig {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(BluetoothMeasConfig(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BluetoothMeasConfigNameList(pub Vec<BluetoothName>);
impl entropic::Entropic for BluetoothMeasConfigNameList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(BluetoothName::from_finite_entropy(source)?);
        }
        Ok(BluetoothMeasConfigNameList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    #[asn(optional_idx = 0)]
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for BluetoothMeasurementConfiguration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let bluetooth_meas_config: BluetoothMeasConfig = __entropic_internal_source.entropic()?;
        let bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList> =
            __entropic_internal_source.entropic()?;
        let bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            bluetooth_meas_config,
            bluetooth_meas_config_name_list,
            bt_rssi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .bluetooth_meas_config
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .bluetooth_meas_config_name_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.bt_rssi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BluetoothName(pub Vec<u8>);
impl entropic::Entropic for BluetoothName {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(BluetoothName(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum BroadcastCancelledAreaList {
    #[asn(key = 0, extended = false)]
    CellID_Cancelled(CellID_Cancelled),
    #[asn(key = 1, extended = false)]
    TAI_Cancelled(TAI_Cancelled),
    #[asn(key = 2, extended = false)]
    EmergencyAreaID_Cancelled(EmergencyAreaID_Cancelled),
}
impl asn1_codecs::Asn1Choice for BroadcastCancelledAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            BroadcastCancelledAreaList::CellID_Cancelled(_) => 0u128.try_into().unwrap(),
            BroadcastCancelledAreaList::TAI_Cancelled(_) => 1u128.try_into().unwrap(),
            BroadcastCancelledAreaList::EmergencyAreaID_Cancelled(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum BroadcastCompletedAreaList {
    #[asn(key = 0, extended = false)]
    CellID_Broadcast(CellID_Broadcast),
    #[asn(key = 1, extended = false)]
    TAI_Broadcast(TAI_Broadcast),
    #[asn(key = 2, extended = false)]
    EmergencyAreaID_Broadcast(EmergencyAreaID_Broadcast),
}
impl asn1_codecs::Asn1Choice for BroadcastCompletedAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            BroadcastCompletedAreaList::CellID_Broadcast(_) => 0u128.try_into().unwrap(),
            BroadcastCompletedAreaList::TAI_Broadcast(_) => 1u128.try_into().unwrap(),
            BroadcastCompletedAreaList::EmergencyAreaID_Broadcast(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CE_ModeBRestricted(pub u8);
impl CE_ModeBRestricted {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}
impl entropic::Entropic for CE_ModeBRestricted {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CE_ModeBRestricted(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CE_mode_B_SupportIndicator(pub u8);
impl CE_mode_B_SupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
}
impl entropic::Entropic for CE_mode_B_SupportIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CE_mode_B_SupportIndicator(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CELevel(pub Vec<u8>);

impl entropic::Entropic for CELevel {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let paging_info: crate::celevel::UEPagingCoverageInformation = source.entropic()?;
        let mut encoded = asn1_codecs::PerCodecData::new_aper();
        paging_info.aper_encode(&mut encoded).unwrap();
        Ok(CELevel(encoded.into_bytes()))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut decode_bytes = asn1_codecs::PerCodecData::from_slice_aper(self.0.as_slice());
        let paging_info = crate::celevel::UEPagingCoverageInformation::aper_decode(&mut decode_bytes).unwrap();
        Ok(sink.put_entropic(&paging_info)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CGI {
    pub plm_nidentity: PLMNidentity,
    pub lac: LAC,
    pub ci: CI,
    #[asn(optional_idx = 0)]
    pub rac: Option<RAC>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CGIIE_Extensions>,
}
impl entropic::Entropic for CGI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let lac: LAC = __entropic_internal_source.entropic()?;
        let ci: CI = __entropic_internal_source.entropic()?;
        let rac: Option<RAC> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CGIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            lac,
            ci,
            rac,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.lac.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.ci.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.rac.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct CI(pub Vec<u8>);
impl entropic::Entropic for CI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(CI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CNDomain(pub u8);
impl CNDomain {
    pub const PS: u8 = 0u8;
    pub const CS: u8 = 1u8;
}
impl entropic::Entropic for CNDomain {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CNDomain(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CNType(pub u8);
impl CNType {
    pub const FIVE_GC_FORBIDDEN: u8 = 0u8;
}
impl entropic::Entropic for CNType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CNType(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CNTypeRestrictions(pub Vec<CNTypeRestrictions_Item>);
impl entropic::Entropic for CNTypeRestrictions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CNTypeRestrictions_Item::from_finite_entropy(source)?);
        }
        Ok(CNTypeRestrictions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CNTypeRestrictions_Item {
    pub plmn_identity: PLMNidentity,
    pub cn_type: CNType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CNTypeRestrictions_ItemIE_Extensions>,
}
impl entropic::Entropic for CNTypeRestrictions_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let cn_type: CNType = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CNTypeRestrictions_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            cn_type,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cn_type.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueExtended {
    pub pdcp_sn_extended: PDCP_SNExtended,
    pub hfn_modified: HFNModified,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueExtendedIE_Extensions>,
}
impl entropic::Entropic for COUNTValueExtended {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pdcp_sn_extended: PDCP_SNExtended = __entropic_internal_source.entropic()?;
        let hfn_modified: HFNModified = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<COUNTValueExtendedIE_Extensions> = None;
        Ok(Self {
            pdcp_sn_extended,
            hfn_modified,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pdcp_sn_extended
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .hfn_modified
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvalue {
    pub pdcp_sn: PDCP_SN,
    pub hfn: HFN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvalueIE_Extensions>,
}
impl entropic::Entropic for COUNTvalue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pdcp_sn: PDCP_SN = __entropic_internal_source.entropic()?;
        let hfn: HFN = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<COUNTvalueIE_Extensions> = None;
        Ok(Self {
            pdcp_sn,
            hfn,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pdcp_sn.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.hfn.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvaluePDCP_SNlength18 {
    pub pdcp_s_nlength18: PDCP_SNlength18,
    pub hf_nfor_pdcp_s_nlength18: HFNforPDCP_SNlength18,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvaluePDCP_SNlength18IE_Extensions>,
}
impl entropic::Entropic for COUNTvaluePDCP_SNlength18 {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pdcp_s_nlength18: PDCP_SNlength18 = __entropic_internal_source.entropic()?;
        let hf_nfor_pdcp_s_nlength18: HFNforPDCP_SNlength18 =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<COUNTvaluePDCP_SNlength18IE_Extensions> = None;
        Ok(Self {
            pdcp_s_nlength18,
            hf_nfor_pdcp_s_nlength18,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pdcp_s_nlength18
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .hf_nfor_pdcp_s_nlength18
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CSFallbackIndicator(pub u8);
impl CSFallbackIndicator {
    pub const CS_FALLBACK_REQUIRED: u8 = 0u8;
}
impl entropic::Entropic for CSFallbackIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CSFallbackIndicator(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "27", sz_ub = "27")]
pub struct CSG_Id(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for CSG_Id {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(27, 16383);
        let total_bitlen = source.get_bounded_len(27..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(CSG_Id(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 27);
        let capped_max = std::cmp::min(27, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(27..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CSG_IdList(pub Vec<CSG_IdList_Item>);
impl entropic::Entropic for CSG_IdList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CSG_IdList_Item::from_finite_entropy(source)?);
        }
        Ok(CSG_IdList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSG_IdList_Item {
    pub csg_id: CSG_Id,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CSG_IdList_ItemIE_Extensions>,
}
impl entropic::Entropic for CSG_IdList_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let csg_id: CSG_Id = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CSG_IdList_ItemIE_Extensions> = None;
        Ok(Self {
            csg_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.csg_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CSGMembershipInfo {
    pub csg_membership_status: CSGMembershipStatus,
    pub csg_id: CSG_Id,
    #[asn(optional_idx = 0)]
    pub cell_access_mode: Option<CellAccessMode>,
    #[asn(optional_idx = 1)]
    pub plm_nidentity: Option<PLMNidentity>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<CSGMembershipInfoIE_Extensions>,
}
impl entropic::Entropic for CSGMembershipInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let csg_membership_status: CSGMembershipStatus = __entropic_internal_source.entropic()?;
        let csg_id: CSG_Id = __entropic_internal_source.entropic()?;
        let cell_access_mode: Option<CellAccessMode> = __entropic_internal_source.entropic()?;
        let plm_nidentity: Option<PLMNidentity> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CSGMembershipInfoIE_Extensions> = None;
        Ok(Self {
            csg_membership_status,
            csg_id,
            cell_access_mode,
            plm_nidentity,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .csg_membership_status
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.csg_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .cell_access_mode
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSGMembershipStatus(pub u8);
impl CSGMembershipStatus {
    pub const MEMBER: u8 = 0u8;
    pub const NOT_MEMBER: u8 = 1u8;
}
impl entropic::Entropic for CSGMembershipStatus {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CSGMembershipStatus(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinEAI(pub Vec<CancelledCellinEAI_Item>);
impl entropic::Entropic for CancelledCellinEAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellinEAI_Item::from_finite_entropy(source)?);
        }
        Ok(CancelledCellinEAI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellinEAI_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellinEAI_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellinEAI_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CancelledCellinEAI_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .number_of_broadcasts
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinTAI(pub Vec<CancelledCellinTAI_Item>);
impl entropic::Entropic for CancelledCellinTAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellinTAI_Item::from_finite_entropy(source)?);
        }
        Ok(CancelledCellinTAI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellinTAI_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellinTAI_ItemIE_Extensions>,
}
impl entropic::Entropic for CancelledCellinTAI_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CancelledCellinTAI_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .number_of_broadcasts
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CandidateCellList(pub Vec<IRAT_Cell_ID>);
impl entropic::Entropic for CandidateCellList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(IRAT_Cell_ID::from_finite_entropy(source)?);
        }
        Ok(CandidateCellList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CandidatePCI {
    pub pci: CandidatePCIPCI,
    pub earfcn: CandidatePCIEARFCN,
}
impl entropic::Entropic for CandidatePCI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pci: CandidatePCIPCI = __entropic_internal_source.entropic()?;
        let earfcn: CandidatePCIEARFCN = __entropic_internal_source.entropic()?;
        Ok(Self { pci, earfcn })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pci.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.earfcn.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CandidatePCIList(pub Vec<CandidatePCI>);
impl entropic::Entropic for CandidatePCIList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CandidatePCI::from_finite_entropy(source)?);
        }
        Ok(CandidatePCIList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = true)]
pub enum Cause {
    #[asn(key = 0, extended = false)]
    RadioNetwork(CauseRadioNetwork),
    #[asn(key = 1, extended = false)]
    Transport(CauseTransport),
    #[asn(key = 2, extended = false)]
    Nas(CauseNas),
    #[asn(key = 3, extended = false)]
    Protocol(CauseProtocol),
    #[asn(key = 4, extended = false)]
    Misc(CauseMisc),
}
impl asn1_codecs::Asn1Choice for Cause {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Cause::RadioNetwork(_) => 0u128.try_into().unwrap(),
            Cause::Transport(_) => 1u128.try_into().unwrap(),
            Cause::Nas(_) => 2u128.try_into().unwrap(),
            Cause::Protocol(_) => 3u128.try_into().unwrap(),
            Cause::Misc(_) => 4u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct CauseMisc(pub u8);
impl CauseMisc {
    pub const CONTROL_PROCESSING_OVERLOAD: u8 = 0u8;
    pub const NOT_ENOUGH_USER_PLANE_PROCESSING_RESOURCES: u8 = 1u8;
    pub const HARDWARE_FAILURE: u8 = 2u8;
    pub const OM_INTERVENTION: u8 = 3u8;
    pub const UNSPECIFIED: u8 = 4u8;
    pub const UNKNOWN_PLMN: u8 = 5u8;
}
impl entropic::Entropic for CauseMisc {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CauseMisc(source.get_uniform_range(0..=5)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CauseNas(pub u8);
impl CauseNas {
    pub const NORMAL_RELEASE: u8 = 0u8;
    pub const AUTHENTICATION_FAILURE: u8 = 1u8;
    pub const DETACH: u8 = 2u8;
    pub const UNSPECIFIED: u8 = 3u8;
}
impl entropic::Entropic for CauseNas {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CauseNas(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct CauseProtocol(pub u8);
impl CauseProtocol {
    pub const TRANSFER_SYNTAX_ERROR: u8 = 0u8;
    pub const ABSTRACT_SYNTAX_ERROR_REJECT: u8 = 1u8;
    pub const ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY: u8 = 2u8;
    pub const MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE: u8 = 3u8;
    pub const SEMANTIC_ERROR: u8 = 4u8;
    pub const ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE: u8 = 5u8;
    pub const UNSPECIFIED: u8 = 6u8;
}
impl entropic::Entropic for CauseProtocol {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CauseProtocol(source.get_uniform_range(0..=6)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=6 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "35")]
pub struct CauseRadioNetwork(pub u8);
impl CauseRadioNetwork {
    pub const UNSPECIFIED: u8 = 0u8;
    pub const TX2RELOCOVERALL_EXPIRY: u8 = 1u8;
    pub const SUCCESSFUL_HANDOVER: u8 = 2u8;
    pub const RELEASE_DUE_TO_EUTRAN_GENERATED_REASON: u8 = 3u8;
    pub const HANDOVER_CANCELLED: u8 = 4u8;
    pub const PARTIAL_HANDOVER: u8 = 5u8;
    pub const HO_FAILURE_IN_TARGET_EPC_E_NB_OR_TARGET_SYSTEM: u8 = 6u8;
    pub const HO_TARGET_NOT_ALLOWED: u8 = 7u8;
    pub const T_S1RELOCOVERALL_EXPIRY: u8 = 8u8;
    pub const T_S1RELOCPREP_EXPIRY: u8 = 9u8;
    pub const CELL_NOT_AVAILABLE: u8 = 10u8;
    pub const UNKNOWN_TARGET_ID: u8 = 11u8;
    pub const NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL: u8 = 12u8;
    pub const UNKNOWN_MME_UE_S1AP_ID: u8 = 13u8;
    pub const UNKNOWN_ENB_UE_S1AP_ID: u8 = 14u8;
    pub const UNKNOWN_PAIR_UE_S1AP_ID: u8 = 15u8;
    pub const HANDOVER_DESIRABLE_FOR_RADIO_REASON: u8 = 16u8;
    pub const TIME_CRITICAL_HANDOVER: u8 = 17u8;
    pub const RESOURCE_OPTIMISATION_HANDOVER: u8 = 18u8;
    pub const REDUCE_LOAD_IN_SERVING_CELL: u8 = 19u8;
    pub const USER_INACTIVITY: u8 = 20u8;
    pub const RADIO_CONNECTION_WITH_UE_LOST: u8 = 21u8;
    pub const LOAD_BALANCING_TAU_REQUIRED: u8 = 22u8;
    pub const CS_FALLBACK_TRIGGERED: u8 = 23u8;
    pub const UE_NOT_AVAILABLE_FOR_PS_SERVICE: u8 = 24u8;
    pub const RADIO_RESOURCES_NOT_AVAILABLE: u8 = 25u8;
    pub const FAILURE_IN_RADIO_INTERFACE_PROCEDURE: u8 = 26u8;
    pub const INVALID_QOS_COMBINATION: u8 = 27u8;
    pub const INTERRAT_REDIRECTION: u8 = 28u8;
    pub const INTERACTION_WITH_OTHER_PROCEDURE: u8 = 29u8;
    pub const UNKNOWN_E_RAB_ID: u8 = 30u8;
    pub const MULTIPLE_E_RAB_ID_INSTANCES: u8 = 31u8;
    pub const ENCRYPTION_AND_OR_INTEGRITY_PROTECTION_ALGORITHMS_NOT_SUPPORTED: u8 = 32u8;
    pub const S1_INTRA_SYSTEM_HANDOVER_TRIGGERED: u8 = 33u8;
    pub const S1_INTER_SYSTEM_HANDOVER_TRIGGERED: u8 = 34u8;
    pub const X2_HANDOVER_TRIGGERED: u8 = 35u8;
}
impl entropic::Entropic for CauseRadioNetwork {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CauseRadioNetwork(source.get_uniform_range(0..=35)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=35 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CauseTransport(pub u8);
impl CauseTransport {
    pub const TRANSPORT_RESOURCE_UNAVAILABLE: u8 = 0u8;
    pub const UNSPECIFIED: u8 = 1u8;
}
impl entropic::Entropic for CauseTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CauseTransport(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Cdma2000HORequiredIndication(pub u8);
impl Cdma2000HORequiredIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for Cdma2000HORequiredIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Cdma2000HORequiredIndication(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Cdma2000HOStatus(pub u8);
impl Cdma2000HOStatus {
    pub const H_O_SUCCESS: u8 = 0u8;
    pub const H_O_FAILURE: u8 = 1u8;
}
impl entropic::Entropic for Cdma2000HOStatus {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Cdma2000HOStatus(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXMEID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXMSI(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXPilot(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXRAND(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Cdma2000OneXSRVCCInfo {
    pub cdma2000_one_xmeid: Cdma2000OneXMEID,
    pub cdma2000_one_xmsi: Cdma2000OneXMSI,
    pub cdma2000_one_x_pilot: Cdma2000OneXPilot,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Cdma2000OneXSRVCCInfoIE_Extensions>,
}
impl entropic::Entropic for Cdma2000OneXSRVCCInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cdma2000_one_xmeid: Cdma2000OneXMEID = __entropic_internal_source.entropic()?;
        let cdma2000_one_xmsi: Cdma2000OneXMSI = __entropic_internal_source.entropic()?;
        let cdma2000_one_x_pilot: Cdma2000OneXPilot = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Cdma2000OneXSRVCCInfoIE_Extensions> = None;
        Ok(Self {
            cdma2000_one_xmeid,
            cdma2000_one_xmsi,
            cdma2000_one_x_pilot,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cdma2000_one_xmeid
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .cdma2000_one_xmsi
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .cdma2000_one_x_pilot
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Cdma2000RATType(pub u8);
impl Cdma2000RATType {
    pub const H_RPD: u8 = 0u8;
    pub const ONEX_RTT: u8 = 1u8;
}
impl entropic::Entropic for Cdma2000RATType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Cdma2000RATType(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000SectorID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct Cell_Size(pub u8);
impl Cell_Size {
    pub const VERYSMALL: u8 = 0u8;
    pub const SMALL: u8 = 1u8;
    pub const MEDIUM: u8 = 2u8;
    pub const LARGE: u8 = 3u8;
}
impl entropic::Entropic for Cell_Size {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Cell_Size(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CellAccessMode(pub u8);
impl CellAccessMode {
    pub const HYBRID: u8 = 0u8;
}
impl entropic::Entropic for CellAccessMode {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CellAccessMode(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellActivationCause(pub u8);
impl CellActivationCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl entropic::Entropic for CellActivationCause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CellActivationCause(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellActivationRequest {
    pub cells_to_activate_list: CellsToActivateList,
    #[asn(optional_idx = 0)]
    pub minimum_activation_time: Option<CellActivationRequestMinimumActivationTime>,
}
impl entropic::Entropic for CellActivationRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cells_to_activate_list: CellsToActivateList = __entropic_internal_source.entropic()?;
        let minimum_activation_time: Option<CellActivationRequestMinimumActivationTime> =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            cells_to_activate_list,
            minimum_activation_time,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cells_to_activate_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .minimum_activation_time
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellActivationResponse {
    pub activated_cells_list: ActivatedCellsList,
}
impl entropic::Entropic for CellActivationResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let activated_cells_list: ActivatedCellsList = __entropic_internal_source.entropic()?;
        Ok(Self {
            activated_cells_list,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .activated_cells_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT {
    pub cell_id_listfor_mdt: CellIdListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDTIE_Extensions>,
}
impl entropic::Entropic for CellBasedMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id_listfor_mdt: CellIdListforMDT = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellBasedMDTIE_Extensions> = None;
        Ok(Self {
            cell_id_listfor_mdt,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cell_id_listfor_mdt
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedQMC {
    pub cell_id_listfor_qmc: CellIdListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedQMCIE_Extensions>,
}
impl entropic::Entropic for CellBasedQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id_listfor_qmc: CellIdListforQMC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellBasedQMCIE_Extensions> = None;
        Ok(Self {
            cell_id_listfor_qmc,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cell_id_listfor_qmc
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Broadcast(pub Vec<CellID_Broadcast_Item>);
impl entropic::Entropic for CellID_Broadcast {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellID_Broadcast_Item::from_finite_entropy(source)?);
        }
        Ok(CellID_Broadcast(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellID_Broadcast_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellID_Broadcast_ItemIE_Extensions>,
}
impl entropic::Entropic for CellID_Broadcast_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellID_Broadcast_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Cancelled(pub Vec<CellID_Cancelled_Item>);
impl entropic::Entropic for CellID_Cancelled {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellID_Cancelled_Item::from_finite_entropy(source)?);
        }
        Ok(CellID_Cancelled(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellID_Cancelled_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellID_Cancelled_ItemIE_Extensions>,
}
impl entropic::Entropic for CellID_Cancelled_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let number_of_broadcasts: NumberOfBroadcasts = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellID_Cancelled_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            number_of_broadcasts,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .number_of_broadcasts
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for CellIdListforMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(CellIdListforMDT(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforQMC(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for CellIdListforQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(CellIdListforQMC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIdentifierAndCELevelForCECapableUEs {
    pub global_cell_id: EUTRAN_CGI,
    pub ce_level: CELevel,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIdentifierAndCELevelForCECapableUEsIE_Extensions>,
}
impl entropic::Entropic for CellIdentifierAndCELevelForCECapableUEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_cell_id: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let ce_level: CELevel = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellIdentifierAndCELevelForCECapableUEsIE_Extensions> = None;
        Ok(Self {
            global_cell_id,
            ce_level,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_cell_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.ce_level.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct CellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for CellIdentity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(28, 16383);
        let total_bitlen = source.get_bounded_len(28..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(CellIdentity(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 28);
        let capped_max = std::cmp::min(28, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(28..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellLoadReportingCause(pub u8);
impl CellLoadReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl entropic::Entropic for CellLoadReportingCause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CellLoadReportingCause(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum CellLoadReportingResponse {
    #[asn(key = 0, extended = false)]
    EUTRAN(EUTRANcellLoadReportingResponse),
    #[asn(key = 1, extended = false)]
    UTRAN(CellLoadReportingResponse_uTRAN),
    #[asn(key = 2, extended = false)]
    GERAN(CellLoadReportingResponse_gERAN),
    #[asn(key = 0, extended = true)]
    EHRPD(EHRPDSectorLoadReportingResponse),
}
impl asn1_codecs::Asn1Choice for CellLoadReportingResponse {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            CellLoadReportingResponse::EUTRAN(_) => 0u128.try_into().unwrap(),
            CellLoadReportingResponse::UTRAN(_) => 1u128.try_into().unwrap(),
            CellLoadReportingResponse::GERAN(_) => 2u128.try_into().unwrap(),
            CellLoadReportingResponse::EHRPD(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellStateIndication {
    pub notification_cell_list: NotificationCellList,
}
impl entropic::Entropic for CellStateIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let notification_cell_list: NotificationCellList = __entropic_internal_source.entropic()?;
        Ok(Self {
            notification_cell_list,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .notification_cell_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellStateIndicationCause(pub u8);
impl CellStateIndicationCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl entropic::Entropic for CellStateIndicationCause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CellStateIndicationCause(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellTrafficTrace {
    pub protocol_i_es: CellTrafficTraceProtocolIEs,
}
impl entropic::Entropic for CellTrafficTrace {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: CellTrafficTraceProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellType {
    pub cell_size: Cell_Size,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellTypeIE_Extensions>,
}
impl entropic::Entropic for CellType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_size: Cell_Size = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CellTypeIE_Extensions> = None;
        Ok(Self {
            cell_size,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_size.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellsToActivateList(pub Vec<CellsToActivateList_Item>);
impl entropic::Entropic for CellsToActivateList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellsToActivateList_Item::from_finite_entropy(source)?);
        }
        Ok(CellsToActivateList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellsToActivateList_Item {
    pub cell_id: CellsToActivateList_ItemCell_ID,
}
impl entropic::Entropic for CellsToActivateList_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id: CellsToActivateList_ItemCell_ID = __entropic_internal_source.entropic()?;
        Ok(Self { cell_id })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinEAI(pub Vec<CompletedCellinEAI_Item>);
impl entropic::Entropic for CompletedCellinEAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellinEAI_Item::from_finite_entropy(source)?);
        }
        Ok(CompletedCellinEAI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellinEAI_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellinEAI_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellinEAI_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CompletedCellinEAI_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinTAI(pub Vec<CompletedCellinTAI_Item>);
impl entropic::Entropic for CompletedCellinTAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellinTAI_Item::from_finite_entropy(source)?);
        }
        Ok(CompletedCellinTAI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellinTAI_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellinTAI_ItemIE_Extensions>,
}
impl entropic::Entropic for CompletedCellinTAI_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ecgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CompletedCellinTAI_ItemIE_Extensions> = None;
        Ok(Self {
            ecgi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ecgi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CompositeAvailableCapacityGroup(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ConcurrentWarningMessageIndicator(pub u8);
impl ConcurrentWarningMessageIndicator {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for ConcurrentWarningMessageIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ConcurrentWarningMessageIndicator(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ConnectedengNBItem {
    pub en_g_nb_id: En_gNB_ID,
    pub supported_t_as: SupportedTAs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ConnectedengNBItemIE_Extensions>,
}
impl entropic::Entropic for ConnectedengNBItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let en_g_nb_id: En_gNB_ID = __entropic_internal_source.entropic()?;
        let supported_t_as: SupportedTAs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ConnectedengNBItemIE_Extensions> = None;
        Ok(Self {
            en_g_nb_id,
            supported_t_as,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .en_g_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .supported_t_as
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ConnectedengNBList(pub Vec<ConnectedengNBItem>);
impl entropic::Entropic for ConnectedengNBList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ConnectedengNBItem::from_finite_entropy(source)?);
        }
        Ok(ConnectedengNBList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ConnectionEstablishmentIndication {
    pub protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs,
}
impl entropic::Entropic for ConnectionEstablishmentIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ContextatSource {
    pub source_ng_ran_node_id: Global_RAN_NODE_ID,
    pub ran_ue_ngap_id: RAN_UE_NGAP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ContextatSourceIE_Extensions>,
}
impl entropic::Entropic for ContextatSource {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let source_ng_ran_node_id: Global_RAN_NODE_ID = __entropic_internal_source.entropic()?;
        let ran_ue_ngap_id: RAN_UE_NGAP_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ContextatSourceIE_Extensions> = None;
        Ok(Self {
            source_ng_ran_node_id,
            ran_ue_ngap_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .source_ng_ran_node_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ran_ue_ngap_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct Correlation_ID(pub Vec<u8>);
impl entropic::Entropic for Correlation_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(Correlation_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Coverage_Level(pub u8);
impl Coverage_Level {
    pub const EXTENDEDCOVERAGE: u8 = 0u8;
}
impl entropic::Entropic for Coverage_Level {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Coverage_Level(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Criticality(pub u8);
impl Criticality {
    pub const REJECT: u8 = 0u8;
    pub const IGNORE: u8 = 1u8;
    pub const NOTIFY: u8 = 2u8;
}
impl entropic::Entropic for Criticality {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Criticality(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CriticalityDiagnostics {
    #[asn(optional_idx = 0)]
    pub procedure_code: Option<ProcedureCode>,
    #[asn(optional_idx = 1)]
    pub triggering_message: Option<TriggeringMessage>,
    #[asn(optional_idx = 2)]
    pub procedure_criticality: Option<Criticality>,
    #[asn(optional_idx = 3)]
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CriticalityDiagnosticsIE_Extensions>,
}
impl entropic::Entropic for CriticalityDiagnostics {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let procedure_code: Option<ProcedureCode> = __entropic_internal_source.entropic()?;
        let triggering_message: Option<TriggeringMessage> =
            __entropic_internal_source.entropic()?;
        let procedure_criticality: Option<Criticality> = __entropic_internal_source.entropic()?;
        let i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CriticalityDiagnosticsIE_Extensions> = None;
        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            i_es_criticality_diagnostics,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .procedure_code
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .triggering_message
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .procedure_criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .i_es_criticality_diagnostics
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CriticalityDiagnostics_IE_Item {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIE_ID,
    pub type_of_error: TypeOfError,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions>,
}
impl entropic::Entropic for CriticalityDiagnostics_IE_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ie_criticality: Criticality = __entropic_internal_source.entropic()?;
        let ie_id: ProtocolIE_ID = __entropic_internal_source.entropic()?;
        let type_of_error: TypeOfError = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions> = None;
        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ie_criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.ie_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .type_of_error
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CriticalityDiagnostics_IE_List(pub Vec<CriticalityDiagnostics_IE_Item>);
impl entropic::Entropic for CriticalityDiagnostics_IE_List {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnostics_IE_Item::from_finite_entropy(source)?);
        }
        Ok(CriticalityDiagnostics_IE_List(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSRequestInfo {
    pub daps_indicator: DAPSRequestInfoDAPSIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSRequestInfoIE_Extensions>,
}
impl entropic::Entropic for DAPSRequestInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let daps_indicator: DAPSRequestInfoDAPSIndicator = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<DAPSRequestInfoIE_Extensions> = None;
        Ok(Self {
            daps_indicator,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .daps_indicator
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfo {
    pub dapsresponseindicator: DAPSResponseInfoDapsresponseindicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoIE_Extensions>,
}
impl entropic::Entropic for DAPSResponseInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let dapsresponseindicator: DAPSResponseInfoDapsresponseindicator =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<DAPSResponseInfoIE_Extensions> = None;
        Ok(Self {
            dapsresponseindicator,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dapsresponseindicator
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfoItem {
    pub e_rab_id: E_RAB_ID,
    pub daps_response_info: DAPSResponseInfo,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoItemIE_Extensions>,
}
impl entropic::Entropic for DAPSResponseInfoItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let daps_response_info: DAPSResponseInfo = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<DAPSResponseInfoItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            daps_response_info,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .daps_response_info
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct DAPSResponseInfoList(pub Vec<DAPSResponseInfoList_Entry>);
impl entropic::Entropic for DAPSResponseInfoList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoList_Entry::from_finite_entropy(source)?);
        }
        Ok(DAPSResponseInfoList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct DCN_ID(pub u16);
impl entropic::Entropic for DCN_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DCN_ID(source.get_uniform_range(0..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DL_CP_SecurityInformation {
    pub dl_nas_mac: DL_NAS_MAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions>,
}
impl entropic::Entropic for DL_CP_SecurityInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let dl_nas_mac: DL_NAS_MAC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions> = None;
        Ok(Self {
            dl_nas_mac,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dl_nas_mac
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DL_Forwarding(pub u8);
impl DL_Forwarding {
    pub const D_L_FORWARDING_PROPOSED: u8 = 0u8;
}
impl entropic::Entropic for DL_Forwarding {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DL_Forwarding(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct DL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for DL_NAS_MAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(DL_NAS_MAC(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum DLCOUNT_PDCP_SNlength {
    #[asn(key = 0, extended = false)]
    DLCOUNTValuePDCP_SNlength12(COUNTvalue),
    #[asn(key = 1, extended = false)]
    DLCOUNTValuePDCP_SNlength15(COUNTValueExtended),
    #[asn(key = 2, extended = false)]
    DLCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
}
impl asn1_codecs::Asn1Choice for DLCOUNT_PDCP_SNlength {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            DLCOUNT_PDCP_SNlength::DLCOUNTValuePDCP_SNlength12(_) => 0u128.try_into().unwrap(),
            DLCOUNT_PDCP_SNlength::DLCOUNTValuePDCP_SNlength15(_) => 1u128.try_into().unwrap(),
            DLCOUNT_PDCP_SNlength::DLCOUNTValuePDCP_SNlength18(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DLNASPDUDeliveryAckRequest(pub u8);
impl DLNASPDUDeliveryAckRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for DLNASPDUDeliveryAckRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DLNASPDUDeliveryAckRequest(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Data_Forwarding_Not_Possible(pub u8);
impl Data_Forwarding_Not_Possible {
    pub const DATA_FORWARDING_NOT_POSSIBLE: u8 = 0u8;
}
impl entropic::Entropic for Data_Forwarding_Not_Possible {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Data_Forwarding_Not_Possible(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct DataCodingScheme(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for DataCodingScheme {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(DataCodingScheme(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "4095", extensible = true)]
pub struct DataSize(pub u16);
impl entropic::Entropic for DataSize {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DataSize(source.get_uniform_range(1..=4095)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeactivateTrace {
    pub protocol_i_es: DeactivateTraceProtocolIEs,
}
impl entropic::Entropic for DeactivateTrace {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: DeactivateTraceProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Direct_Forwarding_Path_Availability(pub u8);
impl Direct_Forwarding_Path_Availability {
    pub const DIRECT_PATH_AVAILABLE: u8 = 0u8;
}
impl entropic::Entropic for Direct_Forwarding_Path_Availability {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Direct_Forwarding_Path_Availability(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNASTransport {
    pub protocol_i_es: DownlinkNASTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkNASTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: DownlinkNASTransportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNonUEAssociatedLPPaTransport {
    pub protocol_i_es: DownlinkNonUEAssociatedLPPaTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkNonUEAssociatedLPPaTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: DownlinkNonUEAssociatedLPPaTransportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkS1cdma2000tunnelling {
    pub protocol_i_es: DownlinkS1cdma2000tunnellingProtocolIEs,
}
impl entropic::Entropic for DownlinkS1cdma2000tunnelling {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: DownlinkS1cdma2000tunnellingProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkUEAssociatedLPPaTransport {
    pub protocol_i_es: DownlinkUEAssociatedLPPaTransportProtocolIEs,
}
impl entropic::Entropic for DownlinkUEAssociatedLPPaTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: DownlinkUEAssociatedLPPaTransportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct E_RAB_ID(pub u8);
impl entropic::Entropic for E_RAB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(E_RAB_ID(source.get_uniform_range(0..=15)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABAdmittedItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub dl_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub dl_g_tp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 2)]
    pub ul_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 3)]
    pub ul_gtp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABAdmittedItemIE_Extensions>,
}
impl entropic::Entropic for E_RABAdmittedItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let dl_transport_layer_address: Option<TransportLayerAddress> =
            __entropic_internal_source.entropic()?;
        let dl_g_tp_teid: Option<GTP_TEID> = __entropic_internal_source.entropic()?;
        let ul_transport_layer_address: Option<TransportLayerAddress> =
            __entropic_internal_source.entropic()?;
        let ul_gtp_teid: Option<GTP_TEID> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABAdmittedItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            dl_transport_layer_address,
            dl_g_tp_teid,
            ul_transport_layer_address,
            ul_gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_g_tp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_gtp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABAdmittedList(pub Vec<E_RABAdmittedList_Entry>);
impl entropic::Entropic for E_RABAdmittedList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABAdmittedList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABAdmittedList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABDataForwardingItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub dl_g_tp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 2)]
    pub ul_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 3)]
    pub ul_gtp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABDataForwardingItemIE_Extensions>,
}
impl entropic::Entropic for E_RABDataForwardingItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let dl_transport_layer_address: Option<TransportLayerAddress> =
            __entropic_internal_source.entropic()?;
        let dl_g_tp_teid: Option<GTP_TEID> = __entropic_internal_source.entropic()?;
        let ul_transport_layer_address: Option<TransportLayerAddress> =
            __entropic_internal_source.entropic()?;
        let ul_gtp_teid: Option<GTP_TEID> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABDataForwardingItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            dl_transport_layer_address,
            dl_g_tp_teid,
            ul_transport_layer_address,
            ul_gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_g_tp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_gtp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToResumeItemResumeReq {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToResumeItemResumeReqIE_Extensions>,
}
impl entropic::Entropic for E_RABFailedToResumeItemResumeReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let cause: Cause = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABFailedToResumeItemResumeReqIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            cause,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cause.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToResumeItemResumeRes {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToResumeItemResumeResIE_Extensions>,
}
impl entropic::Entropic for E_RABFailedToResumeItemResumeRes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let cause: Cause = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABFailedToResumeItemResumeResIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            cause,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cause.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedToResumeListResumeReq(pub Vec<E_RABFailedToResumeListResumeReq_Entry>);
impl entropic::Entropic for E_RABFailedToResumeListResumeReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABFailedToResumeListResumeReq_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABFailedToResumeListResumeReq(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedToResumeListResumeRes(pub Vec<E_RABFailedToResumeListResumeRes_Entry>);
impl entropic::Entropic for E_RABFailedToResumeListResumeRes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABFailedToResumeListResumeRes_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABFailedToResumeListResumeRes(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToSetupItemHOReqAck {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToSetupItemHOReqAckIE_Extensions>,
}
impl entropic::Entropic for E_RABFailedToSetupItemHOReqAck {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let cause: Cause = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABFailedToSetupItemHOReqAckIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            cause,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cause.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedtoSetupListHOReqAck(pub Vec<E_RABFailedtoSetupListHOReqAck_Entry>);
impl entropic::Entropic for E_RABFailedtoSetupListHOReqAck {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABFailedtoSetupListHOReqAck_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABFailedtoSetupListHOReqAck(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABInformationList(pub Vec<E_RABInformationList_Entry>);
impl entropic::Entropic for E_RABInformationList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABInformationList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABInformationList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABInformationListItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DL_Forwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABInformationListItemIE_Extensions>,
}
impl entropic::Entropic for E_RABInformationListItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let dl_forwarding: Option<DL_Forwarding> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABInformationListItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            dl_forwarding,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_forwarding
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABItem {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABItemIE_Extensions>,
}
impl entropic::Entropic for E_RABItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let cause: Cause = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            cause,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cause.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABLevelQoSParameters {
    pub qci: QCI,
    pub allocation_retention_priority: AllocationAndRetentionPriority,
    #[asn(optional_idx = 0)]
    pub gbr_qos_information: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABLevelQoSParametersIE_Extensions>,
}
impl entropic::Entropic for E_RABLevelQoSParameters {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let qci: QCI = __entropic_internal_source.entropic()?;
        let allocation_retention_priority: AllocationAndRetentionPriority =
            __entropic_internal_source.entropic()?;
        let gbr_qos_information: Option<GBR_QosInformation> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABLevelQoSParametersIE_Extensions> = None;
        Ok(Self {
            qci,
            allocation_retention_priority,
            gbr_qos_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.qci.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .allocation_retention_priority
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .gbr_qos_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABList(pub Vec<E_RABList_Entry>);
impl entropic::Entropic for E_RABList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModificationConfirm {
    pub protocol_i_es: E_RABModificationConfirmProtocolIEs,
}
impl entropic::Entropic for E_RABModificationConfirm {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABModificationConfirmProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModificationIndication {
    pub protocol_i_es: E_RABModificationIndicationProtocolIEs,
}
impl entropic::Entropic for E_RABModificationIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABModificationIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABModifyItemBearerModConf {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABModifyItemBearerModConfIE_Extensions>,
}
impl entropic::Entropic for E_RABModifyItemBearerModConf {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABModifyItemBearerModConfIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABModifyItemBearerModRes {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABModifyItemBearerModResIE_Extensions>,
}
impl entropic::Entropic for E_RABModifyItemBearerModRes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABModifyItemBearerModResIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABModifyListBearerModConf(pub Vec<E_RABModifyListBearerModConf_Entry>);
impl entropic::Entropic for E_RABModifyListBearerModConf {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyListBearerModConf_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABModifyListBearerModConf(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABModifyListBearerModRes(pub Vec<E_RABModifyListBearerModRes_Entry>);
impl entropic::Entropic for E_RABModifyListBearerModRes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyListBearerModRes_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABModifyListBearerModRes(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModifyRequest {
    pub protocol_i_es: E_RABModifyRequestProtocolIEs,
}
impl entropic::Entropic for E_RABModifyRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABModifyRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModifyResponse {
    pub protocol_i_es: E_RABModifyResponseProtocolIEs,
}
impl entropic::Entropic for E_RABModifyResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABModifyResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABNotToBeModifiedItemBearerModInd {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub dl_gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABNotToBeModifiedItemBearerModIndIE_Extensions>,
}
impl entropic::Entropic for E_RABNotToBeModifiedItemBearerModInd {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let dl_gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABNotToBeModifiedItemBearerModIndIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            dl_gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_gtp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABNotToBeModifiedListBearerModInd(
    pub Vec<E_RABNotToBeModifiedListBearerModInd_Entry>,
);
impl entropic::Entropic for E_RABNotToBeModifiedListBearerModInd {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABNotToBeModifiedListBearerModInd_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABNotToBeModifiedListBearerModInd(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseCommand {
    pub protocol_i_es: E_RABReleaseCommandProtocolIEs,
}
impl entropic::Entropic for E_RABReleaseCommand {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABReleaseCommandProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseIndication {
    pub protocol_i_es: E_RABReleaseIndicationProtocolIEs,
}
impl entropic::Entropic for E_RABReleaseIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABReleaseIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABReleaseItemBearerRelComp {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABReleaseItemBearerRelCompIE_Extensions>,
}
impl entropic::Entropic for E_RABReleaseItemBearerRelComp {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABReleaseItemBearerRelCompIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABReleaseListBearerRelComp(pub Vec<E_RABReleaseListBearerRelComp_Entry>);
impl entropic::Entropic for E_RABReleaseListBearerRelComp {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABReleaseListBearerRelComp_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABReleaseListBearerRelComp(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseResponse {
    pub protocol_i_es: E_RABReleaseResponseProtocolIEs,
}
impl entropic::Entropic for E_RABReleaseResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABReleaseResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABSetupItemBearerSURes {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABSetupItemBearerSUResIE_Extensions>,
}
impl entropic::Entropic for E_RABSetupItemBearerSURes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABSetupItemBearerSUResIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABSetupItemCtxtSURes {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABSetupItemCtxtSUResIE_Extensions>,
}
impl entropic::Entropic for E_RABSetupItemCtxtSURes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABSetupItemCtxtSUResIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSetupListBearerSURes(pub Vec<E_RABSetupListBearerSURes_Entry>);
impl entropic::Entropic for E_RABSetupListBearerSURes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupListBearerSURes_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABSetupListBearerSURes(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSetupListCtxtSURes(pub Vec<E_RABSetupListCtxtSURes_Entry>);
impl entropic::Entropic for E_RABSetupListCtxtSURes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupListCtxtSURes_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABSetupListCtxtSURes(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABSetupRequest {
    pub protocol_i_es: E_RABSetupRequestProtocolIEs,
}
impl entropic::Entropic for E_RABSetupRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABSetupRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABSetupResponse {
    pub protocol_i_es: E_RABSetupResponseProtocolIEs,
}
impl entropic::Entropic for E_RABSetupResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: E_RABSetupResponseProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSubjecttoDataForwardingList(pub Vec<E_RABSubjecttoDataForwardingList_Entry>);
impl entropic::Entropic for E_RABSubjecttoDataForwardingList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSubjecttoDataForwardingList_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABSubjecttoDataForwardingList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeModifiedItemBearerModInd {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub dl_gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeModifiedItemBearerModIndIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeModifiedItemBearerModInd {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let dl_gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeModifiedItemBearerModIndIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            dl_gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .dl_gtp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeModifiedItemBearerModReq {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RABLevelQoSParameters,
    pub nas_pdu: NAS_PDU,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeModifiedItemBearerModReqIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeModifiedItemBearerModReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let e_rab_level_qo_s_parameters: E_RABLevelQoSParameters =
            __entropic_internal_source.entropic()?;
        let nas_pdu: NAS_PDU = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeModifiedItemBearerModReqIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            e_rab_level_qo_s_parameters,
            nas_pdu,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_level_qo_s_parameters
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.nas_pdu.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeModifiedListBearerModInd(pub Vec<E_RABToBeModifiedListBearerModInd_Entry>);
impl entropic::Entropic for E_RABToBeModifiedListBearerModInd {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeModifiedListBearerModInd_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeModifiedListBearerModInd(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeModifiedListBearerModReq(pub Vec<E_RABToBeModifiedListBearerModReq_Entry>);
impl entropic::Entropic for E_RABToBeModifiedListBearerModReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeModifiedListBearerModReq_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeModifiedListBearerModReq(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSetupItemBearerSUReq {
    pub e_rab_id: E_RAB_ID,
    pub e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    pub nas_pdu: NAS_PDU,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSetupItemBearerSUReqIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeSetupItemBearerSUReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters =
            __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let nas_pdu: NAS_PDU = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeSetupItemBearerSUReqIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            e_ra_blevel_qo_s_parameters,
            transport_layer_address,
            gtp_teid,
            nas_pdu,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_ra_blevel_qo_s_parameters
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.nas_pdu.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABToBeSetupItemCtxtSUReq {
    pub e_rab_id: E_RAB_ID,
    pub e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABToBeSetupItemCtxtSUReqIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeSetupItemCtxtSUReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters =
            __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let nas_pdu: Option<NAS_PDU> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeSetupItemCtxtSUReqIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            e_ra_blevel_qo_s_parameters,
            transport_layer_address,
            gtp_teid,
            nas_pdu,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_ra_blevel_qo_s_parameters
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.nas_pdu.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSetupItemHOReq {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    pub e_ra_blevel_qos_parameters: E_RABLevelQoSParameters,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSetupItemHOReqIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeSetupItemHOReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let e_ra_blevel_qos_parameters: E_RABLevelQoSParameters =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeSetupItemHOReqIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            e_ra_blevel_qos_parameters,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_ra_blevel_qos_parameters
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListBearerSUReq(pub Vec<E_RABToBeSetupListBearerSUReq_Entry>);
impl entropic::Entropic for E_RABToBeSetupListBearerSUReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupListBearerSUReq_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABToBeSetupListBearerSUReq(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListCtxtSUReq(pub Vec<E_RABToBeSetupListCtxtSUReq_Entry>);
impl entropic::Entropic for E_RABToBeSetupListCtxtSUReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupListCtxtSUReq_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABToBeSetupListCtxtSUReq(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListHOReq(pub Vec<E_RABToBeSetupListHOReq_Entry>);
impl entropic::Entropic for E_RABToBeSetupListHOReq {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupListHOReq_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSetupListHOReq(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSwitchedDLItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSwitchedDLItemIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeSwitchedDLItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeSwitchedDLItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSwitchedDLList(pub Vec<E_RABToBeSwitchedDLList_Entry>);
impl entropic::Entropic for E_RABToBeSwitchedDLList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSwitchedDLList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSwitchedDLList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSwitchedULItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSwitchedULItemIE_Extensions>,
}
impl entropic::Entropic for E_RABToBeSwitchedULItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABToBeSwitchedULItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            transport_layer_address,
            gtp_teid,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtp_teid.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSwitchedULList(pub Vec<E_RABToBeSwitchedULList_Entry>);
impl entropic::Entropic for E_RABToBeSwitchedULList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSwitchedULList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSwitchedULList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABUsageReportItem {
    pub start_timestamp: E_RABUsageReportItemStartTimestamp,
    pub end_timestamp: E_RABUsageReportItemEndTimestamp,
    pub usage_count_ul: E_RABUsageReportItemUsageCountUL,
    pub usage_count_dl: E_RABUsageReportItemUsageCountDL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABUsageReportItemIE_Extensions>,
}
impl entropic::Entropic for E_RABUsageReportItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let start_timestamp: E_RABUsageReportItemStartTimestamp =
            __entropic_internal_source.entropic()?;
        let end_timestamp: E_RABUsageReportItemEndTimestamp =
            __entropic_internal_source.entropic()?;
        let usage_count_ul: E_RABUsageReportItemUsageCountUL =
            __entropic_internal_source.entropic()?;
        let usage_count_dl: E_RABUsageReportItemUsageCountDL =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<E_RABUsageReportItemIE_Extensions> = None;
        Ok(Self {
            start_timestamp,
            end_timestamp,
            usage_count_ul,
            usage_count_dl,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .start_timestamp
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .end_timestamp
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .usage_count_ul
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .usage_count_dl
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct E_RABUsageReportList(pub Vec<E_RABUsageReportList_Entry>);
impl entropic::Entropic for E_RABUsageReportList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABUsageReportList_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABUsageReportList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct E_UTRAN_Trace_ID(pub Vec<u8>);
impl entropic::Entropic for E_UTRAN_Trace_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(8..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(E_UTRAN_Trace_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143", extensible = true)]
pub struct EARFCN(pub u32);
impl entropic::Entropic for EARFCN {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EARFCN(source.get_uniform_range(0..=262143)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=262143 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ECGI_List(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for ECGI_List {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(ECGI_List(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ECGIList(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for ECGIList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(ECGIList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ECGIListForRestart(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for ECGIListForRestart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(ECGIListForRestart(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EDT_Session(pub u8);
impl EDT_Session {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for EDT_Session {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EDT_Session(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "16",
    sz_ub = "16"
)]
pub struct EHRPD_Sector_ID(pub Vec<u8>);
impl entropic::Entropic for EHRPD_Sector_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(16..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(EHRPD_Sector_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct EHRPDCapacityValue(pub u8);
impl entropic::Entropic for EHRPDCapacityValue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EHRPDCapacityValue(source.get_uniform_range(0..=100)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=100 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDCompositeAvailableCapacity {
    pub ehrpd_sector_capacity_class_value: EHRPDSectorCapacityClassValue,
    pub ehrpd_capacity_value: EHRPDCapacityValue,
}
impl entropic::Entropic for EHRPDCompositeAvailableCapacity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ehrpd_sector_capacity_class_value: EHRPDSectorCapacityClassValue =
            __entropic_internal_source.entropic()?;
        let ehrpd_capacity_value: EHRPDCapacityValue = __entropic_internal_source.entropic()?;
        Ok(Self {
            ehrpd_sector_capacity_class_value,
            ehrpd_capacity_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ehrpd_sector_capacity_class_value
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ehrpd_capacity_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDMultiSectorLoadReportingResponseItem {
    pub ehrpd_sector_id: EHRPD_Sector_ID,
    pub ehrpd_sector_load_reporting_response: EHRPDSectorLoadReportingResponse,
}
impl entropic::Entropic for EHRPDMultiSectorLoadReportingResponseItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ehrpd_sector_id: EHRPD_Sector_ID = __entropic_internal_source.entropic()?;
        let ehrpd_sector_load_reporting_response: EHRPDSectorLoadReportingResponse =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            ehrpd_sector_id,
            ehrpd_sector_load_reporting_response,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ehrpd_sector_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ehrpd_sector_load_reporting_response
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100", extensible = true)]
pub struct EHRPDSectorCapacityClassValue(pub u8);
impl entropic::Entropic for EHRPDSectorCapacityClassValue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EHRPDSectorCapacityClassValue(
            source.get_uniform_range(1..=100)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=100 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDSectorLoadReportingResponse {
    pub dl_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity,
    pub ul_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity,
}
impl entropic::Entropic for EHRPDSectorLoadReportingResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let dl_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity =
            __entropic_internal_source.entropic()?;
        let ul_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            dl_ehrpd_composite_available_capacity,
            ul_ehrpd_composite_available_capacity,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dl_ehrpd_composite_available_capacity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_ehrpd_composite_available_capacity
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EN_DCSONConfigurationTransfer {
    pub transfertype: EN_DCSONTransferType,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub x2tnl_config_info: Option<X2TNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<EN_DCSONConfigurationTransferIE_Extensions>,
}
impl entropic::Entropic for EN_DCSONConfigurationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let transfertype: EN_DCSONTransferType = __entropic_internal_source.entropic()?;
        let son_information: SONInformation = __entropic_internal_source.entropic()?;
        let x2tnl_config_info: Option<X2TNLConfigurationInfo> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EN_DCSONConfigurationTransferIE_Extensions> = None;
        Ok(Self {
            transfertype,
            son_information,
            x2tnl_config_info,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .transfertype
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .son_information
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .x2tnl_config_info
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum EN_DCSONTransferType {
    #[asn(key = 0, extended = false)]
    Request(EN_DCTransferTypeRequest),
    #[asn(key = 1, extended = false)]
    Reply(EN_DCTransferTypeReply),
}
impl asn1_codecs::Asn1Choice for EN_DCSONTransferType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            EN_DCSONTransferType::Request(_) => 0u128.try_into().unwrap(),
            EN_DCSONTransferType::Reply(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCSONeNBIdentification {
    pub globale_nbid: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCSONeNBIdentificationIE_Extensions>,
}
impl entropic::Entropic for EN_DCSONeNBIdentification {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let globale_nbid: Global_ENB_ID = __entropic_internal_source.entropic()?;
        let selected_tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EN_DCSONeNBIdentificationIE_Extensions> = None;
        Ok(Self {
            globale_nbid,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .globale_nbid
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCSONengNBIdentification {
    pub globaleng_nbid: Global_en_gNB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCSONengNBIdentificationIE_Extensions>,
}
impl entropic::Entropic for EN_DCSONengNBIdentification {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let globaleng_nbid: Global_en_gNB_ID = __entropic_internal_source.entropic()?;
        let selected_tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EN_DCSONengNBIdentificationIE_Extensions> = None;
        Ok(Self {
            globaleng_nbid,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .globaleng_nbid
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCTransferTypeReply {
    pub sourceeng_nb: EN_DCSONengNBIdentification,
    pub targete_nb: EN_DCSONeNBIdentification,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCTransferTypeReplyIE_Extensions>,
}
impl entropic::Entropic for EN_DCTransferTypeReply {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let sourceeng_nb: EN_DCSONengNBIdentification = __entropic_internal_source.entropic()?;
        let targete_nb: EN_DCSONeNBIdentification = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EN_DCTransferTypeReplyIE_Extensions> = None;
        Ok(Self {
            sourceeng_nb,
            targete_nb,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .sourceeng_nb
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .targete_nb
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct EN_DCTransferTypeRequest {
    pub sourcee_nb: EN_DCSONeNBIdentification,
    pub targeteng_nb: EN_DCSONengNBIdentification,
    #[asn(optional_idx = 0)]
    pub targete_nb: Option<EN_DCSONeNBIdentification>,
    #[asn(optional_idx = 1)]
    pub associated_tai: Option<TAI>,
    #[asn(optional_idx = 2)]
    pub broadcast5_gstai: Option<FiveGSTAI>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<EN_DCTransferTypeRequestIE_Extensions>,
}
impl entropic::Entropic for EN_DCTransferTypeRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let sourcee_nb: EN_DCSONeNBIdentification = __entropic_internal_source.entropic()?;
        let targeteng_nb: EN_DCSONengNBIdentification = __entropic_internal_source.entropic()?;
        let targete_nb: Option<EN_DCSONeNBIdentification> =
            __entropic_internal_source.entropic()?;
        let associated_tai: Option<TAI> = __entropic_internal_source.entropic()?;
        let broadcast5_gstai: Option<FiveGSTAI> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EN_DCTransferTypeRequestIE_Extensions> = None;
        Ok(Self {
            sourcee_nb,
            targeteng_nb,
            targete_nb,
            associated_tai,
            broadcast5_gstai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .sourcee_nb
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .targeteng_nb
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .targete_nb
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .associated_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .broadcast5_gstai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ENB_EarlyStatusTransfer_TransparentContainer {
    pub bearers_subject_to_early_status_transfer_list: Bearers_SubjectToEarlyStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for ENB_EarlyStatusTransfer_TransparentContainer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let bearers_subject_to_early_status_transfer_list : Bearers_SubjectToEarlyStatusTransferList = __entropic_internal_source . entropic () ? ;
        let ie_extensions: Option<ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            bearers_subject_to_early_status_transfer_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .bearers_subject_to_early_status_transfer_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ENB_ID {
    #[asn(key = 0, extended = false)]
    MacroENB_ID(ENB_ID_macroENB_ID),
    #[asn(key = 1, extended = false)]
    HomeENB_ID(ENB_ID_homeENB_ID),
    #[asn(key = 0, extended = true)]
    Short_macroENB_ID(ENB_ID_short_macroENB_ID),
    #[asn(key = 1, extended = true)]
    Long_macroENB_ID(ENB_ID_long_macroENB_ID),
}
impl asn1_codecs::Asn1Choice for ENB_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            ENB_ID::MacroENB_ID(_) => 0u128.try_into().unwrap(),
            ENB_ID::HomeENB_ID(_) => 1u128.try_into().unwrap(),
            ENB_ID::Short_macroENB_ID(_) => 0u128.try_into().unwrap(),
            ENB_ID::Long_macroENB_ID(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ENB_StatusTransfer_TransparentContainer {
    pub bearers_subject_to_status_transfer_list: Bearers_SubjectToStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ENB_StatusTransfer_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for ENB_StatusTransfer_TransparentContainer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let bearers_subject_to_status_transfer_list: Bearers_SubjectToStatusTransferList =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ENB_StatusTransfer_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            bearers_subject_to_status_transfer_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .bearers_subject_to_status_transfer_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16777215")]
pub struct ENB_UE_S1AP_ID(pub u32);
impl entropic::Entropic for ENB_UE_S1AP_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ENB_UE_S1AP_ID(source.get_uniform_range(0..=16777215)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=16777215 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBCPRelocationIndication {
    pub protocol_i_es: ENBCPRelocationIndicationProtocolIEs,
}
impl entropic::Entropic for ENBCPRelocationIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBCPRelocationIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationTransfer {
    pub protocol_i_es: ENBConfigurationTransferProtocolIEs,
}
impl entropic::Entropic for ENBConfigurationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBConfigurationTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdate {
    pub protocol_i_es: ENBConfigurationUpdateProtocolIEs,
}
impl entropic::Entropic for ENBConfigurationUpdate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBConfigurationUpdateProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateAcknowledge {
    pub protocol_i_es: ENBConfigurationUpdateAcknowledgeProtocolIEs,
}
impl entropic::Entropic for ENBConfigurationUpdateAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBConfigurationUpdateAcknowledgeProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateFailure {
    pub protocol_i_es: ENBConfigurationUpdateFailureProtocolIEs,
}
impl entropic::Entropic for ENBConfigurationUpdateFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBConfigurationUpdateFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBDirectInformationTransfer {
    pub protocol_i_es: ENBDirectInformationTransferProtocolIEs,
}
impl entropic::Entropic for ENBDirectInformationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBDirectInformationTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBEarlyStatusTransfer {
    pub protocol_i_es: ENBEarlyStatusTransferProtocolIEs,
}
impl entropic::Entropic for ENBEarlyStatusTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBEarlyStatusTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct ENBIndirectX2TransportLayerAddresses(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for ENBIndirectX2TransportLayerAddresses {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_finite_entropy(source)?);
        }
        Ok(ENBIndirectX2TransportLayerAddresses(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBStatusTransfer {
    pub protocol_i_es: ENBStatusTransferProtocolIEs,
}
impl entropic::Entropic for ENBStatusTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ENBStatusTransferProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ENBX2ExtTLA {
    #[asn(optional_idx = 0)]
    pub i_psec_tla: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub gtptl_aa: Option<ENBX2GTPTLAs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ENBX2ExtTLAIE_Extensions>,
}
impl entropic::Entropic for ENBX2ExtTLA {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let i_psec_tla: Option<TransportLayerAddress> = __entropic_internal_source.entropic()?;
        let gtptl_aa: Option<ENBX2GTPTLAs> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ENBX2ExtTLAIE_Extensions> = None;
        Ok(Self {
            i_psec_tla,
            gtptl_aa,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .i_psec_tla
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gtptl_aa.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ENBX2ExtTLAs(pub Vec<ENBX2ExtTLA>);
impl entropic::Entropic for ENBX2ExtTLAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBX2ExtTLA::from_finite_entropy(source)?);
        }
        Ok(ENBX2ExtTLAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ENBX2GTPTLAs(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for ENBX2GTPTLAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_finite_entropy(source)?);
        }
        Ok(ENBX2GTPTLAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct ENBX2TLAs(pub Vec<TransportLayerAddress>);
impl entropic::Entropic for ENBX2TLAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TransportLayerAddress::from_finite_entropy(source)?);
        }
        Ok(ENBX2TLAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct ENBname(pub String);
impl entropic::Entropic for ENBname {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_finite_entropy(source)?);
        }
        Ok(Self(s))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_finite_entropy(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct EPLMNs(pub Vec<PLMNidentity>);
impl entropic::Entropic for EPLMNs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(15, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNidentity::from_finite_entropy(source)?);
        }
        Ok(EPLMNs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(15, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EUTRAN_CGI {
    pub plm_nidentity: PLMNidentity,
    pub cell_id: CellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EUTRAN_CGIIE_Extensions>,
}
impl entropic::Entropic for EUTRAN_CGI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let cell_id: CellIdentity = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EUTRAN_CGIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            cell_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANResponse {
    pub cell_id: EUTRANResponseCell_ID,
    pub eutra_ncell_load_reporting_response: EUTRANcellLoadReportingResponse,
}
impl entropic::Entropic for EUTRANResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id: EUTRANResponseCell_ID = __entropic_internal_source.entropic()?;
        let eutra_ncell_load_reporting_response: EUTRANcellLoadReportingResponse =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            cell_id,
            eutra_ncell_load_reporting_response,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .eutra_ncell_load_reporting_response
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct EUTRANRoundTripDelayEstimationInfo(pub u16);
impl entropic::Entropic for EUTRANRoundTripDelayEstimationInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EUTRANRoundTripDelayEstimationInfo(
            source.get_uniform_range(0..=2047)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2047 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANcellLoadReportingResponse {
    pub composite_available_capacity_group: CompositeAvailableCapacityGroup,
}
impl entropic::Entropic for EUTRANcellLoadReportingResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let composite_available_capacity_group: CompositeAvailableCapacityGroup =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            composite_available_capacity_group,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .composite_available_capacity_group
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct EmergencyAreaID(pub Vec<u8>);
impl entropic::Entropic for EmergencyAreaID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Broadcast(pub Vec<EmergencyAreaID_Broadcast_Item>);
impl entropic::Entropic for EmergencyAreaID_Broadcast {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID_Broadcast_Item::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaID_Broadcast(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaID_Broadcast_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cellin_eai: CompletedCellinEAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaID_Broadcast_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaID_Broadcast_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let emergency_area_id: EmergencyAreaID = __entropic_internal_source.entropic()?;
        let completed_cellin_eai: CompletedCellinEAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EmergencyAreaID_Broadcast_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            completed_cellin_eai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .emergency_area_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .completed_cellin_eai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Cancelled(pub Vec<EmergencyAreaID_Cancelled_Item>);
impl entropic::Entropic for EmergencyAreaID_Cancelled {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID_Cancelled_Item::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaID_Cancelled(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaID_Cancelled_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cellin_eai: CancelledCellinEAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaID_Cancelled_ItemIE_Extensions>,
}
impl entropic::Entropic for EmergencyAreaID_Cancelled_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let emergency_area_id: EmergencyAreaID = __entropic_internal_source.entropic()?;
        let cancelled_cellin_eai: CancelledCellinEAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<EmergencyAreaID_Cancelled_ItemIE_Extensions> = None;
        Ok(Self {
            emergency_area_id,
            cancelled_cellin_eai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .emergency_area_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .cancelled_cellin_eai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDList(pub Vec<EmergencyAreaID>);
impl entropic::Entropic for EmergencyAreaIDList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaIDList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EmergencyAreaIDListForRestart(pub Vec<EmergencyAreaID>);
impl entropic::Entropic for EmergencyAreaIDListForRestart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaIDListForRestart(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EmergencyIndicator(pub u8);
impl EmergencyIndicator {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for EmergencyIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EmergencyIndicator(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "22", sz_ub = "32")]
pub struct En_gNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for En_gNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(22..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(En_gNB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 22);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(22..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EncryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for EncryptionAlgorithms {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(EncryptionAlgorithms(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EndIndication(pub u8);
impl EndIndication {
    pub const NO_FURTHER_DATA: u8 = 0u8;
    pub const FURTHER_DATA_EXISTS: u8 = 1u8;
}
impl entropic::Entropic for EndIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EndIndication(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EnhancedCoverageRestricted(pub u8);
impl EnhancedCoverageRestricted {
    pub const RESTRICTED: u8 = 0u8;
}
impl entropic::Entropic for EnhancedCoverageRestricted {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EnhancedCoverageRestricted(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ErrorIndication {
    pub protocol_i_es: ErrorIndicationProtocolIEs,
}
impl entropic::Entropic for ErrorIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ErrorIndicationProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Ethernet_Type(pub u8);
impl Ethernet_Type {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for Ethernet_Type {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Ethernet_Type(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EventTriggeredCellLoadReportingRequest {
    pub number_of_measurement_reporting_levels: NumberOfMeasurementReportingLevels,
}
impl entropic::Entropic for EventTriggeredCellLoadReportingRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let number_of_measurement_reporting_levels: NumberOfMeasurementReportingLevels =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            number_of_measurement_reporting_levels,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .number_of_measurement_reporting_levels
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EventTriggeredCellLoadReportingResponse {
    pub cell_load_reporting_response: CellLoadReportingResponse,
    #[asn(optional_idx = 0)]
    pub overload_flag: Option<OverloadFlag>,
}
impl entropic::Entropic for EventTriggeredCellLoadReportingResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_load_reporting_response: CellLoadReportingResponse =
            __entropic_internal_source.entropic()?;
        let overload_flag: Option<OverloadFlag> = __entropic_internal_source.entropic()?;
        Ok(Self {
            cell_load_reporting_response,
            overload_flag,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .cell_load_reporting_response
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .overload_flag
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct EventType(pub u8);
impl EventType {
    pub const DIRECT: u8 = 0u8;
    pub const CHANGE_OF_SERVE_CELL: u8 = 1u8;
    pub const STOP_CHANGE_OF_SERVE_CELL: u8 = 2u8;
}
impl entropic::Entropic for EventType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(EventType(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedActivityPeriod(pub u8);
impl entropic::Entropic for ExpectedActivityPeriod {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExpectedActivityPeriod(source.get_uniform_range(1..=30)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=30 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct ExpectedHOInterval(pub u8);
impl ExpectedHOInterval {
    pub const SEC15: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC90: u8 = 3u8;
    pub const SEC120: u8 = 4u8;
    pub const SEC180: u8 = 5u8;
    pub const LONG_TIME: u8 = 6u8;
}
impl entropic::Entropic for ExpectedHOInterval {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExpectedHOInterval(source.get_uniform_range(0..=6)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=6 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedIdlePeriod(pub u8);
impl entropic::Entropic for ExpectedIdlePeriod {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExpectedIdlePeriod(source.get_uniform_range(1..=30)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=30 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ExpectedUEActivityBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    #[asn(optional_idx = 1)]
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    #[asn(optional_idx = 2)]
    pub sourceof_ue_activity_behaviour_information: Option<SourceOfUEActivityBehaviourInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions>,
}
impl entropic::Entropic for ExpectedUEActivityBehaviour {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let expected_activity_period: Option<ExpectedActivityPeriod> =
            __entropic_internal_source.entropic()?;
        let expected_idle_period: Option<ExpectedIdlePeriod> =
            __entropic_internal_source.entropic()?;
        let sourceof_ue_activity_behaviour_information: Option<
            SourceOfUEActivityBehaviourInformation,
        > = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions> = None;
        Ok(Self {
            expected_activity_period,
            expected_idle_period,
            sourceof_ue_activity_behaviour_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .expected_activity_period
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .expected_idle_period
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .sourceof_ue_activity_behaviour_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ExpectedUEBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity: Option<ExpectedUEActivityBehaviour>,
    #[asn(optional_idx = 1)]
    pub expected_ho_interval: Option<ExpectedHOInterval>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ExpectedUEBehaviourIE_Extensions>,
}
impl entropic::Entropic for ExpectedUEBehaviour {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let expected_activity: Option<ExpectedUEActivityBehaviour> =
            __entropic_internal_source.entropic()?;
        let expected_ho_interval: Option<ExpectedHOInterval> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ExpectedUEBehaviourIE_Extensions> = None;
        Ok(Self {
            expected_activity,
            expected_ho_interval,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .expected_activity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .expected_ho_interval
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "14", sz_ub = "14")]
pub struct Extended_UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for Extended_UEIdentityIndexValue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(14, 16383);
        let total_bitlen = source.get_bounded_len(14..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(Extended_UEIdentityIndexValue(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 14);
        let capped_max = std::cmp::min(14, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(14..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "INTEGER",
    lb = "10000000001",
    ub = "4000000000000",
    extensible = true
)]
pub struct ExtendedBitRate(pub u64);
impl entropic::Entropic for ExtendedBitRate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExtendedBitRate(
            source.get_uniform_range(10000000001..=4000000000000)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(10000000001..=4000000000000 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "4096", ub = "65535")]
pub struct ExtendedRNC_ID(pub u16);
impl entropic::Entropic for ExtendedRNC_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExtendedRNC_ID(source.get_uniform_range(4096..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(4096..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "4096", ub = "131071")]
pub struct ExtendedRepetitionPeriod(pub u32);
impl entropic::Entropic for ExtendedRepetitionPeriod {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ExtendedRepetitionPeriod(
            source.get_uniform_range(4096..=131071)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(4096..=131071 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum FailureEventReport {
    #[asn(key = 0, extended = false)]
    TooEarlyInterRATHOReportFromEUTRAN(TooEarlyInterRATHOReportReportFromEUTRAN),
}
impl asn1_codecs::Asn1Choice for FailureEventReport {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            FailureEventReport::TooEarlyInterRATHOReportFromEUTRAN(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct FailureEventReportingCause(pub u8);
impl FailureEventReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl entropic::Entropic for FailureEventReportingCause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(FailureEventReportingCause(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct FiveGSTAC(pub Vec<u8>);
impl entropic::Entropic for FiveGSTAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(FiveGSTAC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FiveGSTAI {
    pub plm_nidentity: PLMNidentity,
    pub five_gstac: FiveGSTAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FiveGSTAIIE_Extensions>,
}
impl entropic::Entropic for FiveGSTAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let five_gstac: FiveGSTAC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<FiveGSTAIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            five_gstac,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .five_gstac
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct FiveQI(pub u8);
impl entropic::Entropic for FiveQI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(FiveQI(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ForbiddenInterRATs(pub u8);
impl ForbiddenInterRATs {
    pub const ALL: u8 = 0u8;
    pub const GERAN: u8 = 1u8;
    pub const UTRAN: u8 = 2u8;
    pub const CDMA2000: u8 = 3u8;
}
impl entropic::Entropic for ForbiddenInterRATs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ForbiddenInterRATs(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenLACs(pub Vec<LAC>);
impl entropic::Entropic for ForbiddenLACs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4096, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LAC::from_finite_entropy(source)?);
        }
        Ok(ForbiddenLACs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4096, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenLAs(pub Vec<ForbiddenLAs_Item>);
impl entropic::Entropic for ForbiddenLAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenLAs_Item::from_finite_entropy(source)?);
        }
        Ok(ForbiddenLAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenLAs_Item {
    pub plmn_identity: PLMNidentity,
    pub forbidden_la_cs: ForbiddenLACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenLAs_ItemIE_Extensions>,
}
impl entropic::Entropic for ForbiddenLAs_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let forbidden_la_cs: ForbiddenLACs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ForbiddenLAs_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            forbidden_la_cs,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .forbidden_la_cs
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenTACs(pub Vec<TAC>);
impl entropic::Entropic for ForbiddenTACs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4096, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_finite_entropy(source)?);
        }
        Ok(ForbiddenTACs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4096, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenTAs(pub Vec<ForbiddenTAs_Item>);
impl entropic::Entropic for ForbiddenTAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenTAs_Item::from_finite_entropy(source)?);
        }
        Ok(ForbiddenTAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenTAs_Item {
    pub plmn_identity: PLMNidentity,
    pub forbidden_ta_cs: ForbiddenTACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenTAs_ItemIE_Extensions>,
}
impl entropic::Entropic for ForbiddenTAs_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let forbidden_ta_cs: ForbiddenTACs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ForbiddenTAs_ItemIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            forbidden_ta_cs,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .forbidden_ta_cs
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GBR_QosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GBR_QosInformationIE_Extensions>,
}
impl entropic::Entropic for GBR_QosInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_maximum_bitrate_dl: BitRate = __entropic_internal_source.entropic()?;
        let e_rab_maximum_bitrate_ul: BitRate = __entropic_internal_source.entropic()?;
        let e_rab_guaranteed_bitrate_dl: BitRate = __entropic_internal_source.entropic()?;
        let e_rab_guaranteed_bitrate_ul: BitRate = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<GBR_QosInformationIE_Extensions> = None;
        Ok(Self {
            e_rab_maximum_bitrate_dl,
            e_rab_maximum_bitrate_ul,
            e_rab_guaranteed_bitrate_dl,
            e_rab_guaranteed_bitrate_ul,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .e_rab_maximum_bitrate_dl
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_maximum_bitrate_ul
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_guaranteed_bitrate_dl
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_guaranteed_bitrate_ul
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GERAN_Cell_ID {
    pub lai: LAI,
    pub rac: RAC,
    pub ci: CI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GERAN_Cell_IDIE_Extensions>,
}
impl entropic::Entropic for GERAN_Cell_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let lai: LAI = __entropic_internal_source.entropic()?;
        let rac: RAC = __entropic_internal_source.entropic()?;
        let ci: CI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<GERAN_Cell_IDIE_Extensions> = None;
        Ok(Self {
            lai,
            rac,
            ci,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.lai.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.rac.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.ci.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GNB {
    pub global_g_nb_id: Global_GNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GNBIE_Extensions>,
}
impl entropic::Entropic for GNB {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_g_nb_id: Global_GNB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<GNBIE_Extensions> = None;
        Ok(Self {
            global_g_nb_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_g_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "32")]
pub struct GNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for GNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(22..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(GNB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 22);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(22..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum GNB_Identity {
    #[asn(key = 0, extended = false)]
    GNB_ID(GNB_ID),
}
impl asn1_codecs::Asn1Choice for GNB_Identity {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            GNB_Identity::GNB_ID(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct GTP_TEID(pub Vec<u8>);
impl entropic::Entropic for GTP_TEID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(GTP_TEID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GUMMEI {
    pub plmn_identity: PLMNidentity,
    pub mme_group_id: MME_Group_ID,
    pub mme_code: MME_Code,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GUMMEIIE_Extensions>,
}
impl entropic::Entropic for GUMMEI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let mme_group_id: MME_Group_ID = __entropic_internal_source.entropic()?;
        let mme_code: MME_Code = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<GUMMEIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            mme_group_id,
            mme_code,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .mme_group_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.mme_code.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct GUMMEIList(pub Vec<GUMMEI>);
impl entropic::Entropic for GUMMEIList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GUMMEI::from_finite_entropy(source)?);
        }
        Ok(GUMMEIList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct GUMMEIType(pub u8);
impl GUMMEIType {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}
impl entropic::Entropic for GUMMEIType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(GUMMEIType(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct GWContextReleaseIndication(pub u8);
impl GWContextReleaseIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for GWContextReleaseIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(GWContextReleaseIndication(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_ENB_ID {
    pub plm_nidentity: PLMNidentity,
    pub enb_id: ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_ENB_IDIE_Extensions>,
}
impl entropic::Entropic for Global_ENB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let enb_id: ENB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Global_ENB_IDIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            enb_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.enb_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_GNB_ID {
    pub plmn_identity: PLMNidentity,
    pub gnb_id: GNB_Identity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_GNB_IDIE_Extensions>,
}
impl entropic::Entropic for Global_GNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let gnb_id: GNB_Identity = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Global_GNB_IDIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            gnb_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.gnb_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum Global_RAN_NODE_ID {
    #[asn(key = 0, extended = false)]
    GNB(GNB),
    #[asn(key = 1, extended = false)]
    Ng_eNB(NG_eNB),
}
impl asn1_codecs::Asn1Choice for Global_RAN_NODE_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Global_RAN_NODE_ID::GNB(_) => 0u128.try_into().unwrap(),
            Global_RAN_NODE_ID::Ng_eNB(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_en_gNB_ID {
    pub plm_nidentity: PLMNidentity,
    pub en_g_nb_id: En_gNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_en_gNB_IDIE_Extensions>,
}
impl entropic::Entropic for Global_en_gNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let en_g_nb_id: En_gNB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Global_en_gNB_IDIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            en_g_nb_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .en_g_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct HFN(pub u32);
impl entropic::Entropic for HFN {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HFN(source.get_uniform_range(0..=1048575)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1048575 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "131071")]
pub struct HFNModified(pub u32);
impl entropic::Entropic for HFNModified {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HFNModified(source.get_uniform_range(0..=131071)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=131071 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct HFNforPDCP_SNlength18(pub u16);
impl entropic::Entropic for HFNforPDCP_SNlength18 {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HFNforPDCP_SNlength18(source.get_uniform_range(0..=16383)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=16383 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct HOReport {
    pub ho_type: HoType,
    pub ho_report_type: HoReportType,
    pub hosource_id: IRAT_Cell_ID,
    pub ho_target_id: IRAT_Cell_ID,
    pub candidate_cell_list: CandidateCellList,
    #[asn(optional_idx = 0)]
    pub candidate_pci_list: Option<CandidatePCIList>,
}
impl entropic::Entropic for HOReport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ho_type: HoType = __entropic_internal_source.entropic()?;
        let ho_report_type: HoReportType = __entropic_internal_source.entropic()?;
        let hosource_id: IRAT_Cell_ID = __entropic_internal_source.entropic()?;
        let ho_target_id: IRAT_Cell_ID = __entropic_internal_source.entropic()?;
        let candidate_cell_list: CandidateCellList = __entropic_internal_source.entropic()?;
        let candidate_pci_list: Option<CandidatePCIList> = __entropic_internal_source.entropic()?;
        Ok(Self {
            ho_type,
            ho_report_type,
            hosource_id,
            ho_target_id,
            candidate_cell_list,
            candidate_pci_list,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ho_type.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ho_report_type
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .hosource_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ho_target_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .candidate_cell_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .candidate_pci_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct HOReportingCause(pub u8);
impl HOReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl entropic::Entropic for HOReportingCause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HOReportingCause(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancel {
    pub protocol_i_es: HandoverCancelProtocolIEs,
}
impl entropic::Entropic for HandoverCancel {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverCancelProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancelAcknowledge {
    pub protocol_i_es: HandoverCancelAcknowledgeProtocolIEs,
}
impl entropic::Entropic for HandoverCancelAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverCancelAcknowledgeProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCommand {
    pub protocol_i_es: HandoverCommandProtocolIEs,
}
impl entropic::Entropic for HandoverCommand {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverCommandProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverFailure {
    pub protocol_i_es: HandoverFailureProtocolIEs,
}
impl entropic::Entropic for HandoverFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverFailureProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HandoverFlag(pub u8);
impl HandoverFlag {
    pub const HANDOVER_PREPARATION: u8 = 0u8;
}
impl entropic::Entropic for HandoverFlag {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HandoverFlag(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverNotify {
    pub protocol_i_es: HandoverNotifyProtocolIEs,
}
impl entropic::Entropic for HandoverNotify {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverNotifyProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverPreparationFailure {
    pub protocol_i_es: HandoverPreparationFailureProtocolIEs,
}
impl entropic::Entropic for HandoverPreparationFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverPreparationFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequest {
    pub protocol_i_es: HandoverRequestProtocolIEs,
}
impl entropic::Entropic for HandoverRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequestAcknowledge {
    pub protocol_i_es: HandoverRequestAcknowledgeProtocolIEs,
}
impl entropic::Entropic for HandoverRequestAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverRequestAcknowledgeProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequired {
    pub protocol_i_es: HandoverRequiredProtocolIEs,
}
impl entropic::Entropic for HandoverRequired {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverRequiredProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct HandoverRestrictionList {
    pub serving_plmn: PLMNidentity,
    #[asn(optional_idx = 0)]
    pub equivalent_plm_ns: Option<EPLMNs>,
    #[asn(optional_idx = 1)]
    pub forbidden_t_as: Option<ForbiddenTAs>,
    #[asn(optional_idx = 2)]
    pub forbidden_l_as: Option<ForbiddenLAs>,
    #[asn(optional_idx = 3)]
    pub forbidden_inter_ra_ts: Option<ForbiddenInterRATs>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<HandoverRestrictionListIE_Extensions>,
}
impl entropic::Entropic for HandoverRestrictionList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let serving_plmn: PLMNidentity = __entropic_internal_source.entropic()?;
        let equivalent_plm_ns: Option<EPLMNs> = __entropic_internal_source.entropic()?;
        let forbidden_t_as: Option<ForbiddenTAs> = __entropic_internal_source.entropic()?;
        let forbidden_l_as: Option<ForbiddenLAs> = __entropic_internal_source.entropic()?;
        let forbidden_inter_ra_ts: Option<ForbiddenInterRATs> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<HandoverRestrictionListIE_Extensions> = None;
        Ok(Self {
            serving_plmn,
            equivalent_plm_ns,
            forbidden_t_as,
            forbidden_l_as,
            forbidden_inter_ra_ts,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .serving_plmn
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .equivalent_plm_ns
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .forbidden_t_as
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .forbidden_l_as
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .forbidden_inter_ra_ts
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverSuccess {
    pub protocol_i_es: HandoverSuccessProtocolIEs,
}
impl entropic::Entropic for HandoverSuccess {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: HandoverSuccessProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct HandoverType(pub u8);
impl HandoverType {
    pub const INTRALTE: u8 = 0u8;
    pub const LTETOUTRAN: u8 = 1u8;
    pub const LTETOGERAN: u8 = 2u8;
    pub const UTRANTOLTE: u8 = 3u8;
    pub const GERANTOLTE: u8 = 4u8;
}
impl entropic::Entropic for HandoverType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HandoverType(source.get_uniform_range(0..=4)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HoReportType(pub u8);
impl HoReportType {
    pub const UNNECESSARYHOTOANOTHERRAT: u8 = 0u8;
}
impl entropic::Entropic for HoReportType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HoReportType(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct HoType(pub u8);
impl HoType {
    pub const LTETOUTRAN: u8 = 0u8;
    pub const LTETOGERAN: u8 = 1u8;
}
impl entropic::Entropic for HoType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(HoType(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IAB_Authorized(pub u8);
impl IAB_Authorized {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for IAB_Authorized {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IAB_Authorized(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Node_Indication(pub u8);
impl IAB_Node_Indication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for IAB_Node_Indication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IAB_Node_Indication(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Supported(pub u8);
impl IAB_Supported {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for IAB_Supported {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IAB_Supported(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "8")]
pub struct IMSI(pub Vec<u8>);
impl entropic::Entropic for IMSI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(IMSI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IMSvoiceEPSfallbackfrom5G(pub u8);
impl IMSvoiceEPSfallbackfrom5G {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for IMSvoiceEPSfallbackfrom5G {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IMSvoiceEPSfallbackfrom5G(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum IRAT_Cell_ID {
    #[asn(key = 0, extended = false)]
    EUTRAN(IRAT_Cell_ID_eUTRAN),
    #[asn(key = 1, extended = false)]
    UTRAN(IRAT_Cell_ID_uTRAN),
    #[asn(key = 2, extended = false)]
    GERAN(IRAT_Cell_ID_gERAN),
    #[asn(key = 0, extended = true)]
    EHRPD(EHRPD_Sector_ID),
}
impl asn1_codecs::Asn1Choice for IRAT_Cell_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            IRAT_Cell_ID::EUTRAN(_) => 0u128.try_into().unwrap(),
            IRAT_Cell_ID::UTRAN(_) => 1u128.try_into().unwrap(),
            IRAT_Cell_ID::GERAN(_) => 2u128.try_into().unwrap(),
            IRAT_Cell_ID::EHRPD(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ImmediateMDT {
    pub measurements_to_activate: MeasurementsToActivate,
    pub m1reporting_trigger: M1ReportingTrigger,
    #[asn(optional_idx = 0)]
    pub m1thresholdevent_a2: Option<M1ThresholdEventA2>,
    #[asn(optional_idx = 1)]
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ImmediateMDTIE_Extensions>,
}
impl entropic::Entropic for ImmediateMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let measurements_to_activate: MeasurementsToActivate =
            __entropic_internal_source.entropic()?;
        let m1reporting_trigger: M1ReportingTrigger = __entropic_internal_source.entropic()?;
        let m1thresholdevent_a2: Option<M1ThresholdEventA2> =
            __entropic_internal_source.entropic()?;
        let m1periodic_reporting: Option<M1PeriodicReporting> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ImmediateMDTIE_Extensions> = None;
        Ok(Self {
            measurements_to_activate,
            m1reporting_trigger,
            m1thresholdevent_a2,
            m1periodic_reporting,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .measurements_to_activate
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m1reporting_trigger
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m1thresholdevent_a2
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m1periodic_reporting
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InformationOnRecommendedCellsAndENBsForPaging {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    pub recommend_en_bs_for_paging: RecommendedENBsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InformationOnRecommendedCellsAndENBsForPagingIE_Extensions>,
}
impl entropic::Entropic for InformationOnRecommendedCellsAndENBsForPaging {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let recommended_cells_for_paging: RecommendedCellsForPaging =
            __entropic_internal_source.entropic()?;
        let recommend_en_bs_for_paging: RecommendedENBsForPaging =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<InformationOnRecommendedCellsAndENBsForPagingIE_Extensions> =
            None;
        Ok(Self {
            recommended_cells_for_paging,
            recommend_en_bs_for_paging,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .recommended_cells_for_paging
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .recommend_en_bs_for_paging
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupFailure {
    pub protocol_i_es: InitialContextSetupFailureProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: InitialContextSetupFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupRequest {
    pub protocol_i_es: InitialContextSetupRequestProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: InitialContextSetupRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupResponse {
    pub protocol_i_es: InitialContextSetupResponseProtocolIEs,
}
impl entropic::Entropic for InitialContextSetupResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: InitialContextSetupResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialUEMessage {
    pub protocol_i_es: InitialUEMessageProtocolIEs,
}
impl entropic::Entropic for InitialUEMessage {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: InitialUEMessageProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingMessage {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: InitiatingMessageValue,
}
impl entropic::Entropic for InitiatingMessage {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: InitiatingMessageValue = __entropic_internal_source.entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct IntegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for IntegrityProtectionAlgorithms {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(IntegrityProtectionAlgorithms(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct IntendedNumberOfPagingAttempts(pub u8);
impl entropic::Entropic for IntendedNumberOfPagingAttempts {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IntendedNumberOfPagingAttempts(
            source.get_uniform_range(1..=16)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=16 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum Inter_SystemInformationTransferType {
    #[asn(key = 0, extended = false)]
    RIMTransfer(RIMTransfer),
}
impl asn1_codecs::Asn1Choice for Inter_SystemInformationTransferType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Inter_SystemInformationTransferType::RIMTransfer(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct InterSystemMeasurementItem {
    pub freq_band_indicator_nr: InterSystemMeasurementItemFreqBandIndicatorNR,
    pub ss_bfrequencies: InterSystemMeasurementItemSSBfrequencies,
    pub subcarrier_spacing_ssb: InterSystemMeasurementItemSubcarrierSpacingSSB,
    #[asn(optional_idx = 0)]
    pub max_rs_index_cell_qual: Option<InterSystemMeasurementItemMaxRSIndexCellQual>,
    #[asn(optional_idx = 1)]
    pub smtc: Option<InterSystemMeasurementItemSMTC>,
    #[asn(optional_idx = 2)]
    pub thresh_rs_index_r15: Option<InterSystemMeasurementItemThreshRS_Index_r15>,
    #[asn(optional_idx = 3)]
    pub ssb_to_measure: Option<InterSystemMeasurementItemSSBToMeasure>,
    #[asn(optional_idx = 4)]
    pub ssrssi_measurement: Option<InterSystemMeasurementItemSSRSSIMeasurement>,
    #[asn(optional_idx = 5)]
    pub quantity_config_nr_r15: Option<InterSystemMeasurementItemQuantityConfigNR_R15>,
    #[asn(optional_idx = 6)]
    pub black_cells_to_add_mod_list: Option<InterSystemMeasurementItemBlackCellsToAddModList>,
    #[asn(optional_idx = 7)]
    pub ie_extensions: Option<InterSystemMeasurementItemIE_Extensions>,
}
impl entropic::Entropic for InterSystemMeasurementItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let freq_band_indicator_nr: InterSystemMeasurementItemFreqBandIndicatorNR =
            __entropic_internal_source.entropic()?;
        let ss_bfrequencies: InterSystemMeasurementItemSSBfrequencies =
            __entropic_internal_source.entropic()?;
        let subcarrier_spacing_ssb: InterSystemMeasurementItemSubcarrierSpacingSSB =
            __entropic_internal_source.entropic()?;
        let max_rs_index_cell_qual: Option<InterSystemMeasurementItemMaxRSIndexCellQual> =
            __entropic_internal_source.entropic()?;
        let smtc: Option<InterSystemMeasurementItemSMTC> = __entropic_internal_source.entropic()?;
        let thresh_rs_index_r15: Option<InterSystemMeasurementItemThreshRS_Index_r15> =
            __entropic_internal_source.entropic()?;
        let ssb_to_measure: Option<InterSystemMeasurementItemSSBToMeasure> =
            __entropic_internal_source.entropic()?;
        let ssrssi_measurement: Option<InterSystemMeasurementItemSSRSSIMeasurement> =
            __entropic_internal_source.entropic()?;
        let quantity_config_nr_r15: Option<InterSystemMeasurementItemQuantityConfigNR_R15> =
            __entropic_internal_source.entropic()?;
        let black_cells_to_add_mod_list: Option<InterSystemMeasurementItemBlackCellsToAddModList> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<InterSystemMeasurementItemIE_Extensions> = None;
        Ok(Self {
            freq_band_indicator_nr,
            ss_bfrequencies,
            subcarrier_spacing_ssb,
            max_rs_index_cell_qual,
            smtc,
            thresh_rs_index_r15,
            ssb_to_measure,
            ssrssi_measurement,
            quantity_config_nr_r15,
            black_cells_to_add_mod_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .freq_band_indicator_nr
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ss_bfrequencies
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .subcarrier_spacing_ssb
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .max_rs_index_cell_qual
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.smtc.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .thresh_rs_index_r15
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ssb_to_measure
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ssrssi_measurement
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .quantity_config_nr_r15
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .black_cells_to_add_mod_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct InterSystemMeasurementList(pub Vec<InterSystemMeasurementItem>);
impl entropic::Entropic for InterSystemMeasurementList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(64, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InterSystemMeasurementItem::from_finite_entropy(source)?);
        }
        Ok(InterSystemMeasurementList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(64, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct InterSystemMeasurementParameters {
    pub measurement_duration: InterSystemMeasurementParametersMeasurementDuration,
    #[asn(optional_idx = 0)]
    pub inter_system_measurement_list: Option<InterSystemMeasurementList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<InterSystemMeasurementParametersIE_Extensions>,
}
impl entropic::Entropic for InterSystemMeasurementParameters {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let measurement_duration: InterSystemMeasurementParametersMeasurementDuration =
            __entropic_internal_source.entropic()?;
        let inter_system_measurement_list: Option<InterSystemMeasurementList> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<InterSystemMeasurementParametersIE_Extensions> = None;
        Ok(Self {
            measurement_duration,
            inter_system_measurement_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .measurement_duration
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .inter_system_measurement_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct InterfacesToTrace(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for InterfacesToTrace {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(InterfacesToTrace(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct IntersystemMeasurementConfiguration {
    #[asn(optional_idx = 0)]
    pub rsrp: Option<IntersystemMeasurementConfigurationRSRP>,
    #[asn(optional_idx = 1)]
    pub rsrq: Option<IntersystemMeasurementConfigurationRSRQ>,
    #[asn(optional_idx = 2)]
    pub sinr: Option<IntersystemMeasurementConfigurationSINR>,
    pub inter_system_measurement_parameters: InterSystemMeasurementParameters,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<IntersystemMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for IntersystemMeasurementConfiguration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let rsrp: Option<IntersystemMeasurementConfigurationRSRP> =
            __entropic_internal_source.entropic()?;
        let rsrq: Option<IntersystemMeasurementConfigurationRSRQ> =
            __entropic_internal_source.entropic()?;
        let sinr: Option<IntersystemMeasurementConfigurationSINR> =
            __entropic_internal_source.entropic()?;
        let inter_system_measurement_parameters: InterSystemMeasurementParameters =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<IntersystemMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            rsrp,
            rsrq,
            sinr,
            inter_system_measurement_parameters,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.rsrp.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.rsrq.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.sinr.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .inter_system_measurement_parameters
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IntersystemSONConfigurationTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct KillAllWarningMessages(pub u8);
impl KillAllWarningMessages {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for KillAllWarningMessages {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(KillAllWarningMessages(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct KillRequest {
    pub protocol_i_es: KillRequestProtocolIEs,
}
impl entropic::Entropic for KillRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: KillRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct KillResponse {
    pub protocol_i_es: KillResponseProtocolIEs,
}
impl entropic::Entropic for KillResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: KillResponseProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct L3_Information(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LAC(pub Vec<u8>);
impl entropic::Entropic for LAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(LAC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LAI {
    pub plm_nidentity: PLMNidentity,
    pub lac: LAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LAIIE_Extensions>,
}
impl entropic::Entropic for LAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let lac: LAC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<LAIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            lac,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.lac.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "256"
)]
pub struct LHN_ID(pub Vec<u8>);
impl entropic::Entropic for LHN_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(32..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(LHN_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LPPa_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LTE_M_Indication(pub u8);
impl LTE_M_Indication {
    pub const LTE_M: u8 = 0u8;
}
impl entropic::Entropic for LTE_M_Indication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(LTE_M_Indication(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum LastVisitedCell_Item {
    #[asn(key = 0, extended = false)]
    E_UTRAN_Cell(LastVisitedEUTRANCellInformation),
    #[asn(key = 1, extended = false)]
    UTRAN_Cell(LastVisitedUTRANCellInformation),
    #[asn(key = 2, extended = false)]
    GERAN_Cell(LastVisitedGERANCellInformation),
    #[asn(key = 0, extended = true)]
    NG_RAN_Cell(LastVisitedNGRANCellInformation),
}
impl asn1_codecs::Asn1Choice for LastVisitedCell_Item {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            LastVisitedCell_Item::E_UTRAN_Cell(_) => 0u128.try_into().unwrap(),
            LastVisitedCell_Item::UTRAN_Cell(_) => 1u128.try_into().unwrap(),
            LastVisitedCell_Item::GERAN_Cell(_) => 2u128.try_into().unwrap(),
            LastVisitedCell_Item::NG_RAN_Cell(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LastVisitedEUTRANCellInformation {
    pub global_cell_id: EUTRAN_CGI,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: Time_UE_StayedInCell,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LastVisitedEUTRANCellInformationIE_Extensions>,
}
impl entropic::Entropic for LastVisitedEUTRANCellInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_cell_id: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let cell_type: CellType = __entropic_internal_source.entropic()?;
        let time_ue_stayed_in_cell: Time_UE_StayedInCell = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<LastVisitedEUTRANCellInformationIE_Extensions> = None;
        Ok(Self {
            global_cell_id,
            cell_type,
            time_ue_stayed_in_cell,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_cell_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.cell_type.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .time_ue_stayed_in_cell
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum LastVisitedGERANCellInformation {
    #[asn(key = 0, extended = false)]
    Undefined(LastVisitedGERANCellInformation_undefined),
}
impl asn1_codecs::Asn1Choice for LastVisitedGERANCellInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            LastVisitedGERANCellInformation::Undefined(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedNGRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Links_to_log(pub u8);
impl Links_to_log {
    pub const UPLINK: u8 = 0u8;
    pub const DOWNLINK: u8 = 1u8;
    pub const BOTH_UPLINK_AND_DOWNLINK: u8 = 2u8;
}
impl entropic::Entropic for Links_to_log {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Links_to_log(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ListeningSubframePattern {
    pub pattern_period: ListeningSubframePatternPattern_period,
    pub pattern_offset: ListeningSubframePatternPattern_offset,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ListeningSubframePatternIE_Extensions>,
}
impl entropic::Entropic for ListeningSubframePattern {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pattern_period: ListeningSubframePatternPattern_period =
            __entropic_internal_source.entropic()?;
        let pattern_offset: ListeningSubframePatternPattern_offset =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ListeningSubframePatternIE_Extensions> = None;
        Ok(Self {
            pattern_period,
            pattern_offset,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pattern_period
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pattern_offset
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReport {
    pub protocol_i_es: LocationReportProtocolIEs,
}
impl entropic::Entropic for LocationReport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: LocationReportProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingControl {
    pub protocol_i_es: LocationReportingControlProtocolIEs,
}
impl entropic::Entropic for LocationReportingControl {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: LocationReportingControlProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingFailureIndication {
    pub protocol_i_es: LocationReportingFailureIndicationProtocolIEs,
}
impl entropic::Entropic for LocationReportingFailureIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: LocationReportingFailureIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LoggedMBSFNMDT {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    #[asn(optional_idx = 0)]
    pub mbsfn_result_to_log: Option<MBSFN_ResultToLog>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<LoggedMBSFNMDTIE_Extensions>,
}
impl entropic::Entropic for LoggedMBSFNMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let logging_interval: LoggingInterval = __entropic_internal_source.entropic()?;
        let logging_duration: LoggingDuration = __entropic_internal_source.entropic()?;
        let mbsfn_result_to_log: Option<MBSFN_ResultToLog> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<LoggedMBSFNMDTIE_Extensions> = None;
        Ok(Self {
            logging_interval,
            logging_duration,
            mbsfn_result_to_log,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .logging_interval
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .logging_duration
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .mbsfn_result_to_log
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LoggedMDT {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LoggedMDTIE_Extensions>,
}
impl entropic::Entropic for LoggedMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let logging_interval: LoggingInterval = __entropic_internal_source.entropic()?;
        let logging_duration: LoggingDuration = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<LoggedMDTIE_Extensions> = None;
        Ok(Self {
            logging_interval,
            logging_duration,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .logging_interval
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .logging_duration
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct LoggingDuration(pub u8);
impl LoggingDuration {
    pub const M10: u8 = 0u8;
    pub const M20: u8 = 1u8;
    pub const M40: u8 = 2u8;
    pub const M60: u8 = 3u8;
    pub const M90: u8 = 4u8;
    pub const M120: u8 = 5u8;
}
impl entropic::Entropic for LoggingDuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(LoggingDuration(source.get_uniform_range(0..=5)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct LoggingInterval(pub u8);
impl LoggingInterval {
    pub const MS128: u8 = 0u8;
    pub const MS256: u8 = 1u8;
    pub const MS512: u8 = 2u8;
    pub const MS1024: u8 = 3u8;
    pub const MS2048: u8 = 4u8;
    pub const MS3072: u8 = 5u8;
    pub const MS4096: u8 = 6u8;
    pub const MS6144: u8 = 7u8;
}
impl entropic::Entropic for LoggingInterval {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(LoggingInterval(source.get_uniform_range(0..=7)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct M_TMSI(pub Vec<u8>);
impl entropic::Entropic for M_TMSI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(M_TMSI(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMDT,
    pub report_amount: ReportAmountMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1PeriodicReportingIE_Extensions>,
}
impl entropic::Entropic for M1PeriodicReporting {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let report_interval: ReportIntervalMDT = __entropic_internal_source.entropic()?;
        let report_amount: ReportAmountMDT = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M1PeriodicReportingIE_Extensions> = None;
        Ok(Self {
            report_interval,
            report_amount,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .report_interval
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .report_amount
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct M1ReportingTrigger(pub u8);
impl M1ReportingTrigger {
    pub const PERIODIC: u8 = 0u8;
    pub const A2EVENTTRIGGERED: u8 = 1u8;
}
impl entropic::Entropic for M1ReportingTrigger {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M1ReportingTrigger(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1ThresholdEventA2 {
    pub measurement_threshold: MeasurementThresholdA2,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1ThresholdEventA2IE_Extensions>,
}
impl entropic::Entropic for M1ThresholdEventA2 {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let measurement_threshold: MeasurementThresholdA2 =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M1ThresholdEventA2IE_Extensions> = None;
        Ok(Self {
            measurement_threshold,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .measurement_threshold
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M3Configuration {
    pub m3period: M3period,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M3ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M3Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let m3period: M3period = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M3ConfigurationIE_Extensions> = None;
        Ok(Self {
            m3period,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m3period.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct M3period(pub u8);
impl M3period {
    pub const MS100: u8 = 0u8;
    pub const MS1000: u8 = 1u8;
    pub const MS10000: u8 = 2u8;
}
impl entropic::Entropic for M3period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M3period(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M4ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M4Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let m4period: M4period = __entropic_internal_source.entropic()?;
        let m4_links_to_log: Links_to_log = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M4ConfigurationIE_Extensions> = None;
        Ok(Self {
            m4period,
            m4_links_to_log,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m4period.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m4_links_to_log
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M4period(pub u8);
impl M4period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl entropic::Entropic for M4period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M4period(source.get_uniform_range(0..=4)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M5ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M5Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let m5period: M5period = __entropic_internal_source.entropic()?;
        let m5_links_to_log: Links_to_log = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M5ConfigurationIE_Extensions> = None;
        Ok(Self {
            m5period,
            m5_links_to_log,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m5period.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m5_links_to_log
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M5period(pub u8);
impl M5period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl entropic::Entropic for M5period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M5period(source.get_uniform_range(0..=4)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct M6Configuration {
    pub m6report_interval: M6report_Interval,
    #[asn(optional_idx = 0)]
    pub m6delay_threshold: Option<M6delay_threshold>,
    pub m6_links_to_log: Links_to_log,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<M6ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M6Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let m6report_interval: M6report_Interval = __entropic_internal_source.entropic()?;
        let m6delay_threshold: Option<M6delay_threshold> = __entropic_internal_source.entropic()?;
        let m6_links_to_log: Links_to_log = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M6ConfigurationIE_Extensions> = None;
        Ok(Self {
            m6report_interval,
            m6delay_threshold,
            m6_links_to_log,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .m6report_interval
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m6delay_threshold
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m6_links_to_log
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "11")]
pub struct M6delay_threshold(pub u8);
impl M6delay_threshold {
    pub const MS30: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS50: u8 = 2u8;
    pub const MS60: u8 = 3u8;
    pub const MS70: u8 = 4u8;
    pub const MS80: u8 = 5u8;
    pub const MS90: u8 = 6u8;
    pub const MS100: u8 = 7u8;
    pub const MS150: u8 = 8u8;
    pub const MS300: u8 = 9u8;
    pub const MS500: u8 = 10u8;
    pub const MS750: u8 = 11u8;
}
impl entropic::Entropic for M6delay_threshold {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M6delay_threshold(source.get_uniform_range(0..=11)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=11 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct M6report_Interval(pub u8);
impl M6report_Interval {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
}
impl entropic::Entropic for M6report_Interval {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M6report_Interval(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M7ConfigurationIE_Extensions>,
}
impl entropic::Entropic for M7Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let m7period: M7period = __entropic_internal_source.entropic()?;
        let m7_links_to_log: Links_to_log = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<M7ConfigurationIE_Extensions> = None;
        Ok(Self {
            m7period,
            m7_links_to_log,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.m7period.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .m7_links_to_log
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "60", extensible = true)]
pub struct M7period(pub u8);
impl entropic::Entropic for M7period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(M7period(source.get_uniform_range(1..=60)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=60 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_ResultToLog(pub Vec<MBSFN_ResultToLogInfo>);
impl entropic::Entropic for MBSFN_ResultToLog {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MBSFN_ResultToLogInfo::from_finite_entropy(source)?);
        }
        Ok(MBSFN_ResultToLog(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MBSFN_ResultToLogInfo {
    #[asn(optional_idx = 0)]
    pub mbsfn_area_id: Option<MBSFN_ResultToLogInfoMBSFN_AreaId>,
    pub carrier_freq: EARFCN,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MBSFN_ResultToLogInfoIE_Extensions>,
}
impl entropic::Entropic for MBSFN_ResultToLogInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mbsfn_area_id: Option<MBSFN_ResultToLogInfoMBSFN_AreaId> =
            __entropic_internal_source.entropic()?;
        let carrier_freq: EARFCN = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<MBSFN_ResultToLogInfoIE_Extensions> = None;
        Ok(Self {
            mbsfn_area_id,
            carrier_freq,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .mbsfn_area_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .carrier_freq
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct MDT_Activation(pub u8);
impl MDT_Activation {
    pub const IMMEDIATE_MDT_ONLY: u8 = 0u8;
    pub const IMMEDIATE_MDT_AND_TRACE: u8 = 1u8;
    pub const LOGGED_MDT_ONLY: u8 = 2u8;
}
impl entropic::Entropic for MDT_Activation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MDT_Activation(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MDT_Configuration {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT,
    pub mdt_mode: MDTMode,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MDT_ConfigurationIE_Extensions>,
}
impl entropic::Entropic for MDT_Configuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mdt_activation: MDT_Activation = __entropic_internal_source.entropic()?;
        let area_scope_of_mdt: AreaScopeOfMDT = __entropic_internal_source.entropic()?;
        let mdt_mode: MDTMode = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<MDT_ConfigurationIE_Extensions> = None;
        Ok(Self {
            mdt_activation,
            area_scope_of_mdt,
            mdt_mode,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .mdt_activation
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .area_scope_of_mdt
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.mdt_mode.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MDT_ConfigurationNR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MDT_Location_Info(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MDT_Location_Info {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(MDT_Location_Info(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MDTMode {
    #[asn(key = 0, extended = false)]
    ImmediateMDT(ImmediateMDT),
    #[asn(key = 1, extended = false)]
    LoggedMDT(LoggedMDT),
    #[asn(key = 0, extended = true)]
    MDTMode_Extension(MDTMode_Extension),
}
impl asn1_codecs::Asn1Choice for MDTMode {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MDTMode::ImmediateMDT(_) => 0u128.try_into().unwrap(),
            MDTMode::LoggedMDT(_) => 1u128.try_into().unwrap(),
            MDTMode::MDTMode_Extension(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDTMode_Extension {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MDTMode_ExtensionValue,
}
impl entropic::Entropic for MDTMode_Extension {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MDTMode_ExtensionValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MDTPLMNList(pub Vec<PLMNidentity>);
impl entropic::Entropic for MDTPLMNList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNidentity::from_finite_entropy(source)?);
        }
        Ok(MDTPLMNList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MME_Code(pub Vec<u8>);
impl entropic::Entropic for MME_Code {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(MME_Code(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MME_Group_ID(pub Vec<u8>);
impl entropic::Entropic for MME_Group_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(MME_Group_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct MME_UE_S1AP_ID(pub u32);
impl entropic::Entropic for MME_UE_S1AP_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MME_UE_S1AP_ID(source.get_uniform_range(0..=4294967295)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4294967295 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMECPRelocationIndication {
    pub protocol_i_es: MMECPRelocationIndicationProtocolIEs,
}
impl entropic::Entropic for MMECPRelocationIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMECPRelocationIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationTransfer {
    pub protocol_i_es: MMEConfigurationTransferProtocolIEs,
}
impl entropic::Entropic for MMEConfigurationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEConfigurationTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdate {
    pub protocol_i_es: MMEConfigurationUpdateProtocolIEs,
}
impl entropic::Entropic for MMEConfigurationUpdate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEConfigurationUpdateProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdateAcknowledge {
    pub protocol_i_es: MMEConfigurationUpdateAcknowledgeProtocolIEs,
}
impl entropic::Entropic for MMEConfigurationUpdateAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEConfigurationUpdateAcknowledgeProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdateFailure {
    pub protocol_i_es: MMEConfigurationUpdateFailureProtocolIEs,
}
impl entropic::Entropic for MMEConfigurationUpdateFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEConfigurationUpdateFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEDirectInformationTransfer {
    pub protocol_i_es: MMEDirectInformationTransferProtocolIEs,
}
impl entropic::Entropic for MMEDirectInformationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEDirectInformationTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEEarlyStatusTransfer {
    pub protocol_i_es: MMEEarlyStatusTransferProtocolIEs,
}
impl entropic::Entropic for MMEEarlyStatusTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEEarlyStatusTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MMEPagingTarget {
    #[asn(key = 0, extended = false)]
    Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 1, extended = false)]
    TAI(TAI),
}
impl asn1_codecs::Asn1Choice for MMEPagingTarget {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MMEPagingTarget::Global_ENB_ID(_) => 0u128.try_into().unwrap(),
            MMEPagingTarget::TAI(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MMERelaySupportIndicator(pub u8);
impl MMERelaySupportIndicator {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for MMERelaySupportIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MMERelaySupportIndicator(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEStatusTransfer {
    pub protocol_i_es: MMEStatusTransferProtocolIEs,
}
impl entropic::Entropic for MMEStatusTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: MMEStatusTransferProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct MMEname(pub String);
impl entropic::Entropic for MMEname {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(150, 16383);
        let strlen = source.get_bounded_len(1..=capped_max)?;
        let mut s = String::new();
        for _ in 0..strlen {
            s.push(char::from_finite_entropy(source)?);
        }
        Ok(Self(s))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(150, 16383);
        let mut length = 0;
        let strlen = self.0.chars().count();
        length += sink.put_bounded_len(1..=capped_max, strlen)?;
        for c in self.0.chars() {
            length += c.to_finite_entropy(sink)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MSClassmark2(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MSClassmark3(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ManagementBasedMDTAllowed(pub u8);
impl ManagementBasedMDTAllowed {
    pub const ALLOWED: u8 = 0u8;
}
impl entropic::Entropic for ManagementBasedMDTAllowed {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ManagementBasedMDTAllowed(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct Masked_IMEISV(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for Masked_IMEISV {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(64, 16383);
        let total_bitlen = source.get_bounded_len(64..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(Masked_IMEISV(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 64);
        let capped_max = std::cmp::min(64, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(64..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MeasurementThresholdA2 {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
}
impl asn1_codecs::Asn1Choice for MeasurementThresholdA2 {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MeasurementThresholdA2::Threshold_RSRP(_) => 0u128.try_into().unwrap(),
            MeasurementThresholdA2::Threshold_RSRQ(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasurementsToActivate(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MeasurementsToActivate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(MeasurementsToActivate(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MessageIdentifier(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MessageIdentifier {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(MessageIdentifier(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct MobilityInformation(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for MobilityInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(32, 16383);
        let total_bitlen = source.get_bounded_len(32..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(MobilityInformation(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 32);
        let capped_max = std::cmp::min(32, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(32..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MultiCellLoadReportingRequest {
    pub requested_cell_list: RequestedCellList,
}
impl entropic::Entropic for MultiCellLoadReportingRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let requested_cell_list: RequestedCellList = __entropic_internal_source.entropic()?;
        Ok(Self {
            requested_cell_list,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .requested_cell_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct MultiCellLoadReportingResponse(pub Vec<MultiCellLoadReportingResponse_Item>);
impl entropic::Entropic for MultiCellLoadReportingResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(128, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MultiCellLoadReportingResponse_Item::from_finite_entropy(
                source,
            )?);
        }
        Ok(MultiCellLoadReportingResponse(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(128, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum MultiCellLoadReportingResponse_Item {
    #[asn(key = 0, extended = false)]
    EUTRANResponse(EUTRANResponse),
    #[asn(key = 1, extended = false)]
    UTRANResponse(MultiCellLoadReportingResponse_Item_uTRANResponse),
    #[asn(key = 2, extended = false)]
    GERANResponse(MultiCellLoadReportingResponse_Item_gERANResponse),
    #[asn(key = 0, extended = true)]
    EHRPD(EHRPDMultiSectorLoadReportingResponseItem),
}
impl asn1_codecs::Asn1Choice for MultiCellLoadReportingResponse_Item {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            MultiCellLoadReportingResponse_Item::EUTRANResponse(_) => 0u128.try_into().unwrap(),
            MultiCellLoadReportingResponse_Item::UTRANResponse(_) => 1u128.try_into().unwrap(),
            MultiCellLoadReportingResponse_Item::GERANResponse(_) => 2u128.try_into().unwrap(),
            MultiCellLoadReportingResponse_Item::EHRPD(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct MutingAvailabilityIndication(pub u8);
impl MutingAvailabilityIndication {
    pub const AVAILABLE: u8 = 0u8;
    pub const UNAVAILABLE: u8 = 1u8;
}
impl entropic::Entropic for MutingAvailabilityIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MutingAvailabilityIndication(
            source.get_uniform_range(0..=1)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MutingPatternInformation {
    pub muting_pattern_period: MutingPatternInformationMuting_pattern_period,
    #[asn(optional_idx = 0)]
    pub muting_pattern_offset: Option<MutingPatternInformationMuting_pattern_offset>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MutingPatternInformationIE_Extensions>,
}
impl entropic::Entropic for MutingPatternInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let muting_pattern_period: MutingPatternInformationMuting_pattern_period =
            __entropic_internal_source.entropic()?;
        let muting_pattern_offset: Option<MutingPatternInformationMuting_pattern_offset> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<MutingPatternInformationIE_Extensions> = None;
        Ok(Self {
            muting_pattern_period,
            muting_pattern_offset,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .muting_pattern_period
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .muting_pattern_offset
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NAS_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASDeliveryIndication {
    pub protocol_i_es: NASDeliveryIndicationProtocolIEs,
}
impl entropic::Entropic for NASDeliveryIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: NASDeliveryIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASNonDeliveryIndication {
    pub protocol_i_es: NASNonDeliveryIndicationProtocolIEs,
}
impl entropic::Entropic for NASNonDeliveryIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: NASNonDeliveryIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParametersfromE_UTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParameterstoE_UTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct NB_IoT_DefaultPagingDRX(pub u8);
impl NB_IoT_DefaultPagingDRX {
    pub const V128: u8 = 0u8;
    pub const V256: u8 = 1u8;
    pub const V512: u8 = 2u8;
    pub const V1024: u8 = 3u8;
}
impl entropic::Entropic for NB_IoT_DefaultPagingDRX {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NB_IoT_DefaultPagingDRX(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct NB_IoT_Paging_eDRX_Cycle(pub u8);
impl NB_IoT_Paging_eDRX_Cycle {
    pub const HF2: u8 = 0u8;
    pub const HF4: u8 = 1u8;
    pub const HF6: u8 = 2u8;
    pub const HF8: u8 = 3u8;
    pub const HF10: u8 = 4u8;
    pub const HF12: u8 = 5u8;
    pub const HF14: u8 = 6u8;
    pub const HF16: u8 = 7u8;
    pub const HF32: u8 = 8u8;
    pub const HF64: u8 = 9u8;
    pub const HF128: u8 = 10u8;
    pub const HF256: u8 = 11u8;
    pub const HF512: u8 = 12u8;
    pub const HF1024: u8 = 13u8;
}
impl entropic::Entropic for NB_IoT_Paging_eDRX_Cycle {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NB_IoT_Paging_eDRX_Cycle(source.get_uniform_range(0..=13)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=13 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NB_IoT_Paging_eDRXInformation {
    pub nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub nb_io_t_paging_time_window: Option<NB_IoT_PagingTimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NB_IoT_Paging_eDRXInformationIE_Extensions>,
}
impl entropic::Entropic for NB_IoT_Paging_eDRXInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRX_Cycle =
            __entropic_internal_source.entropic()?;
        let nb_io_t_paging_time_window: Option<NB_IoT_PagingTimeWindow> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NB_IoT_Paging_eDRXInformationIE_Extensions> = None;
        Ok(Self {
            nb_io_t_paging_e_drx_cycle,
            nb_io_t_paging_time_window,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .nb_io_t_paging_e_drx_cycle
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .nb_io_t_paging_time_window
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct NB_IoT_PagingDRX(pub u8);
impl NB_IoT_PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
    pub const V512: u8 = 4u8;
    pub const V1024: u8 = 5u8;
}
impl entropic::Entropic for NB_IoT_PagingDRX {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NB_IoT_PagingDRX(source.get_uniform_range(0..=5)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct NB_IoT_PagingTimeWindow(pub u8);
impl NB_IoT_PagingTimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl entropic::Entropic for NB_IoT_PagingTimeWindow {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NB_IoT_PagingTimeWindow(source.get_uniform_range(0..=15)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NB_IoT_RLF_Report_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "12", sz_ub = "12")]
pub struct NB_IoT_UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NB_IoT_UEIdentityIndexValue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(12, 16383);
        let total_bitlen = source.get_bounded_len(12..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(NB_IoT_UEIdentityIndexValue(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 12);
        let capped_max = std::cmp::min(12, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(12..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NG_eNB {
    pub global_ng_e_nb_id: Global_ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NG_eNBIE_Extensions>,
}
impl entropic::Entropic for NG_eNB {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_ng_e_nb_id: Global_ENB_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NG_eNBIE_Extensions> = None;
        Ok(Self {
            global_ng_e_nb_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_ng_e_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NR_CGI {
    pub plmn_identity: PLMNidentity,
    pub nr_cell_identity: NRCellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NR_CGIIE_Extensions>,
}
impl entropic::Entropic for NR_CGI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_identity: PLMNidentity = __entropic_internal_source.entropic()?;
        let nr_cell_identity: NRCellIdentity = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NR_CGIIE_Extensions> = None;
        Ok(Self {
            plmn_identity,
            nr_cell_identity,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .nr_cell_identity
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct NRCellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRCellIdentity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(36, 16383);
        let total_bitlen = source.get_bounded_len(36..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(NRCellIdentity(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 36);
        let capped_max = std::cmp::min(36, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(36..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESecurityCapabilities {
    pub n_rencryption_algorithms: NRencryptionAlgorithms,
    pub n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESecurityCapabilitiesIE_Extensions>,
}
impl entropic::Entropic for NRUESecurityCapabilities {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let n_rencryption_algorithms: NRencryptionAlgorithms =
            __entropic_internal_source.entropic()?;
        let n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NRUESecurityCapabilitiesIE_Extensions> = None;
        Ok(Self {
            n_rencryption_algorithms,
            n_rintegrity_protection_algorithms,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .n_rencryption_algorithms
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .n_rintegrity_protection_algorithms
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESidelinkAggregateMaximumBitrate {
    pub u_eaggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions>,
}
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let u_eaggregate_maximum_bit_rate: BitRate = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions> = None;
        Ok(Self {
            u_eaggregate_maximum_bit_rate,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .u_eaggregate_maximum_bit_rate
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions>,
}
impl entropic::Entropic for NRV2XServicesAuthorized {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let vehicle_ue: Option<VehicleUE> = __entropic_internal_source.entropic()?;
        let pedestrian_ue: Option<PedestrianUE> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions> = None;
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .vehicle_ue
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pedestrian_ue
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRencryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRencryptionAlgorithms {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(NRencryptionAlgorithms(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRintegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for NRintegrityProtectionAlgorithms {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(NRintegrityProtectionAlgorithms(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictionin5GS(pub u8);
impl NRrestrictionin5GS {
    pub const N_RRESTRICTEDIN5_GS: u8 = 0u8;
}
impl entropic::Entropic for NRrestrictionin5GS {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NRrestrictionin5GS(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictioninEPSasSecondaryRAT(pub u8);
impl NRrestrictioninEPSasSecondaryRAT {
    pub const N_RRESTRICTEDIN_EP_SAS_SECONDARY_RAT: u8 = 0u8;
}
impl entropic::Entropic for NRrestrictioninEPSasSecondaryRAT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NRrestrictioninEPSasSecondaryRAT(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NextPagingAreaScope(pub u8);
impl NextPagingAreaScope {
    pub const SAME: u8 = 0u8;
    pub const CHANGED: u8 = 1u8;
}
impl entropic::Entropic for NextPagingAreaScope {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NextPagingAreaScope(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct NotificationCellList(pub Vec<NotificationCellList_Item>);
impl entropic::Entropic for NotificationCellList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NotificationCellList_Item::from_finite_entropy(source)?);
        }
        Ok(NotificationCellList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NotificationCellList_Item {
    pub cell_id: NotificationCellList_ItemCell_ID,
    pub notify_flag: NotifyFlag,
}
impl entropic::Entropic for NotificationCellList_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id: NotificationCellList_ItemCell_ID = __entropic_internal_source.entropic()?;
        let notify_flag: NotifyFlag = __entropic_internal_source.entropic()?;
        Ok(Self {
            cell_id,
            notify_flag,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .notify_flag
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NotifyFlag(pub u8);
impl NotifyFlag {
    pub const ACTIVATED: u8 = 0u8;
    pub const DEACTIVATED: u8 = 1u8;
}
impl entropic::Entropic for NotifyFlag {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NotifyFlag(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotifySourceeNB(pub u8);
impl NotifySourceeNB {
    pub const NOTIFY_SOURCE: u8 = 0u8;
}
impl entropic::Entropic for NotifySourceeNB {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NotifySourceeNB(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcasts(pub u16);
impl entropic::Entropic for NumberOfBroadcasts {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NumberOfBroadcasts(source.get_uniform_range(0..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct NumberOfMeasurementReportingLevels(pub u8);
impl NumberOfMeasurementReportingLevels {
    pub const RL2: u8 = 0u8;
    pub const RL3: u8 = 1u8;
    pub const RL4: u8 = 2u8;
    pub const RL5: u8 = 3u8;
    pub const RL10: u8 = 4u8;
}
impl entropic::Entropic for NumberOfMeasurementReportingLevels {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NumberOfMeasurementReportingLevels(
            source.get_uniform_range(0..=4)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberofBroadcastRequest(pub u16);
impl entropic::Entropic for NumberofBroadcastRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(NumberofBroadcastRequest(
            source.get_uniform_range(0..=65535)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OldBSS_ToNewBSS_Information(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct OverloadAction(pub u8);
impl OverloadAction {
    pub const REJECT_NON_EMERGENCY_MO_DT: u8 = 0u8;
    pub const REJECT_RRC_CR_SIGNALLING: u8 = 1u8;
    pub const PERMIT_EMERGENCY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 2u8;
}
impl entropic::Entropic for OverloadAction {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(OverloadAction(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct OverloadFlag(pub u8);
impl OverloadFlag {
    pub const OVERLOAD: u8 = 0u8;
}
impl entropic::Entropic for OverloadFlag {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(OverloadFlag(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum OverloadResponse {
    #[asn(key = 0, extended = false)]
    OverloadAction(OverloadAction),
}
impl asn1_codecs::Asn1Choice for OverloadResponse {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            OverloadResponse::OverloadAction(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStart {
    pub protocol_i_es: OverloadStartProtocolIEs,
}
impl entropic::Entropic for OverloadStart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: OverloadStartProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStop {
    pub protocol_i_es: OverloadStopProtocolIEs,
}
impl entropic::Entropic for OverloadStop {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: OverloadStopProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PC5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PC5FlowBitRatesIE_Extensions>,
}
impl entropic::Entropic for PC5FlowBitRates {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let guaranteed_flow_bit_rate: BitRate = __entropic_internal_source.entropic()?;
        let maximum_flow_bit_rate: BitRate = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PC5FlowBitRatesIE_Extensions> = None;
        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .guaranteed_flow_bit_rate
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .maximum_flow_bit_rate
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PC5QoSFlowItem {
    pub pqi: FiveQI,
    #[asn(optional_idx = 0)]
    pub pc5_flow_bit_rates: Option<PC5FlowBitRates>,
    #[asn(optional_idx = 1)]
    pub range: Option<Range>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PC5QoSFlowItemIE_Extensions>,
}
impl entropic::Entropic for PC5QoSFlowItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pqi: FiveQI = __entropic_internal_source.entropic()?;
        let pc5_flow_bit_rates: Option<PC5FlowBitRates> = __entropic_internal_source.entropic()?;
        let range: Option<Range> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PC5QoSFlowItemIE_Extensions> = None;
        Ok(Self {
            pqi,
            pc5_flow_bit_rates,
            range,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.pqi.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pc5_flow_bit_rates
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.range.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct PC5QoSFlowList(pub Vec<PC5QoSFlowItem>);
impl entropic::Entropic for PC5QoSFlowList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2048, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSFlowItem::from_finite_entropy(source)?);
        }
        Ok(PC5QoSFlowList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2048, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PC5QoSParameters {
    pub pc5_qo_s_flow_list: PC5QoSFlowList,
    #[asn(optional_idx = 0)]
    pub pc5_link_aggregated_bit_rates: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PC5QoSParametersIE_Extensions>,
}
impl entropic::Entropic for PC5QoSParameters {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pc5_qo_s_flow_list: PC5QoSFlowList = __entropic_internal_source.entropic()?;
        let pc5_link_aggregated_bit_rates: Option<BitRate> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PC5QoSParametersIE_Extensions> = None;
        Ok(Self {
            pc5_qo_s_flow_list,
            pc5_link_aggregated_bit_rates,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pc5_qo_s_flow_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pc5_link_aggregated_bit_rates
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct PDCP_SN(pub u16);
impl entropic::Entropic for PDCP_SN {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PDCP_SN(source.get_uniform_range(0..=4095)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32767")]
pub struct PDCP_SNExtended(pub u16);
impl entropic::Entropic for PDCP_SNExtended {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PDCP_SNExtended(source.get_uniform_range(0..=32767)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=32767 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct PDCP_SNlength18(pub u32);
impl entropic::Entropic for PDCP_SNlength18 {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PDCP_SNlength18(source.get_uniform_range(0..=262143)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=262143 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PLMNAreaBasedQMC {
    pub plmn_listfor_qmc: PLMNListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PLMNAreaBasedQMCIE_Extensions>,
}
impl entropic::Entropic for PLMNAreaBasedQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plmn_listfor_qmc: PLMNListforQMC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PLMNAreaBasedQMCIE_Extensions> = None;
        Ok(Self {
            plmn_listfor_qmc,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plmn_listfor_qmc
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PLMNListforQMC(pub Vec<PLMNidentity>);
impl entropic::Entropic for PLMNListforQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNidentity::from_finite_entropy(source)?);
        }
        Ok(PLMNListforQMC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

pub type PLMNidentity = TBCD_STRING;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PS_ServiceNotAvailable(pub u8);
impl PS_ServiceNotAvailable {
    pub const PS_SERVICE_NOT_AVAILABLE: u8 = 0u8;
}
impl entropic::Entropic for PS_ServiceNotAvailable {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PS_ServiceNotAvailable(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PSCellInformation {
    pub ncgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PSCellInformationIE_Extensions>,
}
impl entropic::Entropic for PSCellInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ncgi: NR_CGI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PSCellInformationIE_Extensions> = None;
        Ok(Self {
            ncgi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.ncgi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSFailureIndication {
    pub protocol_i_es: PWSFailureIndicationProtocolIEs,
}
impl entropic::Entropic for PWSFailureIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PWSFailureIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSRestartIndication {
    pub protocol_i_es: PWSRestartIndicationProtocolIEs,
}
impl entropic::Entropic for PWSRestartIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PWSRestartIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PWSfailedECGIList(pub Vec<EUTRAN_CGI>);
impl entropic::Entropic for PWSfailedECGIList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGI::from_finite_entropy(source)?);
        }
        Ok(PWSfailedECGIList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct Packet_LossRate(pub u16);
impl entropic::Entropic for Packet_LossRate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Packet_LossRate(source.get_uniform_range(0..=1000)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1000 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Paging {
    pub protocol_i_es: PagingProtocolIEs,
}
impl entropic::Entropic for Paging {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PagingProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct Paging_eDRX_Cycle(pub u8);
impl Paging_eDRX_Cycle {
    pub const HFHALF: u8 = 0u8;
    pub const HF1: u8 = 1u8;
    pub const HF2: u8 = 2u8;
    pub const HF4: u8 = 3u8;
    pub const HF6: u8 = 4u8;
    pub const HF8: u8 = 5u8;
    pub const HF10: u8 = 6u8;
    pub const HF12: u8 = 7u8;
    pub const HF14: u8 = 8u8;
    pub const HF16: u8 = 9u8;
    pub const HF32: u8 = 10u8;
    pub const HF64: u8 = 11u8;
    pub const HF128: u8 = 12u8;
    pub const HF256: u8 = 13u8;
}
impl entropic::Entropic for Paging_eDRX_Cycle {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Paging_eDRX_Cycle(source.get_uniform_range(0..=13)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=13 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Paging_eDRXInformation {
    pub paging_e_drx_cycle: Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub paging_time_window: Option<PagingTimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Paging_eDRXInformationIE_Extensions>,
}
impl entropic::Entropic for Paging_eDRXInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let paging_e_drx_cycle: Paging_eDRX_Cycle = __entropic_internal_source.entropic()?;
        let paging_time_window: Option<PagingTimeWindow> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Paging_eDRXInformationIE_Extensions> = None;
        Ok(Self {
            paging_e_drx_cycle,
            paging_time_window,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .paging_e_drx_cycle
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .paging_time_window
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct PagingAttemptCount(pub u8);
impl entropic::Entropic for PagingAttemptCount {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PagingAttemptCount(source.get_uniform_range(1..=16)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=16 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingAttemptInformation {
    pub paging_attempt_count: PagingAttemptCount,
    pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
    #[asn(optional_idx = 0)]
    pub next_paging_area_scope: Option<NextPagingAreaScope>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingAttemptInformationIE_Extensions>,
}
impl entropic::Entropic for PagingAttemptInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let paging_attempt_count: PagingAttemptCount = __entropic_internal_source.entropic()?;
        let intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts =
            __entropic_internal_source.entropic()?;
        let next_paging_area_scope: Option<NextPagingAreaScope> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<PagingAttemptInformationIE_Extensions> = None;
        Ok(Self {
            paging_attempt_count,
            intended_number_of_paging_attempts,
            next_paging_area_scope,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .paging_attempt_count
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .intended_number_of_paging_attempts
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .next_paging_area_scope
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct PagingDRX(pub u8);
impl PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
}
impl entropic::Entropic for PagingDRX {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PagingDRX(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct PagingPriority(pub u8);
impl PagingPriority {
    pub const PRIOLEVEL1: u8 = 0u8;
    pub const PRIOLEVEL2: u8 = 1u8;
    pub const PRIOLEVEL3: u8 = 2u8;
    pub const PRIOLEVEL4: u8 = 3u8;
    pub const PRIOLEVEL5: u8 = 4u8;
    pub const PRIOLEVEL6: u8 = 5u8;
    pub const PRIOLEVEL7: u8 = 6u8;
    pub const PRIOLEVEL8: u8 = 7u8;
}
impl entropic::Entropic for PagingPriority {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PagingPriority(source.get_uniform_range(0..=7)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "20")]
pub struct PagingProbabilityInformation(pub u8);
impl PagingProbabilityInformation {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P35: u8 = 7u8;
    pub const P40: u8 = 8u8;
    pub const P45: u8 = 9u8;
    pub const P50: u8 = 10u8;
    pub const P55: u8 = 11u8;
    pub const P60: u8 = 12u8;
    pub const P65: u8 = 13u8;
    pub const P70: u8 = 14u8;
    pub const P75: u8 = 15u8;
    pub const P80: u8 = 16u8;
    pub const P85: u8 = 17u8;
    pub const P90: u8 = 18u8;
    pub const P95: u8 = 19u8;
    pub const P100: u8 = 20u8;
}
impl entropic::Entropic for PagingProbabilityInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PagingProbabilityInformation(
            source.get_uniform_range(0..=20)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=20 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct PagingTimeWindow(pub u8);
impl PagingTimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl entropic::Entropic for PagingTimeWindow {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PagingTimeWindow(source.get_uniform_range(0..=15)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequest {
    pub protocol_i_es: PathSwitchRequestProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PathSwitchRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestAcknowledge {
    pub protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequestAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestFailure {
    pub protocol_i_es: PathSwitchRequestFailureProtocolIEs,
}
impl entropic::Entropic for PathSwitchRequestFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: PathSwitchRequestFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PedestrianUE(pub u8);
impl PedestrianUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for PedestrianUE {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PedestrianUE(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PendingDataIndication(pub u8);
impl PendingDataIndication {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for PendingDataIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PendingDataIndication(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct Port_Number(pub Vec<u8>);
impl entropic::Entropic for Port_Number {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(Port_Number(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionCapability(pub u8);
impl Pre_emptionCapability {
    pub const SHALL_NOT_TRIGGER_PRE_EMPTION: u8 = 0u8;
    pub const MAY_TRIGGER_PRE_EMPTION: u8 = 1u8;
}
impl entropic::Entropic for Pre_emptionCapability {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Pre_emptionCapability(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionVulnerability(pub u8);
impl Pre_emptionVulnerability {
    pub const NOT_PRE_EMPTABLE: u8 = 0u8;
    pub const PRE_EMPTABLE: u8 = 1u8;
}
impl entropic::Entropic for Pre_emptionVulnerability {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Pre_emptionVulnerability(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Presence(pub u8);
impl Presence {
    pub const OPTIONAL: u8 = 0u8;
    pub const CONDITIONAL: u8 = 1u8;
    pub const MANDATORY: u8 = 2u8;
}
impl entropic::Entropic for Presence {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Presence(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PriorityLevel(pub u8);
impl entropic::Entropic for PriorityLevel {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PriorityLevel(source.get_uniform_range(0..=15)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=15 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PrivacyIndicator(pub u8);
impl PrivacyIndicator {
    pub const IMMEDIATE_MDT: u8 = 0u8;
    pub const LOGGED_MDT: u8 = 1u8;
}
impl entropic::Entropic for PrivacyIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PrivacyIndicator(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PrivateIE_ID {
    #[asn(key = 0, extended = false)]
    Local(PrivateIE_ID_local),
    #[asn(key = 1, extended = false)]
    Global(PrivateIE_ID_global),
}
impl asn1_codecs::Asn1Choice for PrivateIE_ID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            PrivateIE_ID::Local(_) => 0u128.try_into().unwrap(),
            PrivateIE_ID::Global(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PrivateMessage {
    pub private_i_es: PrivateMessagePrivateIEs,
}
impl entropic::Entropic for PrivateMessage {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let private_i_es: PrivateMessagePrivateIEs = __entropic_internal_source.entropic()?;
        Ok(Self { private_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .private_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ProSeAuthorized {
    #[asn(optional_idx = 0)]
    pub pro_se_direct_discovery: Option<ProSeDirectDiscovery>,
    #[asn(optional_idx = 1)]
    pub pro_se_direct_communication: Option<ProSeDirectCommunication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ProSeAuthorizedIE_Extensions>,
}
impl entropic::Entropic for ProSeAuthorized {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let pro_se_direct_discovery: Option<ProSeDirectDiscovery> =
            __entropic_internal_source.entropic()?;
        let pro_se_direct_communication: Option<ProSeDirectCommunication> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ProSeAuthorizedIE_Extensions> = None;
        Ok(Self {
            pro_se_direct_discovery,
            pro_se_direct_communication,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .pro_se_direct_discovery
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pro_se_direct_communication
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectCommunication(pub u8);
impl ProSeDirectCommunication {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for ProSeDirectCommunication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProSeDirectCommunication(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectDiscovery(pub u8);
impl ProSeDirectDiscovery {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for ProSeDirectDiscovery {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProSeDirectDiscovery(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeUEtoNetworkRelaying(pub u8);
impl ProSeUEtoNetworkRelaying {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for ProSeUEtoNetworkRelaying {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProSeUEtoNetworkRelaying(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ProcedureCode(pub u8);
impl entropic::Entropic for ProcedureCode {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProcedureCode(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolExtensionID(pub u16);
impl entropic::Entropic for ProtocolExtensionID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProtocolExtensionID(source.get_uniform_range(0..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolIE_ID(pub u16);
impl entropic::Entropic for ProtocolIE_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ProtocolIE_ID(source.get_uniform_range(0..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct QCI(pub u8);
impl entropic::Entropic for QCI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(QCI(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RAC(pub Vec<u8>);
impl entropic::Entropic for RAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(RAC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct RAN_UE_NGAP_ID(pub u32);
impl entropic::Entropic for RAN_UE_NGAP_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RAN_UE_NGAP_ID(source.get_uniform_range(0..=4294967295)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4294967295 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RAT_Type(pub u8);
impl RAT_Type {
    pub const NBIOT: u8 = 0u8;
}
impl entropic::Entropic for RAT_Type {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RAT_Type(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RIMInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum RIMRoutingAddress {
    #[asn(key = 0, extended = false)]
    GERAN_Cell_ID(GERAN_Cell_ID),
    #[asn(key = 0, extended = true)]
    TargetRNC_ID(TargetRNC_ID),
    #[asn(key = 1, extended = true)]
    EHRPD_Sector_ID(RIMRoutingAddress_eHRPD_Sector_ID),
}
impl asn1_codecs::Asn1Choice for RIMRoutingAddress {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            RIMRoutingAddress::GERAN_Cell_ID(_) => 0u128.try_into().unwrap(),
            RIMRoutingAddress::TargetRNC_ID(_) => 0u128.try_into().unwrap(),
            RIMRoutingAddress::EHRPD_Sector_ID(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RIMTransfer {
    pub rim_information: RIMInformation,
    #[asn(optional_idx = 0)]
    pub rim_routing_address: Option<RIMRoutingAddress>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RIMTransferIE_Extensions>,
}
impl entropic::Entropic for RIMTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let rim_information: RIMInformation = __entropic_internal_source.entropic()?;
        let rim_routing_address: Option<RIMRoutingAddress> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RIMTransferIE_Extensions> = None;
        Ok(Self {
            rim_information,
            rim_routing_address,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .rim_information
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .rim_routing_address
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RLFReportInformation {
    pub ue_rlf_report_container: UE_RLF_Report_Container,
    #[asn(optional_idx = 0)]
    pub ue_rlf_report_container_for_extended_bands:
        Option<UE_RLF_Report_Container_for_extended_bands>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RLFReportInformationIE_Extensions>,
}
impl entropic::Entropic for RLFReportInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ue_rlf_report_container: UE_RLF_Report_Container =
            __entropic_internal_source.entropic()?;
        let ue_rlf_report_container_for_extended_bands: Option<
            UE_RLF_Report_Container_for_extended_bands,
        > = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RLFReportInformationIE_Extensions> = None;
        Ok(Self {
            ue_rlf_report_container,
            ue_rlf_report_container_for_extended_bands,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_rlf_report_container
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ue_rlf_report_container_for_extended_bands
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RNC_ID(pub u16);
impl entropic::Entropic for RNC_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RNC_ID(source.get_uniform_range(0..=4095)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRC_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct RRC_Establishment_Cause(pub u8);
impl RRC_Establishment_Cause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
}
impl entropic::Entropic for RRC_Establishment_Cause {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RRC_Establishment_Cause(source.get_uniform_range(0..=4)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct Range(pub u8);
impl Range {
    pub const M50: u8 = 0u8;
    pub const M80: u8 = 1u8;
    pub const M180: u8 = 2u8;
    pub const M200: u8 = 3u8;
    pub const M350: u8 = 4u8;
    pub const M400: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const M700: u8 = 7u8;
    pub const M1000: u8 = 8u8;
}
impl entropic::Entropic for Range {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Range(source.get_uniform_range(0..=8)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=8 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ReceiveStatusOfULPDCPSDUsExtended(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ReceiveStatusOfULPDCPSDUsExtended {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16384, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ReceiveStatusOfULPDCPSDUsExtended(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(16384, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "131072"
)]
pub struct ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for ReceiveStatusOfULPDCPSDUsPDCP_SNlength18 {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(131072, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(131072, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "4096",
    sz_ub = "4096"
)]
pub struct ReceiveStatusofULPDCPSDUs(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ReceiveStatusofULPDCPSDUs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(4096, 16383);
        let total_bitlen = source.get_bounded_len(4096..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ReceiveStatusofULPDCPSDUs(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 4096);
        let capped_max = std::cmp::min(4096, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4096..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RecommendedCellItem {
    pub eutran_cgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<RecommendedCellItemTimeStayedInCell>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RecommendedCellItemIE_Extensions>,
}
impl entropic::Entropic for RecommendedCellItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let eutran_cgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let time_stayed_in_cell: Option<RecommendedCellItemTimeStayedInCell> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RecommendedCellItemIE_Extensions> = None;
        Ok(Self {
            eutran_cgi,
            time_stayed_in_cell,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .eutran_cgi
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .time_stayed_in_cell
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedCellList(pub Vec<RecommendedCellList_Entry>);
impl entropic::Entropic for RecommendedCellList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellList_Entry::from_finite_entropy(source)?);
        }
        Ok(RecommendedCellList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedCellsForPaging {
    pub recommended_cell_list: RecommendedCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedCellsForPagingIE_Extensions>,
}
impl entropic::Entropic for RecommendedCellsForPaging {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let recommended_cell_list: RecommendedCellList = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RecommendedCellsForPagingIE_Extensions> = None;
        Ok(Self {
            recommended_cell_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .recommended_cell_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedENBItem {
    pub mme_paging_target: MMEPagingTarget,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedENBItemIE_Extensions>,
}
impl entropic::Entropic for RecommendedENBItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mme_paging_target: MMEPagingTarget = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RecommendedENBItemIE_Extensions> = None;
        Ok(Self {
            mme_paging_target,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .mme_paging_target
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedENBList(pub Vec<RecommendedENBList_Entry>);
impl entropic::Entropic for RecommendedENBList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedENBList_Entry::from_finite_entropy(source)?);
        }
        Ok(RecommendedENBList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedENBsForPaging {
    pub recommended_enb_list: RecommendedENBList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedENBsForPagingIE_Extensions>,
}
impl entropic::Entropic for RecommendedENBsForPaging {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let recommended_enb_list: RecommendedENBList = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RecommendedENBsForPagingIE_Extensions> = None;
        Ok(Self {
            recommended_enb_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .recommended_enb_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct RelativeMMECapacity(pub u8);
impl entropic::Entropic for RelativeMMECapacity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RelativeMMECapacity(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RelayNode_Indicator(pub u8);
impl RelayNode_Indicator {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for RelayNode_Indicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RelayNode_Indicator(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RepetitionPeriod(pub u16);
impl entropic::Entropic for RepetitionPeriod {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RepetitionPeriod(source.get_uniform_range(0..=4095)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportAmountMDT(pub u8);
impl ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const RINFINITY: u8 = 7u8;
}
impl entropic::Entropic for ReportAmountMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ReportAmountMDT(source.get_uniform_range(0..=7)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReportArea(pub u8);
impl ReportArea {
    pub const ECGI: u8 = 0u8;
}
impl entropic::Entropic for ReportArea {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ReportArea(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "12")]
pub struct ReportIntervalMDT(pub u8);
impl ReportIntervalMDT {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
}
impl entropic::Entropic for ReportIntervalMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ReportIntervalMDT(source.get_uniform_range(0..=12)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=12 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct ReportingCellList(pub Vec<ReportingCellList_Item>);
impl entropic::Entropic for ReportingCellList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(128, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ReportingCellList_Item::from_finite_entropy(source)?);
        }
        Ok(ReportingCellList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(128, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ReportingCellList_Item {
    pub cell_id: IRAT_Cell_ID,
}
impl entropic::Entropic for ReportingCellList_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let cell_id: IRAT_Cell_ID = __entropic_internal_source.entropic()?;
        Ok(Self { cell_id })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.cell_id.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RequestType {
    pub event_type: EventType,
    pub report_area: ReportArea,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RequestTypeIE_Extensions>,
}
impl entropic::Entropic for RequestType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let event_type: EventType = __entropic_internal_source.entropic()?;
        let report_area: ReportArea = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<RequestTypeIE_Extensions> = None;
        Ok(Self {
            event_type,
            report_area,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .event_type
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .report_area
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RequestTypeAdditionalInfo(pub u8);
impl RequestTypeAdditionalInfo {
    pub const INCLUDE_PS_CELL: u8 = 0u8;
}
impl entropic::Entropic for RequestTypeAdditionalInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RequestTypeAdditionalInfo(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct RequestedCellList(pub Vec<IRAT_Cell_ID>);
impl entropic::Entropic for RequestedCellList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(128, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(IRAT_Cell_ID::from_finite_entropy(source)?);
        }
        Ok(RequestedCellList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(128, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RerouteNASRequest {
    pub protocol_i_es: RerouteNASRequestProtocolIEs,
}
impl entropic::Entropic for RerouteNASRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: RerouteNASRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Reset {
    pub protocol_i_es: ResetProtocolIEs,
}
impl entropic::Entropic for Reset {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ResetProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResetAcknowledge {
    pub protocol_i_es: ResetAcknowledgeProtocolIEs,
}
impl entropic::Entropic for ResetAcknowledge {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: ResetAcknowledgeProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ResetAll(pub u8);
impl ResetAll {
    pub const RESET_ALL: u8 = 0u8;
}
impl entropic::Entropic for ResetAll {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ResetAll(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ResetType {
    #[asn(key = 0, extended = false)]
    S1_Interface(ResetAll),
    #[asn(key = 1, extended = false)]
    PartOfS1_Interface(UE_associatedLogicalS1_ConnectionListRes),
}
impl asn1_codecs::Asn1Choice for ResetType {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            ResetType::S1_Interface(_) => 0u128.try_into().unwrap(),
            ResetType::PartOfS1_Interface(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEInformation {
    pub protocol_i_es: RetrieveUEInformationProtocolIEs,
}
impl entropic::Entropic for RetrieveUEInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: RetrieveUEInformationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct Routing_ID(pub u8);
impl entropic::Entropic for Routing_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Routing_ID(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct S_TMSI {
    pub mmec: MME_Code,
    pub m_tmsi: M_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<S_TMSIIE_Extensions>,
}
impl entropic::Entropic for S_TMSI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mmec: MME_Code = __entropic_internal_source.entropic()?;
        let m_tmsi: M_TMSI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<S_TMSIIE_Extensions> = None;
        Ok(Self {
            mmec,
            m_tmsi,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.mmec.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.m_tmsi.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum S1AP_PDU {
    #[asn(key = 0, extended = false)]
    InitiatingMessage(InitiatingMessage),
    #[asn(key = 1, extended = false)]
    SuccessfulOutcome(SuccessfulOutcome),
    #[asn(key = 2, extended = false)]
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}
impl asn1_codecs::Asn1Choice for S1AP_PDU {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            S1AP_PDU::InitiatingMessage(_) => 0u128.try_into().unwrap(),
            S1AP_PDU::SuccessfulOutcome(_) => 1u128.try_into().unwrap(),
            S1AP_PDU::UnsuccessfulOutcome(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupFailure {
    pub protocol_i_es: S1SetupFailureProtocolIEs,
}
impl entropic::Entropic for S1SetupFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: S1SetupFailureProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupRequest {
    pub protocol_i_es: S1SetupRequestProtocolIEs,
}
impl entropic::Entropic for S1SetupRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: S1SetupRequestProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupResponse {
    pub protocol_i_es: S1SetupResponseProtocolIEs,
}
impl entropic::Entropic for S1SetupResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: S1SetupResponseProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SONConfigurationTransfer {
    pub targete_nb_id: TargeteNB_ID,
    pub sourcee_nb_id: SourceeNB_ID,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SONConfigurationTransferIE_Extensions>,
}
impl entropic::Entropic for SONConfigurationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let targete_nb_id: TargeteNB_ID = __entropic_internal_source.entropic()?;
        let sourcee_nb_id: SourceeNB_ID = __entropic_internal_source.entropic()?;
        let son_information: SONInformation = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SONConfigurationTransferIE_Extensions> = None;
        Ok(Self {
            targete_nb_id,
            sourcee_nb_id,
            son_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .targete_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .sourcee_nb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .son_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum SONInformation {
    #[asn(key = 0, extended = false)]
    SONInformationRequest(SONInformationRequest),
    #[asn(key = 1, extended = false)]
    SONInformationReply(SONInformationReply),
    #[asn(key = 0, extended = true)]
    SONInformation_Extension(SONInformation_Extension),
}
impl asn1_codecs::Asn1Choice for SONInformation {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONInformation::SONInformationRequest(_) => 0u128.try_into().unwrap(),
            SONInformation::SONInformationReply(_) => 1u128.try_into().unwrap(),
            SONInformation::SONInformation_Extension(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformation_Extension {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SONInformation_ExtensionValue,
}
impl entropic::Entropic for SONInformation_Extension {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: SONInformation_ExtensionValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONInformationReply {
    #[asn(optional_idx = 0)]
    pub x2tnl_configuration_info: Option<X2TNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONInformationReplyIE_Extensions>,
}
impl entropic::Entropic for SONInformationReply {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let x2tnl_configuration_info: Option<X2TNLConfigurationInfo> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SONInformationReplyIE_Extensions> = None;
        Ok(Self {
            x2tnl_configuration_info,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .x2tnl_configuration_info
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONInformationReport {
    #[asn(key = 0, extended = false)]
    RLFReportInformation(RLFReportInformation),
}
impl asn1_codecs::Asn1Choice for SONInformationReport {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONInformationReport::RLFReportInformation(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONInformationRequest(pub u8);
impl SONInformationRequest {
    pub const X2_TNL_CONFIGURATION_INFO: u8 = 0u8;
}
impl entropic::Entropic for SONInformationRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SONInformationRequest(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONtransferApplicationIdentity(pub u8);
impl SONtransferApplicationIdentity {
    pub const CELL_LOAD_REPORTING: u8 = 0u8;
}
impl entropic::Entropic for SONtransferApplicationIdentity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SONtransferApplicationIdentity(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferCause {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(CellLoadReportingCause),
    #[asn(key = 0, extended = true)]
    MultiCellLoadReporting(CellLoadReportingCause),
    #[asn(key = 1, extended = true)]
    EventTriggeredCellLoadReporting(CellLoadReportingCause),
    #[asn(key = 2, extended = true)]
    HOReporting(HOReportingCause),
    #[asn(key = 3, extended = true)]
    EutranCellActivation(CellActivationCause),
    #[asn(key = 4, extended = true)]
    EnergySavingsIndication(CellStateIndicationCause),
    #[asn(key = 5, extended = true)]
    FailureEventReporting(FailureEventReportingCause),
}
impl asn1_codecs::Asn1Choice for SONtransferCause {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONtransferCause::CellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferCause::MultiCellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferCause::EventTriggeredCellLoadReporting(_) => 1u128.try_into().unwrap(),
            SONtransferCause::HOReporting(_) => 2u128.try_into().unwrap(),
            SONtransferCause::EutranCellActivation(_) => 3u128.try_into().unwrap(),
            SONtransferCause::EnergySavingsIndication(_) => 4u128.try_into().unwrap(),
            SONtransferCause::FailureEventReporting(_) => 5u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferRequestContainer {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(SONtransferRequestContainer_cellLoadReporting),
    #[asn(key = 0, extended = true)]
    MultiCellLoadReporting(MultiCellLoadReportingRequest),
    #[asn(key = 1, extended = true)]
    EventTriggeredCellLoadReporting(EventTriggeredCellLoadReportingRequest),
    #[asn(key = 2, extended = true)]
    HOReporting(HOReport),
    #[asn(key = 3, extended = true)]
    EutranCellActivation(CellActivationRequest),
    #[asn(key = 4, extended = true)]
    EnergySavingsIndication(CellStateIndication),
    #[asn(key = 5, extended = true)]
    FailureEventReporting(FailureEventReport),
}
impl asn1_codecs::Asn1Choice for SONtransferRequestContainer {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONtransferRequestContainer::CellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferRequestContainer::MultiCellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferRequestContainer::EventTriggeredCellLoadReporting(_) => {
                1u128.try_into().unwrap()
            }
            SONtransferRequestContainer::HOReporting(_) => 2u128.try_into().unwrap(),
            SONtransferRequestContainer::EutranCellActivation(_) => 3u128.try_into().unwrap(),
            SONtransferRequestContainer::EnergySavingsIndication(_) => 4u128.try_into().unwrap(),
            SONtransferRequestContainer::FailureEventReporting(_) => 5u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferResponseContainer {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(CellLoadReportingResponse),
    #[asn(key = 0, extended = true)]
    MultiCellLoadReporting(MultiCellLoadReportingResponse),
    #[asn(key = 1, extended = true)]
    EventTriggeredCellLoadReporting(EventTriggeredCellLoadReportingResponse),
    #[asn(key = 2, extended = true)]
    HOReporting(SONtransferResponseContainer_hOReporting),
    #[asn(key = 3, extended = true)]
    EutranCellActivation(CellActivationResponse),
    #[asn(key = 4, extended = true)]
    EnergySavingsIndication(SONtransferResponseContainer_energySavingsIndication),
    #[asn(key = 5, extended = true)]
    FailureEventReporting(SONtransferResponseContainer_failureEventReporting),
}
impl asn1_codecs::Asn1Choice for SONtransferResponseContainer {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SONtransferResponseContainer::CellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferResponseContainer::MultiCellLoadReporting(_) => 0u128.try_into().unwrap(),
            SONtransferResponseContainer::EventTriggeredCellLoadReporting(_) => {
                1u128.try_into().unwrap()
            }
            SONtransferResponseContainer::HOReporting(_) => 2u128.try_into().unwrap(),
            SONtransferResponseContainer::EutranCellActivation(_) => 3u128.try_into().unwrap(),
            SONtransferResponseContainer::EnergySavingsIndication(_) => 4u128.try_into().unwrap(),
            SONtransferResponseContainer::FailureEventReporting(_) => 5u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SRVCCHOIndication(pub u8);
impl SRVCCHOIndication {
    pub const P_SAND_CS: u8 = 0u8;
    pub const C_SONLY: u8 = 1u8;
}
impl entropic::Entropic for SRVCCHOIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SRVCCHOIndication(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SRVCCOperationNotPossible(pub u8);
impl SRVCCOperationNotPossible {
    pub const NOT_POSSIBLE: u8 = 0u8;
}
impl entropic::Entropic for SRVCCOperationNotPossible {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SRVCCOperationNotPossible(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SRVCCOperationPossible(pub u8);
impl SRVCCOperationPossible {
    pub const POSSIBLE: u8 = 0u8;
}
impl entropic::Entropic for SRVCCOperationPossible {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SRVCCOperationPossible(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ScheduledCommunicationTime {
    #[asn(optional_idx = 0)]
    pub dayof_week: Option<ScheduledCommunicationTimeDayofWeek>,
    #[asn(optional_idx = 1)]
    pub timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart>,
    #[asn(optional_idx = 2)]
    pub timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions>,
}
impl entropic::Entropic for ScheduledCommunicationTime {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let dayof_week: Option<ScheduledCommunicationTimeDayofWeek> =
            __entropic_internal_source.entropic()?;
        let timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart> =
            __entropic_internal_source.entropic()?;
        let timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions> = None;
        Ok(Self {
            dayof_week,
            timeof_day_start,
            timeof_day_end,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .dayof_week
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .timeof_day_start
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .timeof_day_end
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecondaryRATDataUsageReport {
    pub protocol_i_es: SecondaryRATDataUsageReportProtocolIEs,
}
impl entropic::Entropic for SecondaryRATDataUsageReport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: SecondaryRATDataUsageReportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecondaryRATDataUsageReportItem {
    pub e_rab_id: E_RAB_ID,
    pub secondary_rat_type: SecondaryRATType,
    pub e_rab_usage_report_list: E_RABUsageReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecondaryRATDataUsageReportItemIE_Extensions>,
}
impl entropic::Entropic for SecondaryRATDataUsageReportItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_rab_id: E_RAB_ID = __entropic_internal_source.entropic()?;
        let secondary_rat_type: SecondaryRATType = __entropic_internal_source.entropic()?;
        let e_rab_usage_report_list: E_RABUsageReportList =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SecondaryRATDataUsageReportItemIE_Extensions> = None;
        Ok(Self {
            e_rab_id,
            secondary_rat_type,
            e_rab_usage_report_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.e_rab_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .secondary_rat_type
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_usage_report_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SecondaryRATDataUsageReportList(pub Vec<SecondaryRATDataUsageReportList_Entry>);
impl entropic::Entropic for SecondaryRATDataUsageReportList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecondaryRATDataUsageReportList_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SecondaryRATDataUsageReportList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SecondaryRATDataUsageRequest(pub u8);
impl SecondaryRATDataUsageRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for SecondaryRATDataUsageRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SecondaryRATDataUsageRequest(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SecondaryRATType(pub u8);
impl SecondaryRATType {
    pub const N_R: u8 = 0u8;
}
impl entropic::Entropic for SecondaryRATType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SecondaryRATType(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityContext {
    pub next_hop_chaining_count: SecurityContextNextHopChainingCount,
    pub next_hop_parameter: SecurityKey,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityContextIE_Extensions>,
}
impl entropic::Entropic for SecurityContext {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let next_hop_chaining_count: SecurityContextNextHopChainingCount =
            __entropic_internal_source.entropic()?;
        let next_hop_parameter: SecurityKey = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SecurityContextIE_Extensions> = None;
        Ok(Self {
            next_hop_chaining_count,
            next_hop_parameter,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .next_hop_chaining_count
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .next_hop_parameter
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SecurityKey(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for SecurityKey {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(256, 16383);
        let total_bitlen = source.get_bounded_len(256..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(SecurityKey(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 256);
        let capped_max = std::cmp::min(256, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(256..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SerialNumber(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for SerialNumber {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(SerialNumber(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "32")]
pub struct ServedDCNs(pub Vec<ServedDCNsItem>);
impl entropic::Entropic for ServedDCNs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedDCNsItem::from_finite_entropy(source)?);
        }
        Ok(ServedDCNs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedDCNsItem {
    pub dcn_id: DCN_ID,
    pub relative_dcn_capacity: RelativeMMECapacity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedDCNsItemIE_Extensions>,
}
impl entropic::Entropic for ServedDCNsItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let dcn_id: DCN_ID = __entropic_internal_source.entropic()?;
        let relative_dcn_capacity: RelativeMMECapacity = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ServedDCNsItemIE_Extensions> = None;
        Ok(Self {
            dcn_id,
            relative_dcn_capacity,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.dcn_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .relative_dcn_capacity
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct ServedGUMMEIs(pub Vec<ServedGUMMEIsItem>);
impl entropic::Entropic for ServedGUMMEIs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedGUMMEIsItem::from_finite_entropy(source)?);
        }
        Ok(ServedGUMMEIs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedGUMMEIsItem {
    pub served_plm_ns: ServedPLMNs,
    pub served_group_i_ds: ServedGroupIDs,
    pub served_mme_cs: ServedMMECs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedGUMMEIsItemIE_Extensions>,
}
impl entropic::Entropic for ServedGUMMEIsItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let served_plm_ns: ServedPLMNs = __entropic_internal_source.entropic()?;
        let served_group_i_ds: ServedGroupIDs = __entropic_internal_source.entropic()?;
        let served_mme_cs: ServedMMECs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<ServedGUMMEIsItemIE_Extensions> = None;
        Ok(Self {
            served_plm_ns,
            served_group_i_ds,
            served_mme_cs,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .served_plm_ns
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .served_group_i_ds
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .served_mme_cs
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGroupIDs(pub Vec<MME_Group_ID>);
impl entropic::Entropic for ServedGroupIDs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MME_Group_ID::from_finite_entropy(source)?);
        }
        Ok(ServedGroupIDs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedMMECs(pub Vec<MME_Code>);
impl entropic::Entropic for ServedMMECs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MME_Code::from_finite_entropy(source)?);
        }
        Ok(ServedMMECs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ServedPLMNs(pub Vec<PLMNidentity>);
impl entropic::Entropic for ServedPLMNs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(32, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNidentity::from_finite_entropy(source)?);
        }
        Ok(ServedPLMNs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(32, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ServiceType(pub u8);
impl ServiceType {
    pub const Q_MC_FOR_STREAMING_SERVICE: u8 = 0u8;
    pub const Q_MC_FOR_MTSI_SERVICE: u8 = 1u8;
}
impl entropic::Entropic for ServiceType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ServiceType(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Source_ToTarget_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SourceBSS_ToTargetBSS_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SourceNgRanNode_ID {
    pub global_ran_node_id: Global_RAN_NODE_ID,
    pub selected_tai: FiveGSTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceNgRanNode_IDIE_Extensions>,
}
impl entropic::Entropic for SourceNgRanNode_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_ran_node_id: Global_RAN_NODE_ID = __entropic_internal_source.entropic()?;
        let selected_tai: FiveGSTAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SourceNgRanNode_IDIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_ran_node_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SourceNgRanNode_ToTargetNgRanNode_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SourceNodeID {
    #[asn(key = 0, extended = false)]
    SourceNgRanNode_ID(SourceNgRanNode_ID),
    #[asn(key = 1, extended = false)]
    SourceNodeID_Extension(SourceNodeID_Extension),
}
impl asn1_codecs::Asn1Choice for SourceNodeID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            SourceNodeID::SourceNgRanNode_ID(_) => 0u128.try_into().unwrap(),
            SourceNodeID::SourceNodeID_Extension(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNodeID_Extension {}
impl entropic::Entropic for SourceNodeID_Extension {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SourceOfUEActivityBehaviourInformation(pub u8);
impl SourceOfUEActivityBehaviourInformation {
    pub const SUBSCRIPTION_INFORMATION: u8 = 0u8;
    pub const STATISTICS: u8 = 1u8;
}
impl entropic::Entropic for SourceOfUEActivityBehaviourInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SourceOfUEActivityBehaviourInformation(
            source.get_uniform_range(0..=1)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SourceRNC_ToTargetRNC_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SourceeNB_ID {
    pub global_enb_id: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceeNB_IDIE_Extensions>,
}
impl entropic::Entropic for SourceeNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_enb_id: Global_ENB_ID = __entropic_internal_source.entropic()?;
        let selected_tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SourceeNB_IDIE_Extensions> = None;
        Ok(Self {
            global_enb_id,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_enb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SourceeNB_ToTargeteNB_TransparentContainer {
    pub rrc_container: RRC_Container,
    #[asn(optional_idx = 0)]
    pub e_rab_information_list: Option<E_RABInformationList>,
    pub target_cell_id: EUTRAN_CGI,
    #[asn(optional_idx = 1)]
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRFP>,
    pub ue_history_information: UE_HistoryInformation,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for SourceeNB_ToTargeteNB_TransparentContainer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let rrc_container: RRC_Container = __entropic_internal_source.entropic()?;
        let e_rab_information_list: Option<E_RABInformationList> =
            __entropic_internal_source.entropic()?;
        let target_cell_id: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRFP> =
            __entropic_internal_source.entropic()?;
        let ue_history_information: UE_HistoryInformation =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            rrc_container,
            e_rab_information_list,
            target_cell_id,
            subscriber_profile_i_dfor_rfp,
            ue_history_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .rrc_container
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .e_rab_information_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .target_cell_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .subscriber_profile_i_dfor_rfp
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ue_history_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct StratumLevel(pub u8);
impl entropic::Entropic for StratumLevel {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(StratumLevel(source.get_uniform_range(0..=3)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct SubscriberProfileIDforRFP(pub u16);
impl entropic::Entropic for SubscriberProfileIDforRFP {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SubscriberProfileIDforRFP(
            source.get_uniform_range(1..=256)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=256 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct Subscription_Based_UE_DifferentiationInfo {
    #[asn(optional_idx = 0)]
    pub periodic_communication_indicator:
        Option<Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator>,
    #[asn(optional_idx = 1)]
    pub periodic_time: Option<Subscription_Based_UE_DifferentiationInfoPeriodicTime>,
    #[asn(optional_idx = 2)]
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    #[asn(optional_idx = 3)]
    pub stationary_indication:
        Option<Subscription_Based_UE_DifferentiationInfoStationaryIndication>,
    #[asn(optional_idx = 4)]
    pub traffic_profile: Option<Subscription_Based_UE_DifferentiationInfoTrafficProfile>,
    #[asn(optional_idx = 5)]
    pub battery_indication: Option<Subscription_Based_UE_DifferentiationInfoBatteryIndication>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<Subscription_Based_UE_DifferentiationInfoIE_Extensions>,
}
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let periodic_communication_indicator: Option<
            Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator,
        > = __entropic_internal_source.entropic()?;
        let periodic_time: Option<Subscription_Based_UE_DifferentiationInfoPeriodicTime> =
            __entropic_internal_source.entropic()?;
        let scheduled_communication_time: Option<ScheduledCommunicationTime> =
            __entropic_internal_source.entropic()?;
        let stationary_indication: Option<
            Subscription_Based_UE_DifferentiationInfoStationaryIndication,
        > = __entropic_internal_source.entropic()?;
        let traffic_profile: Option<Subscription_Based_UE_DifferentiationInfoTrafficProfile> =
            __entropic_internal_source.entropic()?;
        let battery_indication: Option<Subscription_Based_UE_DifferentiationInfoBatteryIndication> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<Subscription_Based_UE_DifferentiationInfoIE_Extensions> = None;
        Ok(Self {
            periodic_communication_indicator,
            periodic_time,
            scheduled_communication_time,
            stationary_indication,
            traffic_profile,
            battery_indication,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .periodic_communication_indicator
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .periodic_time
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .scheduled_communication_time
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .stationary_indication
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .traffic_profile
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .battery_indication
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: SuccessfulOutcomeValue,
}
impl entropic::Entropic for SuccessfulOutcome {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: SuccessfulOutcomeValue = __entropic_internal_source.entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedTAs(pub Vec<SupportedTAs_Item>);
impl entropic::Entropic for SupportedTAs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SupportedTAs_Item::from_finite_entropy(source)?);
        }
        Ok(SupportedTAs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SupportedTAs_Item {
    pub tac: TAC,
    pub broadcast_plm_ns: BPLMNs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SupportedTAs_ItemIE_Extensions>,
}
impl entropic::Entropic for SupportedTAs_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tac: TAC = __entropic_internal_source.entropic()?;
        let broadcast_plm_ns: BPLMNs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SupportedTAs_ItemIE_Extensions> = None;
        Ok(Self {
            tac,
            broadcast_plm_ns,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tac.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .broadcast_plm_ns
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SynchronisationInformation {
    #[asn(optional_idx = 0)]
    pub source_stratum_level: Option<StratumLevel>,
    #[asn(optional_idx = 1)]
    pub listening_subframe_pattern: Option<ListeningSubframePattern>,
    #[asn(optional_idx = 2)]
    pub aggressore_cgi_list: Option<ECGI_List>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SynchronisationInformationIE_Extensions>,
}
impl entropic::Entropic for SynchronisationInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let source_stratum_level: Option<StratumLevel> = __entropic_internal_source.entropic()?;
        let listening_subframe_pattern: Option<ListeningSubframePattern> =
            __entropic_internal_source.entropic()?;
        let aggressore_cgi_list: Option<ECGI_List> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<SynchronisationInformationIE_Extensions> = None;
        Ok(Self {
            source_stratum_level,
            listening_subframe_pattern,
            aggressore_cgi_list,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .source_stratum_level
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .listening_subframe_pattern
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .aggressore_cgi_list
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SynchronisationStatus(pub u8);
impl SynchronisationStatus {
    pub const SYNCHRONOUS: u8 = 0u8;
    pub const ASYNCHRONOUS: u8 = 1u8;
}
impl entropic::Entropic for SynchronisationStatus {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SynchronisationStatus(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedMDT {
    pub ta_listfor_mdt: TAListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedMDTIE_Extensions>,
}
impl entropic::Entropic for TABasedMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ta_listfor_mdt: TAListforMDT = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TABasedMDTIE_Extensions> = None;
        Ok(Self {
            ta_listfor_mdt,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ta_listfor_mdt
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedQMC {
    pub ta_listfor_qmc: TAListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedQMCIE_Extensions>,
}
impl entropic::Entropic for TABasedQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ta_listfor_qmc: TAListforQMC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TABasedQMCIE_Extensions> = None;
        Ok(Self {
            ta_listfor_qmc,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ta_listfor_qmc
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct TAC(pub Vec<u8>);
impl entropic::Entropic for TAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(TAC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI {
    pub plm_nidentity: PLMNidentity,
    pub tac: TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIIE_Extensions>,
}
impl entropic::Entropic for TAI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let plm_nidentity: PLMNidentity = __entropic_internal_source.entropic()?;
        let tac: TAC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAIIE_Extensions> = None;
        Ok(Self {
            plm_nidentity,
            tac,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .plm_nidentity
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.tac.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Broadcast(pub Vec<TAI_Broadcast_Item>);
impl entropic::Entropic for TAI_Broadcast {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI_Broadcast_Item::from_finite_entropy(source)?);
        }
        Ok(TAI_Broadcast(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI_Broadcast_Item {
    pub tai: TAI,
    pub completed_cellin_tai: CompletedCellinTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAI_Broadcast_ItemIE_Extensions>,
}
impl entropic::Entropic for TAI_Broadcast_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tai: TAI = __entropic_internal_source.entropic()?;
        let completed_cellin_tai: CompletedCellinTAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAI_Broadcast_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            completed_cellin_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .completed_cellin_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Cancelled(pub Vec<TAI_Cancelled_Item>);
impl entropic::Entropic for TAI_Cancelled {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI_Cancelled_Item::from_finite_entropy(source)?);
        }
        Ok(TAI_Cancelled(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI_Cancelled_Item {
    pub tai: TAI,
    pub cancelled_cellin_tai: CancelledCellinTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAI_Cancelled_ItemIE_Extensions>,
}
impl entropic::Entropic for TAI_Cancelled_Item {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tai: TAI = __entropic_internal_source.entropic()?;
        let cancelled_cellin_tai: CancelledCellinTAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAI_Cancelled_ItemIE_Extensions> = None;
        Ok(Self {
            tai,
            cancelled_cellin_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .cancelled_cellin_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedMDT {
    pub tai_listfor_mdt: TAIListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedMDTIE_Extensions>,
}
impl entropic::Entropic for TAIBasedMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tai_listfor_mdt: TAIListforMDT = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAIBasedMDTIE_Extensions> = None;
        Ok(Self {
            tai_listfor_mdt,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .tai_listfor_mdt
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedQMC {
    pub tai_listfor_qmc: TAIListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedQMCIE_Extensions>,
}
impl entropic::Entropic for TAIBasedQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tai_listfor_qmc: TAIListforQMC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAIBasedQMCIE_Extensions> = None;
        Ok(Self {
            tai_listfor_qmc,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .tai_listfor_qmc
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIItemIE_Extensions>,
}
impl entropic::Entropic for TAIItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TAIItemIE_Extensions> = None;
        Ok(Self { tai, ie_extensions })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.tai.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct TAIList(pub Vec<TAIList_Entry>);
impl entropic::Entropic for TAIList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIList_Entry::from_finite_entropy(source)?);
        }
        Ok(TAIList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct TAIListForRestart(pub Vec<TAI>);
impl entropic::Entropic for TAIListForRestart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2048, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_finite_entropy(source)?);
        }
        Ok(TAIListForRestart(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(2048, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforMDT(pub Vec<TAI>);
impl entropic::Entropic for TAIListforMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_finite_entropy(source)?);
        }
        Ok(TAIListforMDT(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforQMC(pub Vec<TAI>);
impl entropic::Entropic for TAIListforQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_finite_entropy(source)?);
        }
        Ok(TAIListforQMC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListforWarning(pub Vec<TAI>);
impl entropic::Entropic for TAIListforWarning {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI::from_finite_entropy(source)?);
        }
        Ok(TAIListforWarning(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforMDT(pub Vec<TAC>);
impl entropic::Entropic for TAListforMDT {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_finite_entropy(source)?);
        }
        Ok(TAListforMDT(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforQMC(pub Vec<TAC>);
impl entropic::Entropic for TAListforQMC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(8, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAC::from_finite_entropy(source)?);
        }
        Ok(TAListforQMC(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(8, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TBCD_STRING(pub Vec<u8>);
impl entropic::Entropic for TBCD_STRING {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(3, 16383);
        let vec_len = source.get_bounded_len(3..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(TBCD_STRING(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(3, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(3..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct Target_ToSource_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetBSS_ToSourceBSS_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum TargetID {
    #[asn(key = 0, extended = false)]
    TargeteNB_ID(TargeteNB_ID),
    #[asn(key = 1, extended = false)]
    TargetRNC_ID(TargetRNC_ID),
    #[asn(key = 2, extended = false)]
    CGI(CGI),
    #[asn(key = 0, extended = true)]
    TargetgNgRanNode_ID(TargetNgRanNode_ID),
}
impl asn1_codecs::Asn1Choice for TargetID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            TargetID::TargeteNB_ID(_) => 0u128.try_into().unwrap(),
            TargetID::TargetRNC_ID(_) => 1u128.try_into().unwrap(),
            TargetID::CGI(_) => 2u128.try_into().unwrap(),
            TargetID::TargetgNgRanNode_ID(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNgRanNode_ID {
    pub global_ran_node_id: Global_RAN_NODE_ID,
    pub selected_tai: FiveGSTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetNgRanNode_IDIE_Extensions>,
}
impl entropic::Entropic for TargetNgRanNode_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_ran_node_id: Global_RAN_NODE_ID = __entropic_internal_source.entropic()?;
        let selected_tai: FiveGSTAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TargetNgRanNode_IDIE_Extensions> = None;
        Ok(Self {
            global_ran_node_id,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_ran_node_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetNgRanNode_ToSourceNgRanNode_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct TargetRNC_ID {
    pub lai: LAI,
    #[asn(optional_idx = 0)]
    pub rac: Option<RAC>,
    pub rnc_id: RNC_ID,
    #[asn(optional_idx = 1)]
    pub extended_rnc_id: Option<ExtendedRNC_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<TargetRNC_IDIE_Extensions>,
}
impl entropic::Entropic for TargetRNC_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let lai: LAI = __entropic_internal_source.entropic()?;
        let rac: Option<RAC> = __entropic_internal_source.entropic()?;
        let rnc_id: RNC_ID = __entropic_internal_source.entropic()?;
        let extended_rnc_id: Option<ExtendedRNC_ID> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TargetRNC_IDIE_Extensions> = None;
        Ok(Self {
            lai,
            rac,
            rnc_id,
            extended_rnc_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self.lai.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.rac.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.rnc_id.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extended_rnc_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetRNC_ToSourceRNC_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ID {
    pub global_enb_id: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_IDIE_Extensions>,
}
impl entropic::Entropic for TargeteNB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let global_enb_id: Global_ENB_ID = __entropic_internal_source.entropic()?;
        let selected_tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TargeteNB_IDIE_Extensions> = None;
        Ok(Self {
            global_enb_id,
            selected_tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .global_enb_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .selected_tai
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ToSourceeNB_TransparentContainer {
    pub rrc_container: RRC_Container,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions>,
}
impl entropic::Entropic for TargeteNB_ToSourceeNB_TransparentContainer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let rrc_container: RRC_Container = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions> = None;
        Ok(Self {
            rrc_container,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .rrc_container
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "97")]
pub struct Threshold_RSRP(pub u8);
impl entropic::Entropic for Threshold_RSRP {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Threshold_RSRP(source.get_uniform_range(0..=97)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=97 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "34")]
pub struct Threshold_RSRQ(pub u8);
impl entropic::Entropic for Threshold_RSRQ {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Threshold_RSRQ(source.get_uniform_range(0..=34)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=34 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct Time_UE_StayedInCell(pub u16);
impl entropic::Entropic for Time_UE_StayedInCell {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Time_UE_StayedInCell(source.get_uniform_range(0..=4095)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "40950")]
pub struct Time_UE_StayedInCell_EnhancedGranularity(pub u16);
impl entropic::Entropic for Time_UE_StayedInCell_EnhancedGranularity {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Time_UE_StayedInCell_EnhancedGranularity(
            source.get_uniform_range(0..=40950)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=40950 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct TimeSinceSecondaryNodeRelease(pub Vec<u8>);
impl entropic::Entropic for TimeSinceSecondaryNodeRelease {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(TimeSinceSecondaryNodeRelease(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TimeSynchronisationInfo {
    pub stratum_level: StratumLevel,
    pub synchronisation_status: SynchronisationStatus,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TimeSynchronisationInfoIE_Extensions>,
}
impl entropic::Entropic for TimeSynchronisationInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let stratum_level: StratumLevel = __entropic_internal_source.entropic()?;
        let synchronisation_status: SynchronisationStatus =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TimeSynchronisationInfoIE_Extensions> = None;
        Ok(Self {
            stratum_level,
            synchronisation_status,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .stratum_level
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .synchronisation_status
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TimeToWait(pub u8);
impl TimeToWait {
    pub const V1S: u8 = 0u8;
    pub const V2S: u8 = 1u8;
    pub const V5S: u8 = 2u8;
    pub const V10S: u8 = 3u8;
    pub const V20S: u8 = 4u8;
    pub const V60S: u8 = 5u8;
}
impl entropic::Entropic for TimeToWait {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(TimeToWait(source.get_uniform_range(0..=5)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TooEarlyInterRATHOReportReportFromEUTRAN {
    pub uerlf_report_container: TooEarlyInterRATHOReportReportFromEUTRANUERLFReportContainer,
    #[asn(optional_idx = 0)]
    pub mobility_information: Option<MobilityInformation>,
}
impl entropic::Entropic for TooEarlyInterRATHOReportReportFromEUTRAN {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let uerlf_report_container: TooEarlyInterRATHOReportReportFromEUTRANUERLFReportContainer =
            __entropic_internal_source.entropic()?;
        let mobility_information: Option<MobilityInformation> =
            __entropic_internal_source.entropic()?;
        Ok(Self {
            uerlf_report_container,
            mobility_information,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .uerlf_report_container
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .mobility_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TraceActivation {
    pub e_utran_trace_id: E_UTRAN_Trace_ID,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TraceActivationIE_Extensions>,
}
impl entropic::Entropic for TraceActivation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let e_utran_trace_id: E_UTRAN_Trace_ID = __entropic_internal_source.entropic()?;
        let interfaces_to_trace: InterfacesToTrace = __entropic_internal_source.entropic()?;
        let trace_depth: TraceDepth = __entropic_internal_source.entropic()?;
        let trace_collection_entity_ip_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TraceActivationIE_Extensions> = None;
        Ok(Self {
            e_utran_trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .e_utran_trace_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .interfaces_to_trace
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .trace_depth
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .trace_collection_entity_ip_address
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TraceDepth(pub u8);
impl TraceDepth {
    pub const MINIMUM: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const MAXIMUM: u8 = 2u8;
    pub const MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 3u8;
    pub const MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 4u8;
    pub const MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 5u8;
}
impl entropic::Entropic for TraceDepth {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(TraceDepth(source.get_uniform_range(0..=5)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=5 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceFailureIndication {
    pub protocol_i_es: TraceFailureIndicationProtocolIEs,
}
impl entropic::Entropic for TraceFailureIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: TraceFailureIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceStart {
    pub protocol_i_es: TraceStartProtocolIEs,
}
impl entropic::Entropic for TraceStart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: TraceStartProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "99")]
pub struct TrafficLoadReductionIndication(pub u8);
impl entropic::Entropic for TrafficLoadReductionIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(TrafficLoadReductionIndication(
            source.get_uniform_range(1..=99)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=99 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TransportInformation {
    pub transport_layer_address: TransportLayerAddress,
    pub ul_gtp_teid: GTP_TEID,
}
impl entropic::Entropic for TransportInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let ul_gtp_teid: GTP_TEID = __entropic_internal_source.entropic()?;
        Ok(Self {
            transport_layer_address,
            ul_gtp_teid,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_gtp_teid
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TransportLayerAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for TransportLayerAddress {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(160, 16383);
        let total_bitlen = source.get_bounded_len(1..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(TransportLayerAddress(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 1);
        let capped_max = std::cmp::min(160, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct TriggeringMessage(pub u8);
impl TriggeringMessage {
    pub const INITIATING_MESSAGE: u8 = 0u8;
    pub const SUCCESSFUL_OUTCOME: u8 = 1u8;
    pub const UNSUCCESSFULL_OUTCOME: u8 = 2u8;
}
impl entropic::Entropic for TriggeringMessage {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(TriggeringMessage(source.get_uniform_range(0..=2)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TunnelInformation {
    pub transport_layer_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub udp_port_number: Option<Port_Number>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TunnelInformationIE_Extensions>,
}
impl entropic::Entropic for TunnelInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let transport_layer_address: TransportLayerAddress =
            __entropic_internal_source.entropic()?;
        let udp_port_number: Option<Port_Number> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<TunnelInformationIE_Extensions> = None;
        Ok(Self {
            transport_layer_address,
            udp_port_number,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .transport_layer_address
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .udp_port_number
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct TypeOfError(pub u8);
impl TypeOfError {
    pub const NOT_UNDERSTOOD: u8 = 0u8;
    pub const MISSING: u8 = 1u8;
}
impl entropic::Entropic for TypeOfError {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(TypeOfError(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct UE_Application_Layer_Measurement_Capability(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl entropic::Entropic for UE_Application_Layer_Measurement_Capability {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(8, 16383);
        let total_bitlen = source.get_bounded_len(8..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(UE_Application_Layer_Measurement_Capability(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 8);
        let capped_max = std::cmp::min(8, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(8..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UE_HistoryInformation(pub Vec<LastVisitedCell_Item>);
impl entropic::Entropic for UE_HistoryInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LastVisitedCell_Item::from_finite_entropy(source)?);
        }
        Ok(UE_HistoryInformation(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(16, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_HistoryInformationFromTheUE(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container_for_extended_bands(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UE_RetentionInformation(pub u8);
impl UE_RetentionInformation {
    pub const UES_RETAINED: u8 = 0u8;
}
impl entropic::Entropic for UE_RetentionInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(UE_RetentionInformation(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_S1AP_ID_pair {
    pub mme_ue_s1ap_id: MME_UE_S1AP_ID,
    pub enb_ue_s1ap_id: ENB_UE_S1AP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_S1AP_ID_pairIE_Extensions>,
}
impl entropic::Entropic for UE_S1AP_ID_pair {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mme_ue_s1ap_id: MME_UE_S1AP_ID = __entropic_internal_source.entropic()?;
        let enb_ue_s1ap_id: ENB_UE_S1AP_ID = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UE_S1AP_ID_pairIE_Extensions> = None;
        Ok(Self {
            mme_ue_s1ap_id,
            enb_ue_s1ap_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .mme_ue_s1ap_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .enb_ue_s1ap_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum UE_S1AP_IDs {
    #[asn(key = 0, extended = false)]
    UE_S1AP_ID_pair(UE_S1AP_ID_pair),
    #[asn(key = 1, extended = false)]
    MME_UE_S1AP_ID(MME_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UE_S1AP_IDs {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UE_S1AP_IDs::UE_S1AP_ID_pair(_) => 0u128.try_into().unwrap(),
            UE_S1AP_IDs::MME_UE_S1AP_ID(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct UE_Usage_Type(pub u8);
impl entropic::Entropic for UE_Usage_Type {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(UE_Usage_Type(source.get_uniform_range(0..=255)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UE_associatedLogicalS1_ConnectionItem {
    #[asn(optional_idx = 0)]
    pub mme_ue_s1ap_id: Option<MME_UE_S1AP_ID>,
    #[asn(optional_idx = 1)]
    pub enb_ue_s1ap_id: Option<ENB_UE_S1AP_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UE_associatedLogicalS1_ConnectionItemIE_Extensions>,
}
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionItem {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mme_ue_s1ap_id: Option<MME_UE_S1AP_ID> = __entropic_internal_source.entropic()?;
        let enb_ue_s1ap_id: Option<ENB_UE_S1AP_ID> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UE_associatedLogicalS1_ConnectionItemIE_Extensions> = None;
        Ok(Self {
            mme_ue_s1ap_id,
            enb_ue_s1ap_id,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .mme_ue_s1ap_id
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .enb_ue_s1ap_id
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UE_associatedLogicalS1_ConnectionListRes(
    pub Vec<UE_associatedLogicalS1_ConnectionListRes_Entry>,
);
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionListRes {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_associatedLogicalS1_ConnectionListRes_Entry::from_finite_entropy(source)?);
        }
        Ok(UE_associatedLogicalS1_ConnectionListRes(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UE_associatedLogicalS1_ConnectionListResAck(
    pub Vec<UE_associatedLogicalS1_ConnectionListResAck_Entry>,
);
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionListResAck {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(256, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_associatedLogicalS1_ConnectionListResAck_Entry::from_finite_entropy(source)?);
        }
        Ok(UE_associatedLogicalS1_ConnectionListResAck(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(256, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAggregateMaximumBitrate {
    pub u_eaggregate_maximum_bit_rate_dl: BitRate,
    pub u_eaggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAggregateMaximumBitrateIE_Extensions>,
}
impl entropic::Entropic for UEAggregateMaximumBitrate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let u_eaggregate_maximum_bit_rate_dl: BitRate = __entropic_internal_source.entropic()?;
        let u_eaggregate_maximum_bit_rate_ul: BitRate = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UEAggregateMaximumBitrateIE_Extensions> = None;
        Ok(Self {
            u_eaggregate_maximum_bit_rate_dl,
            u_eaggregate_maximum_bit_rate_ul,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .u_eaggregate_maximum_bit_rate_dl
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .u_eaggregate_maximum_bit_rate_ul
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAppLayerMeasConfig {
    pub container_for_app_layer_meas_config: UEAppLayerMeasConfigContainerForAppLayerMeasConfig,
    pub area_scope_of_qmc: AreaScopeOfQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAppLayerMeasConfigIE_Extensions>,
}
impl entropic::Entropic for UEAppLayerMeasConfig {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let container_for_app_layer_meas_config : UEAppLayerMeasConfigContainerForAppLayerMeasConfig = __entropic_internal_source . entropic () ? ;
        let area_scope_of_qmc: AreaScopeOfQMC = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UEAppLayerMeasConfigIE_Extensions> = None;
        Ok(Self {
            container_for_app_layer_meas_config,
            area_scope_of_qmc,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .container_for_app_layer_meas_config
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .area_scope_of_qmc
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UECapabilityInfoIndication {
    pub protocol_i_es: UECapabilityInfoIndicationProtocolIEs,
}
impl entropic::Entropic for UECapabilityInfoIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UECapabilityInfoIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UECapabilityInfoRequest(pub u8);
impl UECapabilityInfoRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl entropic::Entropic for UECapabilityInfoRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(UECapabilityInfoRequest(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationConfirm {
    pub protocol_i_es: UEContextModificationConfirmProtocolIEs,
}
impl entropic::Entropic for UEContextModificationConfirm {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextModificationConfirmProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationFailure {
    pub protocol_i_es: UEContextModificationFailureProtocolIEs,
}
impl entropic::Entropic for UEContextModificationFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextModificationFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationIndication {
    pub protocol_i_es: UEContextModificationIndicationProtocolIEs,
}
impl entropic::Entropic for UEContextModificationIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextModificationIndicationProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationRequest {
    pub protocol_i_es: UEContextModificationRequestProtocolIEs,
}
impl entropic::Entropic for UEContextModificationRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextModificationRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationResponse {
    pub protocol_i_es: UEContextModificationResponseProtocolIEs,
}
impl entropic::Entropic for UEContextModificationResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextModificationResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseCommand {
    pub protocol_i_es: UEContextReleaseCommandProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseCommand {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextReleaseCommandProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseComplete {
    pub protocol_i_es: UEContextReleaseCompleteProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseComplete {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextReleaseCompleteProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseRequest {
    pub protocol_i_es: UEContextReleaseRequestProtocolIEs,
}
impl entropic::Entropic for UEContextReleaseRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextReleaseRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeFailure {
    pub protocol_i_es: UEContextResumeFailureProtocolIEs,
}
impl entropic::Entropic for UEContextResumeFailure {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextResumeFailureProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeRequest {
    pub protocol_i_es: UEContextResumeRequestProtocolIEs,
}
impl entropic::Entropic for UEContextResumeRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextResumeRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeResponse {
    pub protocol_i_es: UEContextResumeResponseProtocolIEs,
}
impl entropic::Entropic for UEContextResumeResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextResumeResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendRequest {
    pub protocol_i_es: UEContextSuspendRequestProtocolIEs,
}
impl entropic::Entropic for UEContextSuspendRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextSuspendRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendResponse {
    pub protocol_i_es: UEContextSuspendResponseProtocolIEs,
}
impl entropic::Entropic for UEContextSuspendResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEContextSuspendResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UEIdentityIndexValue {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(10, 16383);
        let total_bitlen = source.get_bounded_len(10..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(UEIdentityIndexValue(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 10);
        let capped_max = std::cmp::min(10, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(10..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEInformationTransfer {
    pub protocol_i_es: UEInformationTransferProtocolIEs,
}
impl entropic::Entropic for UEInformationTransfer {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UEInformationTransferProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum UEPagingID {
    #[asn(key = 0, extended = false)]
    S_TMSI(S_TMSI),
    #[asn(key = 1, extended = false)]
    IMSI(IMSI),
}
impl asn1_codecs::Asn1Choice for UEPagingID {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            UEPagingID::S_TMSI(_) => 0u128.try_into().unwrap(),
            UEPagingID::IMSI(_) => 1u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapability(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPaging(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingRequest {
    pub protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityIDMappingRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingResponse {
    pub protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityIDMappingResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityMatchRequest {
    pub protocol_i_es: UERadioCapabilityMatchRequestProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityMatchRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UERadioCapabilityMatchRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityMatchResponse {
    pub protocol_i_es: UERadioCapabilityMatchResponseProtocolIEs,
}
impl entropic::Entropic for UERadioCapabilityMatchResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UERadioCapabilityMatchResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESecurityCapabilities {
    pub encryption_algorithms: EncryptionAlgorithms,
    pub integrity_protection_algorithms: IntegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESecurityCapabilitiesIE_Extensions>,
}
impl entropic::Entropic for UESecurityCapabilities {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let encryption_algorithms: EncryptionAlgorithms = __entropic_internal_source.entropic()?;
        let integrity_protection_algorithms: IntegrityProtectionAlgorithms =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UESecurityCapabilitiesIE_Extensions> = None;
        Ok(Self {
            encryption_algorithms,
            integrity_protection_algorithms,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .encryption_algorithms
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .integrity_protection_algorithms
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESidelinkAggregateMaximumBitrateIE_Extensions>,
}
impl entropic::Entropic for UESidelinkAggregateMaximumBitrate {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ue_sidelink_aggregate_maximum_bit_rate: BitRate =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UESidelinkAggregateMaximumBitrateIE_Extensions> = None;
        Ok(Self {
            ue_sidelink_aggregate_maximum_bit_rate,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ue_sidelink_aggregate_maximum_bit_rate
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UEUserPlaneCIoTSupportIndicator(pub u8);
impl UEUserPlaneCIoTSupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
}
impl entropic::Entropic for UEUserPlaneCIoTSupportIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(UEUserPlaneCIoTSupportIndicator(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_CP_SecurityInformation {
    pub ul_nas_mac: UL_NAS_MAC,
    pub ul_nas_count: UL_NAS_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions>,
}
impl entropic::Entropic for UL_CP_SecurityInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let ul_nas_mac: UL_NAS_MAC = __entropic_internal_source.entropic()?;
        let ul_nas_count: UL_NAS_Count = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions> = None;
        Ok(Self {
            ul_nas_mac,
            ul_nas_count,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .ul_nas_mac
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .ul_nas_count
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct UL_NAS_Count(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UL_NAS_Count {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(5, 16383);
        let total_bitlen = source.get_bounded_len(5..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(UL_NAS_Count(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 5);
        let capped_max = std::cmp::min(5, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(5..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct UL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for UL_NAS_MAC {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(16, 16383);
        let total_bitlen = source.get_bounded_len(16..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(UL_NAS_MAC(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 16);
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "VisibleString")]
pub struct URI_Address(pub String);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UnlicensedSpectrumRestriction(pub u8);
impl UnlicensedSpectrumRestriction {
    pub const UNLICENSED_RESTRICTED: u8 = 0u8;
}
impl entropic::Entropic for UnlicensedSpectrumRestriction {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(UnlicensedSpectrumRestriction(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnsuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: UnsuccessfulOutcomeValue,
}
impl entropic::Entropic for UnsuccessfulOutcome {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UnsuccessfulOutcomeValue = __entropic_internal_source.entropic()?;
        let procedure_code: ProcedureCode = ProcedureCode(value.choice_key());
        Ok(Self {
            procedure_code,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNASTransport {
    pub protocol_i_es: UplinkNASTransportProtocolIEs,
}
impl entropic::Entropic for UplinkNASTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UplinkNASTransportProtocolIEs = __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNonUEAssociatedLPPaTransport {
    pub protocol_i_es: UplinkNonUEAssociatedLPPaTransportProtocolIEs,
}
impl entropic::Entropic for UplinkNonUEAssociatedLPPaTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UplinkNonUEAssociatedLPPaTransportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkS1cdma2000tunnelling {
    pub protocol_i_es: UplinkS1cdma2000tunnellingProtocolIEs,
}
impl entropic::Entropic for UplinkS1cdma2000tunnelling {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UplinkS1cdma2000tunnellingProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkUEAssociatedLPPaTransport {
    pub protocol_i_es: UplinkUEAssociatedLPPaTransportProtocolIEs,
}
impl entropic::Entropic for UplinkUEAssociatedLPPaTransport {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: UplinkUEAssociatedLPPaTransportProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserLocationInformation {
    pub eutran_cgi: EUTRAN_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserLocationInformationIE_Extensions>,
}
impl entropic::Entropic for UserLocationInformation {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let eutran_cgi: EUTRAN_CGI = __entropic_internal_source.entropic()?;
        let tai: TAI = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<UserLocationInformationIE_Extensions> = None;
        Ok(Self {
            eutran_cgi,
            tai,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .eutran_cgi
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.tai.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct V2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<V2XServicesAuthorizedIE_Extensions>,
}
impl entropic::Entropic for V2XServicesAuthorized {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let vehicle_ue: Option<VehicleUE> = __entropic_internal_source.entropic()?;
        let pedestrian_ue: Option<PedestrianUE> = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<V2XServicesAuthorizedIE_Extensions> = None;
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .vehicle_ue
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .pedestrian_ue
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VehicleUE(pub u8);
impl VehicleUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl entropic::Entropic for VehicleUE {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(VehicleUE(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VoiceSupportMatchIndicator(pub u8);
impl VoiceSupportMatchIndicator {
    pub const SUPPORTED: u8 = 0u8;
    pub const NOT_SUPPORTED: u8 = 1u8;
}
impl entropic::Entropic for VoiceSupportMatchIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(VoiceSupportMatchIndicator(source.get_uniform_range(0..=1)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasConfig(pub u8);
impl WLANMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasConfig {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(WLANMeasConfig(source.get_uniform_range(0..=0)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLANMeasConfigNameList(pub Vec<WLANName>);
impl entropic::Entropic for WLANMeasConfigNameList {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WLANName::from_finite_entropy(source)?);
        }
        Ok(WLANMeasConfigNameList(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(4, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLANMeasurementConfiguration {
    pub wlan_meas_config: WLANMeasConfig,
    #[asn(optional_idx = 0)]
    pub wlan_meas_config_name_list: Option<WLANMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi>,
    #[asn(optional_idx = 2)]
    pub wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions>,
}
impl entropic::Entropic for WLANMeasurementConfiguration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let wlan_meas_config: WLANMeasConfig = __entropic_internal_source.entropic()?;
        let wlan_meas_config_name_list: Option<WLANMeasConfigNameList> =
            __entropic_internal_source.entropic()?;
        let wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi> =
            __entropic_internal_source.entropic()?;
        let wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt> =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions> = None;
        Ok(Self {
            wlan_meas_config,
            wlan_meas_config_name_list,
            wlan_rssi,
            wlan_rtt,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .wlan_meas_config
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .wlan_meas_config_name_list
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.wlan_rssi.to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.wlan_rtt.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLANName(pub Vec<u8>);
impl entropic::Entropic for WLANName {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(WLANName(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WUS_Assistance_Information {
    pub paging_probability_information: PagingProbabilityInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WUS_Assistance_InformationIE_Extensions>,
}
impl entropic::Entropic for WUS_Assistance_Information {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let paging_probability_information: PagingProbabilityInformation =
            __entropic_internal_source.entropic()?;
        let ie_extensions: Option<WUS_Assistance_InformationIE_Extensions> = None;
        Ok(Self {
            paging_probability_information,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .paging_probability_information
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct WarningAreaCoordinates(pub Vec<u8>);
impl entropic::Entropic for WarningAreaCoordinates {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(WarningAreaCoordinates(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum WarningAreaList {
    #[asn(key = 0, extended = false)]
    CellIDList(ECGIList),
    #[asn(key = 1, extended = false)]
    TrackingAreaListforWarning(TAIListforWarning),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDList(EmergencyAreaIDList),
}
impl asn1_codecs::Asn1Choice for WarningAreaList {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            WarningAreaList::CellIDList(_) => 0u128.try_into().unwrap(),
            WarningAreaList::TrackingAreaListforWarning(_) => 1u128.try_into().unwrap(),
            WarningAreaList::EmergencyAreaIDList(_) => 2u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "9600"
)]
pub struct WarningMessageContents(pub Vec<u8>);
impl entropic::Entropic for WarningMessageContents {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(WarningMessageContents(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "50",
    sz_ub = "50"
)]
pub struct WarningSecurityInfo(pub Vec<u8>);
impl entropic::Entropic for WarningSecurityInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(50, 16383);
        let vec_len = source.get_bounded_len(50..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(WarningSecurityInfo(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(50, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(50..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct WarningType(pub Vec<u8>);
impl entropic::Entropic for WarningType {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(2, 16383);
        let vec_len = source.get_bounded_len(2..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(WarningType(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(2, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(2..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningRequest {
    pub protocol_i_es: WriteReplaceWarningRequestProtocolIEs,
}
impl entropic::Entropic for WriteReplaceWarningRequest {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: WriteReplaceWarningRequestProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningResponse {
    pub protocol_i_es: WriteReplaceWarningResponseProtocolIEs,
}
impl entropic::Entropic for WriteReplaceWarningResponse {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let protocol_i_es: WriteReplaceWarningResponseProtocolIEs =
            __entropic_internal_source.entropic()?;
        Ok(Self { protocol_i_es })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .protocol_i_es
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct X2TNLConfigurationInfo {
    pub enbx2_transport_layer_addresses: ENBX2TLAs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<X2TNLConfigurationInfoIE_Extensions>,
}
impl entropic::Entropic for X2TNLConfigurationInfo {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let enbx2_transport_layer_addresses: ENBX2TLAs = __entropic_internal_source.entropic()?;
        let ie_extensions: Option<X2TNLConfigurationInfoIE_Extensions> = None;
        Ok(Self {
            enbx2_transport_layer_addresses,
            ie_extensions,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .enbx2_transport_layer_addresses
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct ActivatedCellsList_ItemCell_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Additional_GUTIIE_Extensions_Entry {}
impl entropic::Entropic for Additional_GUTIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Additional_GUTIIE_Extensions(pub Vec<Additional_GUTIIE_Extensions_Entry>);
impl entropic::Entropic for Additional_GUTIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Additional_GUTIIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(Additional_GUTIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllocationAndRetentionPriorityIE_Extensions_Entry {}
impl entropic::Entropic for AllocationAndRetentionPriorityIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllocationAndRetentionPriorityIE_Extensions(
    pub Vec<AllocationAndRetentionPriorityIE_Extensions_Entry>,
);
impl entropic::Entropic for AllocationAndRetentionPriorityIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AllocationAndRetentionPriorityIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(AllocationAndRetentionPriorityIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct AreaScopeOfMDT_pLMNWide;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForCECapableUEsIE_Extensions_Entry {}
impl entropic::Entropic for AssistanceDataForCECapableUEsIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForCECapableUEsIE_Extensions(
    pub Vec<AssistanceDataForCECapableUEsIE_Extensions_Entry>,
);
impl entropic::Entropic for AssistanceDataForCECapableUEsIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AssistanceDataForCECapableUEsIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(AssistanceDataForCECapableUEsIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForPagingIE_Extensions_Entry {}
impl entropic::Entropic for AssistanceDataForPagingIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForPagingIE_Extensions(
    pub Vec<AssistanceDataForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for AssistanceDataForPagingIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(AssistanceDataForPagingIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(AssistanceDataForPagingIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions_Entry {}
impl entropic::Entropic for AssistanceDataForRecommendedCellsIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions(
    pub Vec<AssistanceDataForRecommendedCellsIE_Extensions_Entry>,
);
impl entropic::Entropic for AssistanceDataForRecommendedCellsIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                AssistanceDataForRecommendedCellsIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(AssistanceDataForRecommendedCellsIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry {}
impl entropic::Entropic for Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions(
    pub Vec<Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToEarlyStatusTransferList_EntryValue {
    #[asn(key = 322)]
    Id_Bearers_SubjectToEarlyStatusTransfer_Item(Bearers_SubjectToEarlyStatusTransfer_Item),
}
impl asn1_codecs::Asn1Choice for Bearers_SubjectToEarlyStatusTransferList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Bearers_SubjectToEarlyStatusTransfer_Item(_) => 322u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToEarlyStatusTransferList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: Bearers_SubjectToEarlyStatusTransferList_EntryValue,
}
impl entropic::Entropic for Bearers_SubjectToEarlyStatusTransferList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: Bearers_SubjectToEarlyStatusTransferList_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 180)]
    Id_DLCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 218)]
    Id_DLCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
    #[asn(key = 181)]
    Id_ReceiveStatusOfULPDCPSDUsExtended(ReceiveStatusOfULPDCPSDUsExtended),
    #[asn(key = 219)]
    Id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18),
    #[asn(key = 179)]
    Id_ULCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 217)]
    Id_ULCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
}
impl asn1_codecs::Asn1Choice
    for Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DLCOUNTValueExtended(_) => 180u128.try_into().unwrap(),
            Self::Id_DLCOUNTValuePDCP_SNlength18(_) => 218u128.try_into().unwrap(),
            Self::Id_ReceiveStatusOfULPDCPSDUsExtended(_) => 181u128.try_into().unwrap(),
            Self::Id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(_) => 219u128.try_into().unwrap(),
            Self::Id_ULCOUNTValueExtended(_) => 179u128.try_into().unwrap(),
            Self::Id_ULCOUNTValuePDCP_SNlength18(_) => 217u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Bearers_SubjectToStatusTransfer_ItemIE_Extensions(
    pub Vec<Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for Bearers_SubjectToStatusTransfer_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(Bearers_SubjectToStatusTransfer_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToStatusTransferList_EntryValue {
    #[asn(key = 89)]
    Id_Bearers_SubjectToStatusTransfer_Item(Bearers_SubjectToStatusTransfer_Item),
}
impl asn1_codecs::Asn1Choice for Bearers_SubjectToStatusTransferList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Bearers_SubjectToStatusTransfer_Item(_) => 89u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToStatusTransferList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: Bearers_SubjectToStatusTransferList_EntryValue,
}
impl entropic::Entropic for Bearers_SubjectToStatusTransferList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: Bearers_SubjectToStatusTransferList_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasurementConfigurationBt_rssi(pub u8);
impl BluetoothMeasurementConfigurationBt_rssi {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for BluetoothMeasurementConfigurationBt_rssi {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(BluetoothMeasurementConfigurationBt_rssi(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for BluetoothMeasurementConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasurementConfigurationIE_Extensions(
    pub Vec<BluetoothMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for BluetoothMeasurementConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                BluetoothMeasurementConfigurationIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(BluetoothMeasurementConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CGIIE_Extensions_Entry {}
impl entropic::Entropic for CGIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CGIIE_Extensions(pub Vec<CGIIE_Extensions_Entry>);
impl entropic::Entropic for CGIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CGIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CGIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNTypeRestrictions_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CNTypeRestrictions_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNTypeRestrictions_ItemIE_Extensions(
    pub Vec<CNTypeRestrictions_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CNTypeRestrictions_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CNTypeRestrictions_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CNTypeRestrictions_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueExtendedIE_Extensions_Entry {}
impl entropic::Entropic for COUNTValueExtendedIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueExtendedIE_Extensions(pub Vec<COUNTValueExtendedIE_Extensions_Entry>);
impl entropic::Entropic for COUNTValueExtendedIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(COUNTValueExtendedIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(COUNTValueExtendedIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvalueIE_Extensions_Entry {}
impl entropic::Entropic for COUNTvalueIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvalueIE_Extensions(pub Vec<COUNTvalueIE_Extensions_Entry>);
impl entropic::Entropic for COUNTvalueIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(COUNTvalueIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(COUNTvalueIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions_Entry {}
impl entropic::Entropic for COUNTvaluePDCP_SNlength18IE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions(
    pub Vec<COUNTvaluePDCP_SNlength18IE_Extensions_Entry>,
);
impl entropic::Entropic for COUNTvaluePDCP_SNlength18IE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(COUNTvaluePDCP_SNlength18IE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(COUNTvaluePDCP_SNlength18IE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSG_IdList_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CSG_IdList_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSG_IdList_ItemIE_Extensions(pub Vec<CSG_IdList_ItemIE_Extensions_Entry>);
impl entropic::Entropic for CSG_IdList_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CSG_IdList_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(CSG_IdList_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSGMembershipInfoIE_Extensions_Entry {}
impl entropic::Entropic for CSGMembershipInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSGMembershipInfoIE_Extensions(pub Vec<CSGMembershipInfoIE_Extensions_Entry>);
impl entropic::Entropic for CSGMembershipInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CSGMembershipInfoIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(CSGMembershipInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellinEAI_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellinEAI_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinEAI_ItemIE_Extensions(
    pub Vec<CancelledCellinEAI_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellinEAI_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellinEAI_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CancelledCellinEAI_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellinTAI_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CancelledCellinTAI_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinTAI_ItemIE_Extensions(
    pub Vec<CancelledCellinTAI_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CancelledCellinTAI_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CancelledCellinTAI_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CancelledCellinTAI_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct CandidatePCIPCI(pub u16);
impl entropic::Entropic for CandidatePCIPCI {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CandidatePCIPCI(source.get_uniform_range(0..=503)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=503 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CandidatePCIEARFCN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cdma2000OneXSRVCCInfoIE_Extensions_Entry {}
impl entropic::Entropic for Cdma2000OneXSRVCCInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Cdma2000OneXSRVCCInfoIE_Extensions(pub Vec<Cdma2000OneXSRVCCInfoIE_Extensions_Entry>);
impl entropic::Entropic for Cdma2000OneXSRVCCInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Cdma2000OneXSRVCCInfoIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(Cdma2000OneXSRVCCInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "60")]
pub struct CellActivationRequestMinimumActivationTime(pub u8);
impl entropic::Entropic for CellActivationRequestMinimumActivationTime {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(CellActivationRequestMinimumActivationTime(
            source.get_uniform_range(1..=60)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=60 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDTIE_Extensions_Entry {}
impl entropic::Entropic for CellBasedMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDTIE_Extensions(pub Vec<CellBasedMDTIE_Extensions_Entry>);
impl entropic::Entropic for CellBasedMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellBasedMDTIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(CellBasedMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedQMCIE_Extensions_Entry {}
impl entropic::Entropic for CellBasedQMCIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedQMCIE_Extensions(pub Vec<CellBasedQMCIE_Extensions_Entry>);
impl entropic::Entropic for CellBasedQMCIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellBasedQMCIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(CellBasedQMCIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellID_Broadcast_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellID_Broadcast_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Broadcast_ItemIE_Extensions(pub Vec<CellID_Broadcast_ItemIE_Extensions_Entry>);
impl entropic::Entropic for CellID_Broadcast_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellID_Broadcast_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CellID_Broadcast_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellID_Cancelled_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CellID_Cancelled_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Cancelled_ItemIE_Extensions(pub Vec<CellID_Cancelled_ItemIE_Extensions_Entry>);
impl entropic::Entropic for CellID_Cancelled_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellID_Cancelled_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CellID_Cancelled_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry {}
impl entropic::Entropic for CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIdentifierAndCELevelForCECapableUEsIE_Extensions(
    pub Vec<CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry>,
);
impl entropic::Entropic for CellIdentifierAndCELevelForCECapableUEsIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(CellIdentifierAndCELevelForCECapableUEsIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellLoadReportingResponse_uTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellLoadReportingResponse_gERAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum CellTrafficTraceProtocolIEs_EntryValue {
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 166)]
    Id_PrivacyIndicator(PrivacyIndicator),
    #[asn(key = 131)]
    Id_TraceCollectionEntityIPAddress(TransportLayerAddress),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for CellTrafficTraceProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_UTRAN_Trace_ID(_) => 86u128.try_into().unwrap(),
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_PrivacyIndicator(_) => 166u128.try_into().unwrap(),
            Self::Id_TraceCollectionEntityIPAddress(_) => 131u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTrafficTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellTrafficTraceProtocolIEs_EntryValue,
}
impl entropic::Entropic for CellTrafficTraceProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: CellTrafficTraceProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellTrafficTraceProtocolIEs(pub Vec<CellTrafficTraceProtocolIEs_Entry>);
impl entropic::Entropic for CellTrafficTraceProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellTrafficTraceProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(CellTrafficTraceProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTypeIE_Extensions_Entry {}
impl entropic::Entropic for CellTypeIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellTypeIE_Extensions(pub Vec<CellTypeIE_Extensions_Entry>);
impl entropic::Entropic for CellTypeIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CellTypeIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CellTypeIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CellsToActivateList_ItemCell_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellinEAI_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellinEAI_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinEAI_ItemIE_Extensions(
    pub Vec<CompletedCellinEAI_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellinEAI_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellinEAI_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CompletedCellinEAI_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellinTAI_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CompletedCellinTAI_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinTAI_ItemIE_Extensions(
    pub Vec<CompletedCellinTAI_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CompletedCellinTAI_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CompletedCellinTAI_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CompletedCellinTAI_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectedengNBItemIE_Extensions_Entry {}
impl entropic::Entropic for ConnectedengNBItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ConnectedengNBItemIE_Extensions(pub Vec<ConnectedengNBItemIE_Extensions_Entry>);
impl entropic::Entropic for ConnectedengNBItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ConnectedengNBItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ConnectedengNBItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 253)]
    Id_DL_CP_SecurityInformation(DL_CP_SecurityInformation),
    #[asn(key = 280)]
    Id_EndIndication(EndIndication),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 252)]
    Id_UE_Level_QoS_Parameters(E_RABLevelQoSParameters),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_DL_CP_SecurityInformation(_) => 253u128.try_into().unwrap(),
            Self::Id_EndIndication(_) => 280u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_UE_Level_QoS_Parameters(_) => 252u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectionEstablishmentIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for ConnectionEstablishmentIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ConnectionEstablishmentIndicationProtocolIEs(
    pub Vec<ConnectionEstablishmentIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for ConnectionEstablishmentIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                ConnectionEstablishmentIndicationProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(ConnectionEstablishmentIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ContextatSourceIE_Extensions_Entry {}
impl entropic::Entropic for ContextatSourceIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ContextatSourceIE_Extensions(pub Vec<ContextatSourceIE_Extensions_Entry>);
impl entropic::Entropic for ContextatSourceIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ContextatSourceIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ContextatSourceIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnosticsIE_Extensions_Entry {}
impl entropic::Entropic for CriticalityDiagnosticsIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnosticsIE_Extensions(pub Vec<CriticalityDiagnosticsIE_Extensions_Entry>);
impl entropic::Entropic for CriticalityDiagnosticsIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnosticsIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CriticalityDiagnosticsIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {}
impl entropic::Entropic for CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions(
    pub Vec<CriticalityDiagnostics_IE_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for CriticalityDiagnostics_IE_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(CriticalityDiagnostics_IE_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(CriticalityDiagnostics_IE_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DAPSRequestInfoDAPSIndicator(pub u8);
impl DAPSRequestInfoDAPSIndicator {
    pub const D_APS_HO_REQUIRED: u8 = 0u8;
}
impl entropic::Entropic for DAPSRequestInfoDAPSIndicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DAPSRequestInfoDAPSIndicator(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSRequestInfoIE_Extensions_Entry {}
impl entropic::Entropic for DAPSRequestInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSRequestInfoIE_Extensions(pub Vec<DAPSRequestInfoIE_Extensions_Entry>);
impl entropic::Entropic for DAPSRequestInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSRequestInfoIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(DAPSRequestInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DAPSResponseInfoDapsresponseindicator(pub u8);
impl DAPSResponseInfoDapsresponseindicator {
    pub const D_APS_HO_ACCEPTED: u8 = 0u8;
    pub const D_APS_HO_NOT_ACCEPTED: u8 = 1u8;
}
impl entropic::Entropic for DAPSResponseInfoDapsresponseindicator {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(DAPSResponseInfoDapsresponseindicator(
            source.get_uniform_range(0..=1)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoIE_Extensions_Entry {}
impl entropic::Entropic for DAPSResponseInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoIE_Extensions(pub Vec<DAPSResponseInfoIE_Extensions_Entry>);
impl entropic::Entropic for DAPSResponseInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(DAPSResponseInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoItemIE_Extensions_Entry {}
impl entropic::Entropic for DAPSResponseInfoItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoItemIE_Extensions(pub Vec<DAPSResponseInfoItemIE_Extensions_Entry>);
impl entropic::Entropic for DAPSResponseInfoItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DAPSResponseInfoItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(DAPSResponseInfoItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DAPSResponseInfoList_EntryValue {
    #[asn(key = 319)]
    Id_DAPSResponseInfoItem(DAPSResponseInfoItem),
}
impl asn1_codecs::Asn1Choice for DAPSResponseInfoList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DAPSResponseInfoItem(_) => 319u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DAPSResponseInfoList_EntryValue,
}
impl entropic::Entropic for DAPSResponseInfoList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DAPSResponseInfoList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CP_SecurityInformationIE_Extensions_Entry {}
impl entropic::Entropic for DL_CP_SecurityInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DL_CP_SecurityInformationIE_Extensions(
    pub Vec<DL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for DL_CP_SecurityInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DL_CP_SecurityInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(DL_CP_SecurityInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DeactivateTraceProtocolIEs_EntryValue {
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for DeactivateTraceProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_UTRAN_Trace_ID(_) => 86u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeactivateTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DeactivateTraceProtocolIEs_EntryValue,
}
impl entropic::Entropic for DeactivateTraceProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DeactivateTraceProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DeactivateTraceProtocolIEs(pub Vec<DeactivateTraceProtocolIEs_Entry>);
impl entropic::Entropic for DeactivateTraceProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DeactivateTraceProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(DeactivateTraceProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 249)]
    Id_DLNASPDUDeliveryAckRequest(DLNASPDUDeliveryAckRequest),
    #[asn(key = 280)]
    Id_EndIndication(EndIndication),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 275)]
    Id_UECapabilityInfoRequest(UECapabilityInfoRequest),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for DownlinkNASTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_DLNASPDUDeliveryAckRequest(_) => 249u128.try_into().unwrap(),
            Self::Id_EndIndication(_) => 280u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_HandoverRestrictionList(_) => 41u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 26u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 124u128.try_into().unwrap(),
            Self::Id_SubscriberProfileIDforRFP(_) => 106u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_UECapabilityInfoRequest(_) => 275u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNASTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkNASTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DownlinkNASTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNASTransportProtocolIEs(pub Vec<DownlinkNASTransportProtocolIEs_Entry>);
impl entropic::Entropic for DownlinkNASTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DownlinkNASTransportProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(DownlinkNASTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
}
impl asn1_codecs::Asn1Choice for DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LPPa_PDU(_) => 147u128.try_into().unwrap(),
            Self::Id_Routing_ID(_) => 148u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNonUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl entropic::Entropic for DownlinkNonUEAssociatedLPPaTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(DownlinkNonUEAssociatedLPPaTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    #[asn(key = 12)]
    Id_E_RABSubjecttoDataForwardingList(E_RABSubjecttoDataForwardingList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 83)]
    Id_cdma2000HOStatus(Cdma2000HOStatus),
    #[asn(key = 70)]
    Id_cdma2000PDU(Cdma2000PDU),
    #[asn(key = 71)]
    Id_cdma2000RATType(Cdma2000RATType),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABSubjecttoDataForwardingList(_) => 12u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_cdma2000HOStatus(_) => 83u128.try_into().unwrap(),
            Self::Id_cdma2000PDU(_) => 70u128.try_into().unwrap(),
            Self::Id_cdma2000RATType(_) => 71u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkS1cdma2000tunnellingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkS1cdma2000tunnellingProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkS1cdma2000tunnellingProtocolIEs(
    pub Vec<DownlinkS1cdma2000tunnellingProtocolIEs_Entry>,
);
impl entropic::Entropic for DownlinkS1cdma2000tunnellingProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(DownlinkS1cdma2000tunnellingProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(DownlinkS1cdma2000tunnellingProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LPPa_PDU(_) => 147u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_Routing_ID(_) => 148u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl entropic::Entropic for DownlinkUEAssociatedLPPaTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(DownlinkUEAssociatedLPPaTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABAdmittedItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABAdmittedItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABAdmittedItemIE_Extensions(pub Vec<E_RABAdmittedItemIE_Extensions_Entry>);
impl entropic::Entropic for E_RABAdmittedItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABAdmittedItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABAdmittedItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABAdmittedList_EntryValue {
    #[asn(key = 20)]
    Id_E_RABAdmittedItem(E_RABAdmittedItem),
}
impl asn1_codecs::Asn1Choice for E_RABAdmittedList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABAdmittedItem(_) => 20u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABAdmittedList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABAdmittedList_EntryValue,
}
impl entropic::Entropic for E_RABAdmittedList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABAdmittedList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABDataForwardingItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABDataForwardingItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABDataForwardingItemIE_Extensions(
    pub Vec<E_RABDataForwardingItemIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABDataForwardingItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABDataForwardingItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABDataForwardingItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeItemResumeReqIE_Extensions_Entry {}
impl entropic::Entropic for E_RABFailedToResumeItemResumeReqIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToResumeItemResumeReqIE_Extensions(
    pub Vec<E_RABFailedToResumeItemResumeReqIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABFailedToResumeItemResumeReqIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                E_RABFailedToResumeItemResumeReqIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(E_RABFailedToResumeItemResumeReqIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeItemResumeResIE_Extensions_Entry {}
impl entropic::Entropic for E_RABFailedToResumeItemResumeResIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToResumeItemResumeResIE_Extensions(
    pub Vec<E_RABFailedToResumeItemResumeResIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABFailedToResumeItemResumeResIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                E_RABFailedToResumeItemResumeResIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(E_RABFailedToResumeItemResumeResIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABFailedToResumeListResumeReq_EntryValue {
    #[asn(key = 236)]
    Id_E_RABFailedToResumeItemResumeReq(E_RABFailedToResumeItemResumeReq),
}
impl asn1_codecs::Asn1Choice for E_RABFailedToResumeListResumeReq_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABFailedToResumeItemResumeReq(_) => 236u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeListResumeReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedToResumeListResumeReq_EntryValue,
}
impl entropic::Entropic for E_RABFailedToResumeListResumeReq_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABFailedToResumeListResumeReq_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABFailedToResumeListResumeRes_EntryValue {
    #[asn(key = 238)]
    Id_E_RABFailedToResumeItemResumeRes(E_RABFailedToResumeItemResumeRes),
}
impl asn1_codecs::Asn1Choice for E_RABFailedToResumeListResumeRes_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABFailedToResumeItemResumeRes(_) => 238u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeListResumeRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedToResumeListResumeRes_EntryValue,
}
impl entropic::Entropic for E_RABFailedToResumeListResumeRes_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABFailedToResumeListResumeRes_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry {}
impl entropic::Entropic for E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToSetupItemHOReqAckIE_Extensions(
    pub Vec<E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABFailedToSetupItemHOReqAckIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABFailedToSetupItemHOReqAckIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABFailedtoSetupListHOReqAck_EntryValue {
    #[asn(key = 21)]
    Id_E_RABFailedtoSetupItemHOReqAck(E_RABFailedToSetupItemHOReqAck),
}
impl asn1_codecs::Asn1Choice for E_RABFailedtoSetupListHOReqAck_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABFailedtoSetupItemHOReqAck(_) => 21u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedtoSetupListHOReqAck_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedtoSetupListHOReqAck_EntryValue,
}
impl entropic::Entropic for E_RABFailedtoSetupListHOReqAck_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABFailedtoSetupListHOReqAck_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABInformationList_EntryValue {
    #[asn(key = 78)]
    Id_E_RABInformationListItem(E_RABInformationListItem),
}
impl asn1_codecs::Asn1Choice for E_RABInformationList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABInformationListItem(_) => 78u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABInformationList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABInformationList_EntryValue,
}
impl entropic::Entropic for E_RABInformationList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABInformationList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABInformationListItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 317)]
    Id_DAPSRequestInfo(DAPSRequestInfo),
}
impl asn1_codecs::Asn1Choice for E_RABInformationListItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DAPSRequestInfo(_) => 317u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABInformationListItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABInformationListItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABInformationListItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABInformationListItemIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABInformationListItemIE_Extensions(
    pub Vec<E_RABInformationListItemIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABInformationListItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABInformationListItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABInformationListItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABItemIE_Extensions(pub Vec<E_RABItemIE_Extensions_Entry>);
impl entropic::Entropic for E_RABItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue {
    #[asn(key = 273)]
    Id_DownlinkPacketLossRate(Packet_LossRate),
    #[asn(key = 274)]
    Id_UplinkPacketLossRate(Packet_LossRate),
}
impl asn1_codecs::Asn1Choice for E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DownlinkPacketLossRate(_) => 273u128.try_into().unwrap(),
            Self::Id_UplinkPacketLossRate(_) => 274u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABLevelQoSParametersIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABLevelQoSParametersIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABLevelQoSParametersIE_Extensions(
    pub Vec<E_RABLevelQoSParametersIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABLevelQoSParametersIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABLevelQoSParametersIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABLevelQoSParametersIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABList_EntryValue {
    #[asn(key = 35)]
    Id_E_RABItem(E_RABItem),
}
impl asn1_codecs::Asn1Choice for E_RABList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABItem(_) => 35u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABList_EntryValue,
}
impl entropic::Entropic for E_RABList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 205)]
    Id_E_RABFailedToModifyListBearerModConf(E_RABList),
    #[asn(key = 203)]
    Id_E_RABModifyListBearerModConf(E_RABModifyListBearerModConf),
    #[asn(key = 210)]
    Id_E_RABToBeReleasedListBearerModConf(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABModificationConfirmProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToModifyListBearerModConf(_) => 205u128.try_into().unwrap(),
            Self::Id_E_RABModifyListBearerModConf(_) => 203u128.try_into().unwrap(),
            Self::Id_E_RABToBeReleasedListBearerModConf(_) => 210u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModificationConfirmProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABModificationConfirmProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModificationConfirmProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModificationConfirmProtocolIEs(pub Vec<E_RABModificationConfirmProtocolIEs_Entry>);
impl entropic::Entropic for E_RABModificationConfirmProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModificationConfirmProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABModificationConfirmProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModificationIndicationProtocolIEs_EntryValue {
    #[asn(key = 226)]
    Id_CSGMembershipInfo(CSGMembershipInfo),
    #[asn(key = 201)]
    Id_E_RABNotToBeModifiedListBearerModInd(E_RABNotToBeModifiedListBearerModInd),
    #[asn(key = 199)]
    Id_E_RABToBeModifiedListBearerModInd(E_RABToBeModifiedListBearerModInd),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABModificationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSGMembershipInfo(_) => 226u128.try_into().unwrap(),
            Self::Id_E_RABNotToBeModifiedListBearerModInd(_) => 201u128.try_into().unwrap(),
            Self::Id_E_RABToBeModifiedListBearerModInd(_) => 199u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_Tunnel_Information_for_BBF(_) => 176u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModificationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModificationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABModificationIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModificationIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModificationIndicationProtocolIEs(
    pub Vec<E_RABModificationIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for E_RABModificationIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModificationIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABModificationIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyItemBearerModConfIE_Extensions_Entry {}
impl entropic::Entropic for E_RABModifyItemBearerModConfIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABModifyItemBearerModConfIE_Extensions(
    pub Vec<E_RABModifyItemBearerModConfIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABModifyItemBearerModConfIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyItemBearerModConfIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABModifyItemBearerModConfIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyItemBearerModResIE_Extensions_Entry {}
impl entropic::Entropic for E_RABModifyItemBearerModResIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABModifyItemBearerModResIE_Extensions(
    pub Vec<E_RABModifyItemBearerModResIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABModifyItemBearerModResIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyItemBearerModResIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABModifyItemBearerModResIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModifyListBearerModConf_EntryValue {
    #[asn(key = 204)]
    Id_E_RABModifyItemBearerModConf(E_RABModifyItemBearerModConf),
}
impl asn1_codecs::Asn1Choice for E_RABModifyListBearerModConf_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABModifyItemBearerModConf(_) => 204u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyListBearerModConf_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyListBearerModConf_EntryValue,
}
impl entropic::Entropic for E_RABModifyListBearerModConf_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModifyListBearerModConf_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModifyListBearerModRes_EntryValue {
    #[asn(key = 37)]
    Id_E_RABModifyItemBearerModRes(E_RABModifyItemBearerModRes),
}
impl asn1_codecs::Asn1Choice for E_RABModifyListBearerModRes_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABModifyItemBearerModRes(_) => 37u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyListBearerModRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyListBearerModRes_EntryValue,
}
impl entropic::Entropic for E_RABModifyListBearerModRes_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModifyListBearerModRes_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModifyRequestProtocolIEs_EntryValue {
    #[asn(key = 30)]
    Id_E_RABToBeModifiedListBearerModReq(E_RABToBeModifiedListBearerModReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 268)]
    Id_SecondaryRATDataUsageRequest(SecondaryRATDataUsageRequest),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for E_RABModifyRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeModifiedListBearerModReq(_) => 30u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageRequest(_) => 268u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABModifyRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModifyRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModifyRequestProtocolIEs(pub Vec<E_RABModifyRequestProtocolIEs_Entry>);
impl entropic::Entropic for E_RABModifyRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABModifyRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABModifyResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 32)]
    Id_E_RABFailedToModifyList(E_RABList),
    #[asn(key = 31)]
    Id_E_RABModifyListBearerModRes(E_RABModifyListBearerModRes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABModifyResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToModifyList(_) => 32u128.try_into().unwrap(),
            Self::Id_E_RABModifyListBearerModRes(_) => 31u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABModifyResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABModifyResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModifyResponseProtocolIEs(pub Vec<E_RABModifyResponseProtocolIEs_Entry>);
impl entropic::Entropic for E_RABModifyResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABModifyResponseProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABModifyResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry {}
impl entropic::Entropic for E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABNotToBeModifiedItemBearerModIndIE_Extensions(
    pub Vec<E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABNotToBeModifiedItemBearerModIndIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(E_RABNotToBeModifiedItemBearerModIndIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABNotToBeModifiedListBearerModInd_EntryValue {
    #[asn(key = 202)]
    Id_E_RABNotToBeModifiedItemBearerModInd(E_RABNotToBeModifiedItemBearerModInd),
}
impl asn1_codecs::Asn1Choice for E_RABNotToBeModifiedListBearerModInd_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABNotToBeModifiedItemBearerModInd(_) => 202u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABNotToBeModifiedListBearerModInd_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABNotToBeModifiedListBearerModInd_EntryValue,
}
impl entropic::Entropic for E_RABNotToBeModifiedListBearerModInd_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABNotToBeModifiedListBearerModInd_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 33)]
    Id_E_RABToBeReleasedList(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for E_RABReleaseCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeReleasedList(_) => 33u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 26u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABReleaseCommandProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABReleaseCommandProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseCommandProtocolIEs(pub Vec<E_RABReleaseCommandProtocolIEs_Entry>);
impl entropic::Entropic for E_RABReleaseCommandProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABReleaseCommandProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABReleaseCommandProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseIndicationProtocolIEs_EntryValue {
    #[asn(key = 110)]
    Id_E_RABReleasedList(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABReleaseIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABReleasedList(_) => 110u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABReleaseIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABReleaseIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseIndicationProtocolIEs(pub Vec<E_RABReleaseIndicationProtocolIEs_Entry>);
impl entropic::Entropic for E_RABReleaseIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABReleaseIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABReleaseIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseItemBearerRelCompIE_Extensions_Entry {}
impl entropic::Entropic for E_RABReleaseItemBearerRelCompIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABReleaseItemBearerRelCompIE_Extensions(
    pub Vec<E_RABReleaseItemBearerRelCompIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABReleaseItemBearerRelCompIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABReleaseItemBearerRelCompIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABReleaseItemBearerRelCompIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseListBearerRelComp_EntryValue {
    #[asn(key = 15)]
    Id_E_RABReleaseItemBearerRelComp(E_RABReleaseItemBearerRelComp),
}
impl asn1_codecs::Asn1Choice for E_RABReleaseListBearerRelComp_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABReleaseItemBearerRelComp(_) => 15u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseListBearerRelComp_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseListBearerRelComp_EntryValue,
}
impl entropic::Entropic for E_RABReleaseListBearerRelComp_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABReleaseListBearerRelComp_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 34)]
    Id_E_RABFailedToReleaseList(E_RABList),
    #[asn(key = 69)]
    Id_E_RABReleaseListBearerRelComp(E_RABReleaseListBearerRelComp),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABReleaseResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToReleaseList(_) => 34u128.try_into().unwrap(),
            Self::Id_E_RABReleaseListBearerRelComp(_) => 69u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABReleaseResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABReleaseResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseResponseProtocolIEs(pub Vec<E_RABReleaseResponseProtocolIEs_Entry>);
impl entropic::Entropic for E_RABReleaseResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABReleaseResponseProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABReleaseResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupItemBearerSUResIE_Extensions_Entry {}
impl entropic::Entropic for E_RABSetupItemBearerSUResIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABSetupItemBearerSUResIE_Extensions(
    pub Vec<E_RABSetupItemBearerSUResIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABSetupItemBearerSUResIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupItemBearerSUResIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABSetupItemBearerSUResIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupItemCtxtSUResIE_Extensions_Entry {}
impl entropic::Entropic for E_RABSetupItemCtxtSUResIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABSetupItemCtxtSUResIE_Extensions(
    pub Vec<E_RABSetupItemCtxtSUResIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABSetupItemCtxtSUResIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupItemCtxtSUResIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABSetupItemCtxtSUResIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABSetupListBearerSURes_EntryValue {
    #[asn(key = 39)]
    Id_E_RABSetupItemBearerSURes(E_RABSetupItemBearerSURes),
}
impl asn1_codecs::Asn1Choice for E_RABSetupListBearerSURes_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABSetupItemBearerSURes(_) => 39u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupListBearerSURes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupListBearerSURes_EntryValue,
}
impl entropic::Entropic for E_RABSetupListBearerSURes_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABSetupListBearerSURes_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABSetupListCtxtSURes_EntryValue {
    #[asn(key = 50)]
    Id_E_RABSetupItemCtxtSURes(E_RABSetupItemCtxtSURes),
}
impl asn1_codecs::Asn1Choice for E_RABSetupListCtxtSURes_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABSetupItemCtxtSURes(_) => 50u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupListCtxtSURes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupListCtxtSURes_EntryValue,
}
impl entropic::Entropic for E_RABSetupListCtxtSURes_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABSetupListCtxtSURes_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 16)]
    Id_E_RABToBeSetupListBearerSUReq(E_RABToBeSetupListBearerSUReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for E_RABSetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSetupListBearerSUReq(_) => 16u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABSetupRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABSetupRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABSetupRequestProtocolIEs(pub Vec<E_RABSetupRequestProtocolIEs_Entry>);
impl entropic::Entropic for E_RABSetupRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABSetupRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 29)]
    Id_E_RABFailedToSetupListBearerSURes(E_RABList),
    #[asn(key = 28)]
    Id_E_RABSetupListBearerSURes(E_RABSetupListBearerSURes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for E_RABSetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToSetupListBearerSURes(_) => 29u128.try_into().unwrap(),
            Self::Id_E_RABSetupListBearerSURes(_) => 28u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for E_RABSetupResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABSetupResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABSetupResponseProtocolIEs(pub Vec<E_RABSetupResponseProtocolIEs_Entry>);
impl entropic::Entropic for E_RABSetupResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABSetupResponseProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(E_RABSetupResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABSubjecttoDataForwardingList_EntryValue {
    #[asn(key = 14)]
    Id_E_RABDataForwardingItem(E_RABDataForwardingItem),
}
impl asn1_codecs::Asn1Choice for E_RABSubjecttoDataForwardingList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABDataForwardingItem(_) => 14u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSubjecttoDataForwardingList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSubjecttoDataForwardingList_EntryValue,
}
impl entropic::Entropic for E_RABSubjecttoDataForwardingList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABSubjecttoDataForwardingList_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry {}
impl entropic::Entropic for E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeModifiedItemBearerModIndIE_Extensions(
    pub Vec<E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeModifiedItemBearerModIndIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(E_RABToBeModifiedItemBearerModIndIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 185)]
    Id_TransportInformation(TransportInformation),
}
impl asn1_codecs::Asn1Choice
    for E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_TransportInformation(_) => 185u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeModifiedItemBearerModReqIE_Extensions(
    pub Vec<E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeModifiedItemBearerModReqIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(E_RABToBeModifiedItemBearerModReqIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedListBearerModInd_EntryValue {
    #[asn(key = 200)]
    Id_E_RABToBeModifiedItemBearerModInd(E_RABToBeModifiedItemBearerModInd),
}
impl asn1_codecs::Asn1Choice for E_RABToBeModifiedListBearerModInd_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeModifiedItemBearerModInd(_) => 200u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedListBearerModInd_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeModifiedListBearerModInd_EntryValue,
}
impl entropic::Entropic for E_RABToBeModifiedListBearerModInd_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeModifiedListBearerModInd_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedListBearerModReq_EntryValue {
    #[asn(key = 36)]
    Id_E_RABToBeModifiedItemBearerModReq(E_RABToBeModifiedItemBearerModReq),
}
impl asn1_codecs::Asn1Choice for E_RABToBeModifiedListBearerModReq_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeModifiedItemBearerModReq(_) => 36u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedListBearerModReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeModifiedListBearerModReq_EntryValue,
}
impl entropic::Entropic for E_RABToBeModifiedListBearerModReq_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeModifiedListBearerModReq_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 156)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 183)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BearerType(_) => 233u128.try_into().unwrap(),
            Self::Id_Correlation_ID(_) => 156u128.try_into().unwrap(),
            Self::Id_Ethernet_Type(_) => 305u128.try_into().unwrap(),
            Self::Id_SIPTO_Correlation_ID(_) => 183u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemBearerSUReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeSetupItemBearerSUReqIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSetupItemBearerSUReqIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 156)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 183)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BearerType(_) => 233u128.try_into().unwrap(),
            Self::Id_Correlation_ID(_) => 156u128.try_into().unwrap(),
            Self::Id_Ethernet_Type(_) => 305u128.try_into().unwrap(),
            Self::Id_SIPTO_Correlation_ID(_) => 183u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemCtxtSUReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeSetupItemCtxtSUReqIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSetupItemCtxtSUReqIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 143)]
    Id_Data_Forwarding_Not_Possible(Data_Forwarding_Not_Possible),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BearerType(_) => 233u128.try_into().unwrap(),
            Self::Id_Data_Forwarding_Not_Possible(_) => 143u128.try_into().unwrap(),
            Self::Id_Ethernet_Type(_) => 305u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemHOReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for E_RABToBeSetupItemHOReqIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemHOReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemHOReqIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeSetupItemHOReqIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSetupItemHOReqIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSetupItemHOReqIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListBearerSUReq_EntryValue {
    #[asn(key = 17)]
    Id_E_RABToBeSetupItemBearerSUReq(E_RABToBeSetupItemBearerSUReq),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupListBearerSUReq_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSetupItemBearerSUReq(_) => 17u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListBearerSUReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListBearerSUReq_EntryValue,
}
impl entropic::Entropic for E_RABToBeSetupListBearerSUReq_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeSetupListBearerSUReq_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListCtxtSUReq_EntryValue {
    #[asn(key = 52)]
    Id_E_RABToBeSetupItemCtxtSUReq(E_RABToBeSetupItemCtxtSUReq),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupListCtxtSUReq_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSetupItemCtxtSUReq(_) => 52u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListCtxtSUReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListCtxtSUReq_EntryValue,
}
impl entropic::Entropic for E_RABToBeSetupListCtxtSUReq_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeSetupListCtxtSUReq_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListHOReq_EntryValue {
    #[asn(key = 27)]
    Id_E_RABToBeSetupItemHOReq(E_RABToBeSetupItemHOReq),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSetupListHOReq_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSetupItemHOReq(_) => 27u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListHOReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListHOReq_EntryValue,
}
impl entropic::Entropic for E_RABToBeSetupListHOReq_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeSetupListHOReq_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedDLItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABToBeSwitchedDLItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSwitchedDLItemIE_Extensions(
    pub Vec<E_RABToBeSwitchedDLItemIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeSwitchedDLItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSwitchedDLItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSwitchedDLItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSwitchedDLList_EntryValue {
    #[asn(key = 23)]
    Id_E_RABToBeSwitchedDLItem(E_RABToBeSwitchedDLItem),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSwitchedDLList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSwitchedDLItem(_) => 23u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedDLList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSwitchedDLList_EntryValue,
}
impl entropic::Entropic for E_RABToBeSwitchedDLList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeSwitchedDLList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedULItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABToBeSwitchedULItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSwitchedULItemIE_Extensions(
    pub Vec<E_RABToBeSwitchedULItemIE_Extensions_Entry>,
);
impl entropic::Entropic for E_RABToBeSwitchedULItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABToBeSwitchedULItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABToBeSwitchedULItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSwitchedULList_EntryValue {
    #[asn(key = 94)]
    Id_E_RABToBeSwitchedULItem(E_RABToBeSwitchedULItem),
}
impl asn1_codecs::Asn1Choice for E_RABToBeSwitchedULList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABToBeSwitchedULItem(_) => 94u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedULList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSwitchedULList_EntryValue,
}
impl entropic::Entropic for E_RABToBeSwitchedULList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABToBeSwitchedULList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReportItemStartTimestamp(pub Vec<u8>);
impl entropic::Entropic for E_RABUsageReportItemStartTimestamp {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(E_RABUsageReportItemStartTimestamp(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReportItemEndTimestamp(pub Vec<u8>);
impl entropic::Entropic for E_RABUsageReportItemEndTimestamp {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(4, 16383);
        let vec_len = source.get_bounded_len(4..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(E_RABUsageReportItemEndTimestamp(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(4, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(4..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReportItemUsageCountUL(pub u64);
impl entropic::Entropic for E_RABUsageReportItemUsageCountUL {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(E_RABUsageReportItemUsageCountUL(
            source.get_uniform_range(0..=18446744073709551615)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=18446744073709551615 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReportItemUsageCountDL(pub u64);
impl entropic::Entropic for E_RABUsageReportItemUsageCountDL {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(E_RABUsageReportItemUsageCountDL(
            source.get_uniform_range(0..=18446744073709551615)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=18446744073709551615 as u64, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReportItemIE_Extensions_Entry {}
impl entropic::Entropic for E_RABUsageReportItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABUsageReportItemIE_Extensions(pub Vec<E_RABUsageReportItemIE_Extensions_Entry>);
impl entropic::Entropic for E_RABUsageReportItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(E_RABUsageReportItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(E_RABUsageReportItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum E_RABUsageReportList_EntryValue {
    #[asn(key = 267)]
    Id_E_RABUsageReportItem(E_RABUsageReportItem),
}
impl asn1_codecs::Asn1Choice for E_RABUsageReportList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABUsageReportItem(_) => 267u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABUsageReportList_EntryValue,
}
impl entropic::Entropic for E_RABUsageReportList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: E_RABUsageReportList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONConfigurationTransferIE_Extensions_Entry {}
impl entropic::Entropic for EN_DCSONConfigurationTransferIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONConfigurationTransferIE_Extensions(
    pub Vec<EN_DCSONConfigurationTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for EN_DCSONConfigurationTransferIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EN_DCSONConfigurationTransferIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EN_DCSONConfigurationTransferIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONeNBIdentificationIE_Extensions_Entry {}
impl entropic::Entropic for EN_DCSONeNBIdentificationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONeNBIdentificationIE_Extensions(
    pub Vec<EN_DCSONeNBIdentificationIE_Extensions_Entry>,
);
impl entropic::Entropic for EN_DCSONeNBIdentificationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EN_DCSONeNBIdentificationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EN_DCSONeNBIdentificationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONengNBIdentificationIE_Extensions_Entry {}
impl entropic::Entropic for EN_DCSONengNBIdentificationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONengNBIdentificationIE_Extensions(
    pub Vec<EN_DCSONengNBIdentificationIE_Extensions_Entry>,
);
impl entropic::Entropic for EN_DCSONengNBIdentificationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EN_DCSONengNBIdentificationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EN_DCSONengNBIdentificationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCTransferTypeReplyIE_Extensions_Entry {}
impl entropic::Entropic for EN_DCTransferTypeReplyIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCTransferTypeReplyIE_Extensions(pub Vec<EN_DCTransferTypeReplyIE_Extensions_Entry>);
impl entropic::Entropic for EN_DCTransferTypeReplyIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EN_DCTransferTypeReplyIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EN_DCTransferTypeReplyIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCTransferTypeRequestIE_Extensions_Entry {}
impl entropic::Entropic for EN_DCTransferTypeRequestIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCTransferTypeRequestIE_Extensions(
    pub Vec<EN_DCTransferTypeRequestIE_Extensions_Entry>,
);
impl entropic::Entropic for EN_DCTransferTypeRequestIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EN_DCTransferTypeRequestIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EN_DCTransferTypeRequestIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {}
impl entropic::Entropic for ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry :: from_finite_entropy (source) ?) ;
        }
        Ok(ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ENB_ID_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_macroENB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(20, 16383);
        let total_bitlen = source.get_bounded_len(20..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ENB_ID_macroENB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 20);
        let capped_max = std::cmp::min(20, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(20..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct ENB_ID_homeENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_homeENB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(28, 16383);
        let total_bitlen = source.get_bounded_len(28..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ENB_ID_homeENB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 28);
        let capped_max = std::cmp::min(28, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(28..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct ENB_ID_short_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_short_macroENB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(18, 16383);
        let total_bitlen = source.get_bounded_len(18..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ENB_ID_short_macroENB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 18);
        let capped_max = std::cmp::min(18, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(18..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct ENB_ID_long_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ENB_ID_long_macroENB_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(21, 16383);
        let total_bitlen = source.get_bounded_len(21..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ENB_ID_long_macroENB_ID(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 21);
        let capped_max = std::cmp::min(21, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(21..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry {}
impl entropic::Entropic for ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENB_StatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for ENB_StatusTransfer_TransparentContainerIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(ENB_StatusTransfer_TransparentContainerIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 254)]
    Id_UL_CP_SecurityInformation(UL_CP_SecurityInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for ENBCPRelocationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_S_TMSI(_) => 96u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_UL_CP_SecurityInformation(_) => 254u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBCPRelocationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBCPRelocationIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBCPRelocationIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBCPRelocationIndicationProtocolIEs(
    pub Vec<ENBCPRelocationIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for ENBCPRelocationIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBCPRelocationIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBCPRelocationIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 294)]
    Id_EN_DCSONConfigurationTransfer_ECT(EN_DCSONConfigurationTransfer),
    #[asn(key = 310)]
    Id_IntersystemSONConfigurationTransferECT(IntersystemSONConfigurationTransfer),
    #[asn(key = 129)]
    Id_SONConfigurationTransferECT(SONConfigurationTransfer),
}
impl asn1_codecs::Asn1Choice for ENBConfigurationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EN_DCSONConfigurationTransfer_ECT(_) => 294u128.try_into().unwrap(),
            Self::Id_IntersystemSONConfigurationTransferECT(_) => 310u128.try_into().unwrap(),
            Self::Id_SONConfigurationTransferECT(_) => 129u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBConfigurationTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBConfigurationTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationTransferProtocolIEs(pub Vec<ENBConfigurationTransferProtocolIEs_Entry>);
impl entropic::Entropic for ENBConfigurationTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBConfigurationTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBConfigurationTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 292)]
    Id_ConnectedengNBToAddList(ConnectedengNBList),
    #[asn(key = 293)]
    Id_ConnectedengNBToRemoveList(ConnectedengNBList),
    #[asn(key = 137)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 234)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 64)]
    Id_SupportedTAs(SupportedTAs),
    #[asn(key = 60)]
    Id_eNBname(ENBname),
}
impl asn1_codecs::Asn1Choice for ENBConfigurationUpdateProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSG_IdList(_) => 128u128.try_into().unwrap(),
            Self::Id_ConnectedengNBToAddList(_) => 292u128.try_into().unwrap(),
            Self::Id_ConnectedengNBToRemoveList(_) => 293u128.try_into().unwrap(),
            Self::Id_DefaultPagingDRX(_) => 137u128.try_into().unwrap(),
            Self::Id_NB_IoT_DefaultPagingDRX(_) => 234u128.try_into().unwrap(),
            Self::Id_SupportedTAs(_) => 64u128.try_into().unwrap(),
            Self::Id_eNBname(_) => 60u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBConfigurationUpdateProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBConfigurationUpdateProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateProtocolIEs(pub Vec<ENBConfigurationUpdateProtocolIEs_Entry>);
impl entropic::Entropic for ENBConfigurationUpdateProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBConfigurationUpdateProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBConfigurationUpdateProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}
impl asn1_codecs::Asn1Choice for ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);
impl entropic::Entropic for ENBConfigurationUpdateAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(ENBConfigurationUpdateAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for ENBConfigurationUpdateFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 65u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBConfigurationUpdateFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBConfigurationUpdateFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateFailureProtocolIEs(
    pub Vec<ENBConfigurationUpdateFailureProtocolIEs_Entry>,
);
impl entropic::Entropic for ENBConfigurationUpdateFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBConfigurationUpdateFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBConfigurationUpdateFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBDirectInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 121)]
    Id_Inter_SystemInformationTransferTypeEDT(Inter_SystemInformationTransferType),
}
impl asn1_codecs::Asn1Choice for ENBDirectInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Inter_SystemInformationTransferTypeEDT(_) => 121u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBDirectInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBDirectInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBDirectInformationTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBDirectInformationTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBDirectInformationTransferProtocolIEs(
    pub Vec<ENBDirectInformationTransferProtocolIEs_Entry>,
);
impl entropic::Entropic for ENBDirectInformationTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBDirectInformationTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBDirectInformationTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 321)]
    Id_eNB_EarlyStatusTransfer_TransparentContainer(ENB_EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for ENBEarlyStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_EarlyStatusTransfer_TransparentContainer(_) => 321u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBEarlyStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBEarlyStatusTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBEarlyStatusTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBEarlyStatusTransferProtocolIEs(pub Vec<ENBEarlyStatusTransferProtocolIEs_Entry>);
impl entropic::Entropic for ENBEarlyStatusTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBEarlyStatusTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBEarlyStatusTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ENBStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 90)]
    Id_eNB_StatusTransfer_TransparentContainer(ENB_StatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for ENBStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_StatusTransfer_TransparentContainer(_) => 90u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for ENBStatusTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ENBStatusTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBStatusTransferProtocolIEs(pub Vec<ENBStatusTransferProtocolIEs_Entry>);
impl entropic::Entropic for ENBStatusTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBStatusTransferProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ENBStatusTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBX2ExtTLAIE_Extensions_Entry {}
impl entropic::Entropic for ENBX2ExtTLAIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENBX2ExtTLAIE_Extensions(pub Vec<ENBX2ExtTLAIE_Extensions_Entry>);
impl entropic::Entropic for ENBX2ExtTLAIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ENBX2ExtTLAIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(ENBX2ExtTLAIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRAN_CGIIE_Extensions_Entry {}
impl entropic::Entropic for EUTRAN_CGIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRAN_CGIIE_Extensions(pub Vec<EUTRAN_CGIIE_Extensions_Entry>);
impl entropic::Entropic for EUTRAN_CGIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EUTRAN_CGIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EUTRAN_CGIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct EUTRANResponseCell_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Broadcast_ItemIE_Extensions(
    pub Vec<EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaID_Broadcast_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaID_Broadcast_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry {}
impl entropic::Entropic for EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Cancelled_ItemIE_Extensions(
    pub Vec<EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry>,
);
impl entropic::Entropic for EmergencyAreaID_Cancelled_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(EmergencyAreaID_Cancelled_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ErrorIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for ErrorIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_S_TMSI(_) => 96u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ErrorIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ErrorIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for ErrorIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ErrorIndicationProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ErrorIndicationProtocolIEs(pub Vec<ErrorIndicationProtocolIEs_Entry>);
impl entropic::Entropic for ErrorIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ErrorIndicationProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ErrorIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEActivityBehaviourIE_Extensions_Entry {}
impl entropic::Entropic for ExpectedUEActivityBehaviourIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEActivityBehaviourIE_Extensions(
    pub Vec<ExpectedUEActivityBehaviourIE_Extensions_Entry>,
);
impl entropic::Entropic for ExpectedUEActivityBehaviourIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEActivityBehaviourIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(ExpectedUEActivityBehaviourIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEBehaviourIE_Extensions_Entry {}
impl entropic::Entropic for ExpectedUEBehaviourIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEBehaviourIE_Extensions(pub Vec<ExpectedUEBehaviourIE_Extensions_Entry>);
impl entropic::Entropic for ExpectedUEBehaviourIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ExpectedUEBehaviourIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ExpectedUEBehaviourIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FiveGSTAIIE_Extensions_Entry {}
impl entropic::Entropic for FiveGSTAIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FiveGSTAIIE_Extensions(pub Vec<FiveGSTAIIE_Extensions_Entry>);
impl entropic::Entropic for FiveGSTAIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(FiveGSTAIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(FiveGSTAIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenLAs_ItemIE_Extensions_Entry {}
impl entropic::Entropic for ForbiddenLAs_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenLAs_ItemIE_Extensions(pub Vec<ForbiddenLAs_ItemIE_Extensions_Entry>);
impl entropic::Entropic for ForbiddenLAs_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenLAs_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ForbiddenLAs_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenTAs_ItemIE_Extensions_Entry {}
impl entropic::Entropic for ForbiddenTAs_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenTAs_ItemIE_Extensions(pub Vec<ForbiddenTAs_ItemIE_Extensions_Entry>);
impl entropic::Entropic for ForbiddenTAs_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ForbiddenTAs_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ForbiddenTAs_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum GBR_QosInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 257)]
    Id_extended_e_RAB_GuaranteedBitrateDL(ExtendedBitRate),
    #[asn(key = 258)]
    Id_extended_e_RAB_GuaranteedBitrateUL(ExtendedBitRate),
    #[asn(key = 255)]
    Id_extended_e_RAB_MaximumBitrateDL(ExtendedBitRate),
    #[asn(key = 256)]
    Id_extended_e_RAB_MaximumBitrateUL(ExtendedBitRate),
}
impl asn1_codecs::Asn1Choice for GBR_QosInformationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_extended_e_RAB_GuaranteedBitrateDL(_) => 257u128.try_into().unwrap(),
            Self::Id_extended_e_RAB_GuaranteedBitrateUL(_) => 258u128.try_into().unwrap(),
            Self::Id_extended_e_RAB_MaximumBitrateDL(_) => 255u128.try_into().unwrap(),
            Self::Id_extended_e_RAB_MaximumBitrateUL(_) => 256u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GBR_QosInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for GBR_QosInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GBR_QosInformationIE_Extensions(pub Vec<GBR_QosInformationIE_Extensions_Entry>);
impl entropic::Entropic for GBR_QosInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GBR_QosInformationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(GBR_QosInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GERAN_Cell_IDIE_Extensions_Entry {}
impl entropic::Entropic for GERAN_Cell_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GERAN_Cell_IDIE_Extensions(pub Vec<GERAN_Cell_IDIE_Extensions_Entry>);
impl entropic::Entropic for GERAN_Cell_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GERAN_Cell_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(GERAN_Cell_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GNBIE_Extensions_Entry {}
impl entropic::Entropic for GNBIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GNBIE_Extensions(pub Vec<GNBIE_Extensions_Entry>);
impl entropic::Entropic for GNBIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GNBIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(GNBIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GUMMEIIE_Extensions_Entry {}
impl entropic::Entropic for GUMMEIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GUMMEIIE_Extensions(pub Vec<GUMMEIIE_Extensions_Entry>);
impl entropic::Entropic for GUMMEIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(GUMMEIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(GUMMEIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_ENB_IDIE_Extensions_Entry {}
impl entropic::Entropic for Global_ENB_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_ENB_IDIE_Extensions(pub Vec<Global_ENB_IDIE_Extensions_Entry>);
impl entropic::Entropic for Global_ENB_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Global_ENB_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(Global_ENB_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_GNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for Global_GNB_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_GNB_IDIE_Extensions(pub Vec<Global_GNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for Global_GNB_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Global_GNB_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(Global_GNB_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_en_gNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for Global_en_gNB_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_en_gNB_IDIE_Extensions(pub Vec<Global_en_gNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for Global_en_gNB_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Global_en_gNB_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(Global_en_gNB_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverCancelProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCancelProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverCancelProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelProtocolIEs(pub Vec<HandoverCancelProtocolIEs_Entry>);
impl entropic::Entropic for HandoverCancelProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverCancelProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverCancelProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCancelAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverCancelAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelAcknowledgeProtocolIEs(
    pub Vec<HandoverCancelAcknowledgeProtocolIEs_Entry>,
);
impl entropic::Entropic for HandoverCancelAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverCancelAcknowledgeProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(HandoverCancelAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCommandProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 12)]
    Id_E_RABSubjecttoDataForwardingList(E_RABSubjecttoDataForwardingList),
    #[asn(key = 13)]
    Id_E_RABtoReleaseListHOCmd(E_RABList),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 135)]
    Id_NASSecurityParametersfromE_UTRAN(NASSecurityParametersfromE_UTRAN),
    #[asn(key = 123)]
    Id_Target_ToSource_TransparentContainer(Target_ToSource_TransparentContainer),
    #[asn(key = 139)]
    Id_Target_ToSource_TransparentContainer_Secondary(Target_ToSource_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABSubjecttoDataForwardingList(_) => 12u128.try_into().unwrap(),
            Self::Id_E_RABtoReleaseListHOCmd(_) => 13u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 1u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NASSecurityParametersfromE_UTRAN(_) => 135u128.try_into().unwrap(),
            Self::Id_Target_ToSource_TransparentContainer(_) => 123u128.try_into().unwrap(),
            Self::Id_Target_ToSource_TransparentContainer_Secondary(_) => {
                139u128.try_into().unwrap()
            }
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverCommandProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverCommandProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCommandProtocolIEs(pub Vec<HandoverCommandProtocolIEs_Entry>);
impl entropic::Entropic for HandoverCommandProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverCommandProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverCommandProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverFailureProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverFailureProtocolIEs(pub Vec<HandoverFailureProtocolIEs_Entry>);
impl entropic::Entropic for HandoverFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverFailureProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverNotifyProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 320)]
    Id_NotifySourceeNB(NotifySourceeNB),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverNotifyProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_LHN_ID(_) => 186u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NotifySourceeNB(_) => 320u128.try_into().unwrap(),
            Self::Id_PSCellInformation(_) => 288u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_Tunnel_Information_for_BBF(_) => 176u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverNotifyProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverNotifyProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverNotifyProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverNotifyProtocolIEs(pub Vec<HandoverNotifyProtocolIEs_Entry>);
impl entropic::Entropic for HandoverNotifyProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverNotifyProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverNotifyProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverPreparationFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverPreparationFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverPreparationFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverPreparationFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverPreparationFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverPreparationFailureProtocolIEs(
    pub Vec<HandoverPreparationFailureProtocolIEs_Entry>,
);
impl entropic::Entropic for HandoverPreparationFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverPreparationFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(HandoverPreparationFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 53)]
    Id_E_RABToBeSetupListHOReq(E_RABToBeSetupListHOReq),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 196)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 165)]
    Id_ManagementBasedMDTAllowed(ManagementBasedMDTAllowed),
    #[asn(key = 177)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 192)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 136)]
    Id_NASSecurityParameterstoE_UTRAN(NASSecurityParameterstoE_UTRAN),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 104)]
    Id_Source_ToTarget_TransparentContainer(Source_ToTarget_TransparentContainer),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for HandoverRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_AerialUEsubscriptionInformation(_) => 277u128.try_into().unwrap(),
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_CSG_Id(_) => 127u128.try_into().unwrap(),
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_E_RABToBeSetupListHOReq(_) => 53u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_ExpectedUEBehaviour(_) => 196u128.try_into().unwrap(),
            Self::Id_GUMMEI_ID(_) => 75u128.try_into().unwrap(),
            Self::Id_HandoverRestrictionList(_) => 41u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 1u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 301u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID_2(_) => 158u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTAllowed(_) => 165u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTPLMNList(_) => 177u128.try_into().unwrap(),
            Self::Id_Masked_IMEISV(_) => 192u128.try_into().unwrap(),
            Self::Id_NASSecurityParameterstoE_UTRAN(_) => 136u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 306u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 308u128.try_into().unwrap(),
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_ProSeAuthorized(_) => 195u128.try_into().unwrap(),
            Self::Id_RequestType(_) => 98u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 124u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 40u128.try_into().unwrap(),
            Self::Id_Source_ToTarget_TransparentContainer(_) => 104u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 25u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 107u128.try_into().unwrap(),
            Self::Id_UESidelinkAggregateMaximumBitrate(_) => 248u128.try_into().unwrap(),
            Self::Id_UEUserPlaneCIoTSupportIndicator(_) => 241u128.try_into().unwrap(),
            Self::Id_V2XServicesAuthorized(_) => 240u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverRequestProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestProtocolIEs(pub Vec<HandoverRequestProtocolIEs_Entry>);
impl entropic::Entropic for HandoverRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 242)]
    Id_CE_mode_B_SupportIndicator(CE_mode_B_SupportIndicator),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 18)]
    Id_E_RABAdmittedList(E_RABAdmittedList),
    #[asn(key = 19)]
    Id_E_RABFailedToSetupListHOReqAck(E_RABFailedtoSetupListHOReqAck),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 123)]
    Id_Target_ToSource_TransparentContainer(Target_ToSource_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CE_mode_B_SupportIndicator(_) => 242u128.try_into().unwrap(),
            Self::Id_CSG_Id(_) => 127u128.try_into().unwrap(),
            Self::Id_CellAccessMode(_) => 145u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABAdmittedList(_) => 18u128.try_into().unwrap(),
            Self::Id_E_RABFailedToSetupListHOReqAck(_) => 19u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_Target_ToSource_TransparentContainer(_) => 123u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequestAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverRequestAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeProtocolIEs(
    pub Vec<HandoverRequestAcknowledgeProtocolIEs_Entry>,
);
impl entropic::Entropic for HandoverRequestAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverRequestAcknowledgeProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(HandoverRequestAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequiredProtocolIEs_EntryValue {
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 79)]
    Id_Direct_Forwarding_Path_Availability(Direct_Forwarding_Path_Availability),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 132)]
    Id_MSClassmark2(MSClassmark2),
    #[asn(key = 133)]
    Id_MSClassmark3(MSClassmark3),
    #[asn(key = 150)]
    Id_PS_ServiceNotAvailable(PS_ServiceNotAvailable),
    #[asn(key = 125)]
    Id_SRVCCHOIndication(SRVCCHOIndication),
    #[asn(key = 104)]
    Id_Source_ToTarget_TransparentContainer(Source_ToTarget_TransparentContainer),
    #[asn(key = 138)]
    Id_Source_ToTarget_TransparentContainer_Secondary(Source_ToTarget_TransparentContainer),
    #[asn(key = 4)]
    Id_TargetID(TargetID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverRequiredProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSG_Id(_) => 127u128.try_into().unwrap(),
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CellAccessMode(_) => 145u128.try_into().unwrap(),
            Self::Id_Direct_Forwarding_Path_Availability(_) => 79u128.try_into().unwrap(),
            Self::Id_HandoverType(_) => 1u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_MSClassmark2(_) => 132u128.try_into().unwrap(),
            Self::Id_MSClassmark3(_) => 133u128.try_into().unwrap(),
            Self::Id_PS_ServiceNotAvailable(_) => 150u128.try_into().unwrap(),
            Self::Id_SRVCCHOIndication(_) => 125u128.try_into().unwrap(),
            Self::Id_Source_ToTarget_TransparentContainer(_) => 104u128.try_into().unwrap(),
            Self::Id_Source_ToTarget_TransparentContainer_Secondary(_) => {
                138u128.try_into().unwrap()
            }
            Self::Id_TargetID(_) => 4u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequiredProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverRequiredProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverRequiredProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequiredProtocolIEs(pub Vec<HandoverRequiredProtocolIEs_Entry>);
impl entropic::Entropic for HandoverRequiredProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverRequiredProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverRequiredProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRestrictionListIE_Extensions_EntryExtensionValue {
    #[asn(key = 282)]
    Id_CNTypeRestrictions(CNTypeRestrictions),
    #[asn(key = 290)]
    Id_LastNG_RANPLMNIdentity(PLMNidentity),
    #[asn(key = 287)]
    Id_NRrestrictionin5GS(NRrestrictionin5GS),
    #[asn(key = 261)]
    Id_NRrestrictioninEPSasSecondaryRAT(NRrestrictioninEPSasSecondaryRAT),
    #[asn(key = 270)]
    Id_UnlicensedSpectrumRestriction(UnlicensedSpectrumRestriction),
}
impl asn1_codecs::Asn1Choice for HandoverRestrictionListIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CNTypeRestrictions(_) => 282u128.try_into().unwrap(),
            Self::Id_LastNG_RANPLMNIdentity(_) => 290u128.try_into().unwrap(),
            Self::Id_NRrestrictionin5GS(_) => 287u128.try_into().unwrap(),
            Self::Id_NRrestrictioninEPSasSecondaryRAT(_) => 261u128.try_into().unwrap(),
            Self::Id_UnlicensedSpectrumRestriction(_) => 270u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRestrictionListIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverRestrictionListIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for HandoverRestrictionListIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: HandoverRestrictionListIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRestrictionListIE_Extensions(
    pub Vec<HandoverRestrictionListIE_Extensions_Entry>,
);
impl entropic::Entropic for HandoverRestrictionListIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverRestrictionListIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(HandoverRestrictionListIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverSuccessProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for HandoverSuccessProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverSuccessProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverSuccessProtocolIEs_EntryValue,
}
impl entropic::Entropic for HandoverSuccessProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: HandoverSuccessProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverSuccessProtocolIEs(pub Vec<HandoverSuccessProtocolIEs_Entry>);
impl entropic::Entropic for HandoverSuccessProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(HandoverSuccessProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(HandoverSuccessProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_eUTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_uTRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_gERAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ImmediateMDTIE_Extensions_EntryExtensionValue {
    #[asn(key = 284)]
    Id_BluetoothMeasurementConfiguration(BluetoothMeasurementConfiguration),
    #[asn(key = 171)]
    Id_M3Configuration(M3Configuration),
    #[asn(key = 172)]
    Id_M4Configuration(M4Configuration),
    #[asn(key = 173)]
    Id_M5Configuration(M5Configuration),
    #[asn(key = 220)]
    Id_M6Configuration(M6Configuration),
    #[asn(key = 221)]
    Id_M7Configuration(M7Configuration),
    #[asn(key = 174)]
    Id_MDT_Location_Info(MDT_Location_Info),
    #[asn(key = 285)]
    Id_WLANMeasurementConfiguration(WLANMeasurementConfiguration),
}
impl asn1_codecs::Asn1Choice for ImmediateMDTIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BluetoothMeasurementConfiguration(_) => 284u128.try_into().unwrap(),
            Self::Id_M3Configuration(_) => 171u128.try_into().unwrap(),
            Self::Id_M4Configuration(_) => 172u128.try_into().unwrap(),
            Self::Id_M5Configuration(_) => 173u128.try_into().unwrap(),
            Self::Id_M6Configuration(_) => 220u128.try_into().unwrap(),
            Self::Id_M7Configuration(_) => 221u128.try_into().unwrap(),
            Self::Id_MDT_Location_Info(_) => 174u128.try_into().unwrap(),
            Self::Id_WLANMeasurementConfiguration(_) => 285u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ImmediateMDTIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ImmediateMDTIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for ImmediateMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: ImmediateMDTIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ImmediateMDTIE_Extensions(pub Vec<ImmediateMDTIE_Extensions_Entry>);
impl entropic::Entropic for ImmediateMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ImmediateMDTIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ImmediateMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry {}
impl entropic::Entropic for InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InformationOnRecommendedCellsAndENBsForPagingIE_Extensions(
    pub Vec<InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for InformationOnRecommendedCellsAndENBsForPagingIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v . push (InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry :: from_finite_entropy (source) ?) ;
        }
        Ok(InformationOnRecommendedCellsAndENBsForPagingIE_Extensions(
            v,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: InitialContextSetupFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupFailureProtocolIEs(
    pub Vec<InitialContextSetupFailureProtocolIEs_Entry>,
);
impl entropic::Entropic for InitialContextSetupFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InitialContextSetupFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(InitialContextSetupFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 187)]
    Id_AdditionalCSFallbackIndicator(AdditionalCSFallbackIndicator),
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 108)]
    Id_CSFallbackIndicator(CSFallbackIndicator),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 24)]
    Id_E_RABToBeSetupListCtxtSUReq(E_RABToBeSetupListCtxtSUReq),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 196)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 165)]
    Id_ManagementBasedMDTAllowed(ManagementBasedMDTAllowed),
    #[asn(key = 177)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 192)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 159)]
    Id_RegisteredLAI(LAI),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 73)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalCSFallbackIndicator(_) => 187u128.try_into().unwrap(),
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_AerialUEsubscriptionInformation(_) => 277u128.try_into().unwrap(),
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_CSFallbackIndicator(_) => 108u128.try_into().unwrap(),
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_E_RABToBeSetupListCtxtSUReq(_) => 24u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_ExpectedUEBehaviour(_) => 196u128.try_into().unwrap(),
            Self::Id_GUMMEI_ID(_) => 75u128.try_into().unwrap(),
            Self::Id_HandoverRestrictionList(_) => 41u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 301u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID_2(_) => 158u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTAllowed(_) => 165u128.try_into().unwrap(),
            Self::Id_ManagementBasedMDTPLMNList(_) => 177u128.try_into().unwrap(),
            Self::Id_Masked_IMEISV(_) => 192u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 306u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 308u128.try_into().unwrap(),
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_ProSeAuthorized(_) => 195u128.try_into().unwrap(),
            Self::Id_RegisteredLAI(_) => 159u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 124u128.try_into().unwrap(),
            Self::Id_SecurityKey(_) => 73u128.try_into().unwrap(),
            Self::Id_SubscriberProfileIDforRFP(_) => 106u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 25u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 107u128.try_into().unwrap(),
            Self::Id_UESidelinkAggregateMaximumBitrate(_) => 248u128.try_into().unwrap(),
            Self::Id_UEUserPlaneCIoTSupportIndicator(_) => 241u128.try_into().unwrap(),
            Self::Id_V2XServicesAuthorized(_) => 240u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: InitialContextSetupRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupRequestProtocolIEs(
    pub Vec<InitialContextSetupRequestProtocolIEs_Entry>,
);
impl entropic::Entropic for InitialContextSetupRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InitialContextSetupRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(InitialContextSetupRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 48)]
    Id_E_RABFailedToSetupListCtxtSURes(E_RABList),
    #[asn(key = 51)]
    Id_E_RABSetupListCtxtSURes(E_RABSetupListCtxtSURes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for InitialContextSetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToSetupListCtxtSURes(_) => 48u128.try_into().unwrap(),
            Self::Id_E_RABSetupListCtxtSURes(_) => 51u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialContextSetupResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: InitialContextSetupResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupResponseProtocolIEs(
    pub Vec<InitialContextSetupResponseProtocolIEs_Entry>,
);
impl entropic::Entropic for InitialContextSetupResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InitialContextSetupResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(InitialContextSetupResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitialUEMessageProtocolIEs_EntryValue {
    #[asn(key = 242)]
    Id_CE_mode_B_SupportIndicator(CE_mode_B_SupportIndicator),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 250)]
    Id_Coverage_Level(Coverage_Level),
    #[asn(key = 246)]
    Id_DCN_ID(DCN_ID),
    #[asn(key = 281)]
    Id_EDT_Session(EDT_Session),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 170)]
    Id_GUMMEIType(GUMMEIType),
    #[asn(key = 155)]
    Id_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 302)]
    Id_IAB_Node_Indication(IAB_Node_Indication),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 223)]
    Id_MME_Group_ID(MME_Group_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 134)]
    Id_RRC_Establishment_Cause(RRC_Establishment_Cause),
    #[asn(key = 160)]
    Id_RelayNode_Indicator(RelayNode_Indicator),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 184)]
    Id_SIPTO_L_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 263)]
    Id_UE_Application_Layer_Measurement_Capability(UE_Application_Layer_Measurement_Capability),
    #[asn(key = 230)]
    Id_UE_Usage_Type(UE_Usage_Type),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for InitialUEMessageProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CE_mode_B_SupportIndicator(_) => 242u128.try_into().unwrap(),
            Self::Id_CSG_Id(_) => 127u128.try_into().unwrap(),
            Self::Id_CellAccessMode(_) => 145u128.try_into().unwrap(),
            Self::Id_Coverage_Level(_) => 250u128.try_into().unwrap(),
            Self::Id_DCN_ID(_) => 246u128.try_into().unwrap(),
            Self::Id_EDT_Session(_) => 281u128.try_into().unwrap(),
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_GUMMEI_ID(_) => 75u128.try_into().unwrap(),
            Self::Id_GUMMEIType(_) => 170u128.try_into().unwrap(),
            Self::Id_GW_TransportLayerAddress(_) => 155u128.try_into().unwrap(),
            Self::Id_IAB_Node_Indication(_) => 302u128.try_into().unwrap(),
            Self::Id_LHN_ID(_) => 186u128.try_into().unwrap(),
            Self::Id_MME_Group_ID(_) => 223u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 26u128.try_into().unwrap(),
            Self::Id_RRC_Establishment_Cause(_) => 134u128.try_into().unwrap(),
            Self::Id_RelayNode_Indicator(_) => 160u128.try_into().unwrap(),
            Self::Id_S_TMSI(_) => 96u128.try_into().unwrap(),
            Self::Id_SIPTO_L_GW_TransportLayerAddress(_) => 184u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_Tunnel_Information_for_BBF(_) => 176u128.try_into().unwrap(),
            Self::Id_UE_Application_Layer_Measurement_Capability(_) => 263u128.try_into().unwrap(),
            Self::Id_UE_Usage_Type(_) => 230u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialUEMessageProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialUEMessageProtocolIEs_EntryValue,
}
impl entropic::Entropic for InitialUEMessageProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: InitialUEMessageProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialUEMessageProtocolIEs(pub Vec<InitialUEMessageProtocolIEs_Entry>);
impl entropic::Entropic for InitialUEMessageProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InitialUEMessageProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(InitialUEMessageProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingMessageValue {
    #[asn(key = 42)]
    Id_CellTrafficTrace(CellTrafficTrace),
    #[asn(key = 54)]
    Id_ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
    #[asn(key = 26)]
    Id_DeactivateTrace(DeactivateTrace),
    #[asn(key = 19)]
    Id_DownlinkS1cdma2000tunnelling(DownlinkS1cdma2000tunnelling),
    #[asn(key = 50)]
    Id_E_RABModificationIndication(E_RABModificationIndication),
    #[asn(key = 6)]
    Id_E_RABModify(E_RABModifyRequest),
    #[asn(key = 7)]
    Id_E_RABRelease(E_RABReleaseCommand),
    #[asn(key = 8)]
    Id_E_RABReleaseIndication(E_RABReleaseIndication),
    #[asn(key = 5)]
    Id_E_RABSetup(E_RABSetupRequest),
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdate),
    #[asn(key = 15)]
    Id_ErrorIndication(ErrorIndication),
    #[asn(key = 4)]
    Id_HandoverCancel(HandoverCancel),
    #[asn(key = 2)]
    Id_HandoverNotification(HandoverNotify),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverRequired),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverRequest),
    #[asn(key = 64)]
    Id_HandoverSuccess(HandoverSuccess),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupRequest),
    #[asn(key = 43)]
    Id_Kill(KillRequest),
    #[asn(key = 33)]
    Id_LocationReport(LocationReport),
    #[asn(key = 31)]
    Id_LocationReportingControl(LocationReportingControl),
    #[asn(key = 32)]
    Id_LocationReportingFailureIndication(LocationReportingFailureIndication),
    #[asn(key = 61)]
    Id_MMECPRelocationIndication(MMECPRelocationIndication),
    #[asn(key = 41)]
    Id_MMEConfigurationTransfer(MMEConfigurationTransfer),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdate),
    #[asn(key = 38)]
    Id_MMEDirectInformationTransfer(MMEDirectInformationTransfer),
    #[asn(key = 66)]
    Id_MMEEarlyStatusTransfer(MMEEarlyStatusTransfer),
    #[asn(key = 25)]
    Id_MMEStatusTransfer(MMEStatusTransfer),
    #[asn(key = 57)]
    Id_NASDeliveryIndication(NASDeliveryIndication),
    #[asn(key = 16)]
    Id_NASNonDeliveryIndication(NASNonDeliveryIndication),
    #[asn(key = 34)]
    Id_OverloadStart(OverloadStart),
    #[asn(key = 35)]
    Id_OverloadStop(OverloadStop),
    #[asn(key = 51)]
    Id_PWSFailureIndication(PWSFailureIndication),
    #[asn(key = 49)]
    Id_PWSRestartIndication(PWSRestartIndication),
    #[asn(key = 10)]
    Id_Paging(Paging),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequest),
    #[asn(key = 39)]
    Id_PrivateMessage(PrivateMessage),
    #[asn(key = 52)]
    Id_RerouteNASRequest(RerouteNASRequest),
    #[asn(key = 14)]
    Id_Reset(Reset),
    #[asn(key = 58)]
    Id_RetrieveUEInformation(RetrieveUEInformation),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupRequest),
    #[asn(key = 62)]
    Id_SecondaryRATDataUsageReport(SecondaryRATDataUsageReport),
    #[asn(key = 28)]
    Id_TraceFailureIndication(TraceFailureIndication),
    #[asn(key = 27)]
    Id_TraceStart(TraceStart),
    #[asn(key = 22)]
    Id_UECapabilityInfoIndication(UECapabilityInfoIndication),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationRequest),
    #[asn(key = 53)]
    Id_UEContextModificationIndication(UEContextModificationIndication),
    #[asn(key = 23)]
    Id_UEContextRelease(UEContextReleaseCommand),
    #[asn(key = 18)]
    Id_UEContextReleaseRequest(UEContextReleaseRequest),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeRequest),
    #[asn(key = 55)]
    Id_UEContextSuspend(UEContextSuspendRequest),
    #[asn(key = 59)]
    Id_UEInformationTransfer(UEInformationTransfer),
    #[asn(key = 63)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingRequest),
    #[asn(key = 48)]
    Id_UERadioCapabilityMatch(UERadioCapabilityMatchRequest),
    #[asn(key = 20)]
    Id_UplinkS1cdma2000tunnelling(UplinkS1cdma2000tunnelling),
    #[asn(key = 36)]
    Id_WriteReplaceWarning(WriteReplaceWarningRequest),
    #[asn(key = 11)]
    Id_downlinkNASTransport(DownlinkNASTransport),
    #[asn(key = 46)]
    Id_downlinkNonUEAssociatedLPPaTransport(DownlinkNonUEAssociatedLPPaTransport),
    #[asn(key = 44)]
    Id_downlinkUEAssociatedLPPaTransport(DownlinkUEAssociatedLPPaTransport),
    #[asn(key = 60)]
    Id_eNBCPRelocationIndication(ENBCPRelocationIndication),
    #[asn(key = 40)]
    Id_eNBConfigurationTransfer(ENBConfigurationTransfer),
    #[asn(key = 37)]
    Id_eNBDirectInformationTransfer(ENBDirectInformationTransfer),
    #[asn(key = 65)]
    Id_eNBEarlyStatusTransfer(ENBEarlyStatusTransfer),
    #[asn(key = 24)]
    Id_eNBStatusTransfer(ENBStatusTransfer),
    #[asn(key = 12)]
    Id_initialUEMessage(InitialUEMessage),
    #[asn(key = 13)]
    Id_uplinkNASTransport(UplinkNASTransport),
    #[asn(key = 47)]
    Id_uplinkNonUEAssociatedLPPaTransport(UplinkNonUEAssociatedLPPaTransport),
    #[asn(key = 45)]
    Id_uplinkUEAssociatedLPPaTransport(UplinkUEAssociatedLPPaTransport),
}
impl asn1_codecs::Asn1Choice for InitiatingMessageValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CellTrafficTrace(_) => 42u128.try_into().unwrap(),
            Self::Id_ConnectionEstablishmentIndication(_) => 54u128.try_into().unwrap(),
            Self::Id_DeactivateTrace(_) => 26u128.try_into().unwrap(),
            Self::Id_DownlinkS1cdma2000tunnelling(_) => 19u128.try_into().unwrap(),
            Self::Id_E_RABModificationIndication(_) => 50u128.try_into().unwrap(),
            Self::Id_E_RABModify(_) => 6u128.try_into().unwrap(),
            Self::Id_E_RABRelease(_) => 7u128.try_into().unwrap(),
            Self::Id_E_RABReleaseIndication(_) => 8u128.try_into().unwrap(),
            Self::Id_E_RABSetup(_) => 5u128.try_into().unwrap(),
            Self::Id_ENBConfigurationUpdate(_) => 29u128.try_into().unwrap(),
            Self::Id_ErrorIndication(_) => 15u128.try_into().unwrap(),
            Self::Id_HandoverCancel(_) => 4u128.try_into().unwrap(),
            Self::Id_HandoverNotification(_) => 2u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 0u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 1u128.try_into().unwrap(),
            Self::Id_HandoverSuccess(_) => 64u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 9u128.try_into().unwrap(),
            Self::Id_Kill(_) => 43u128.try_into().unwrap(),
            Self::Id_LocationReport(_) => 33u128.try_into().unwrap(),
            Self::Id_LocationReportingControl(_) => 31u128.try_into().unwrap(),
            Self::Id_LocationReportingFailureIndication(_) => 32u128.try_into().unwrap(),
            Self::Id_MMECPRelocationIndication(_) => 61u128.try_into().unwrap(),
            Self::Id_MMEConfigurationTransfer(_) => 41u128.try_into().unwrap(),
            Self::Id_MMEConfigurationUpdate(_) => 30u128.try_into().unwrap(),
            Self::Id_MMEDirectInformationTransfer(_) => 38u128.try_into().unwrap(),
            Self::Id_MMEEarlyStatusTransfer(_) => 66u128.try_into().unwrap(),
            Self::Id_MMEStatusTransfer(_) => 25u128.try_into().unwrap(),
            Self::Id_NASDeliveryIndication(_) => 57u128.try_into().unwrap(),
            Self::Id_NASNonDeliveryIndication(_) => 16u128.try_into().unwrap(),
            Self::Id_OverloadStart(_) => 34u128.try_into().unwrap(),
            Self::Id_OverloadStop(_) => 35u128.try_into().unwrap(),
            Self::Id_PWSFailureIndication(_) => 51u128.try_into().unwrap(),
            Self::Id_PWSRestartIndication(_) => 49u128.try_into().unwrap(),
            Self::Id_Paging(_) => 10u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 3u128.try_into().unwrap(),
            Self::Id_PrivateMessage(_) => 39u128.try_into().unwrap(),
            Self::Id_RerouteNASRequest(_) => 52u128.try_into().unwrap(),
            Self::Id_Reset(_) => 14u128.try_into().unwrap(),
            Self::Id_RetrieveUEInformation(_) => 58u128.try_into().unwrap(),
            Self::Id_S1Setup(_) => 17u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReport(_) => 62u128.try_into().unwrap(),
            Self::Id_TraceFailureIndication(_) => 28u128.try_into().unwrap(),
            Self::Id_TraceStart(_) => 27u128.try_into().unwrap(),
            Self::Id_UECapabilityInfoIndication(_) => 22u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 21u128.try_into().unwrap(),
            Self::Id_UEContextModificationIndication(_) => 53u128.try_into().unwrap(),
            Self::Id_UEContextRelease(_) => 23u128.try_into().unwrap(),
            Self::Id_UEContextReleaseRequest(_) => 18u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 56u128.try_into().unwrap(),
            Self::Id_UEContextSuspend(_) => 55u128.try_into().unwrap(),
            Self::Id_UEInformationTransfer(_) => 59u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityIDMapping(_) => 63u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityMatch(_) => 48u128.try_into().unwrap(),
            Self::Id_UplinkS1cdma2000tunnelling(_) => 20u128.try_into().unwrap(),
            Self::Id_WriteReplaceWarning(_) => 36u128.try_into().unwrap(),
            Self::Id_downlinkNASTransport(_) => 11u128.try_into().unwrap(),
            Self::Id_downlinkNonUEAssociatedLPPaTransport(_) => 46u128.try_into().unwrap(),
            Self::Id_downlinkUEAssociatedLPPaTransport(_) => 44u128.try_into().unwrap(),
            Self::Id_eNBCPRelocationIndication(_) => 60u128.try_into().unwrap(),
            Self::Id_eNBConfigurationTransfer(_) => 40u128.try_into().unwrap(),
            Self::Id_eNBDirectInformationTransfer(_) => 37u128.try_into().unwrap(),
            Self::Id_eNBEarlyStatusTransfer(_) => 65u128.try_into().unwrap(),
            Self::Id_eNBStatusTransfer(_) => 24u128.try_into().unwrap(),
            Self::Id_initialUEMessage(_) => 12u128.try_into().unwrap(),
            Self::Id_uplinkNASTransport(_) => 13u128.try_into().unwrap(),
            Self::Id_uplinkNonUEAssociatedLPPaTransport(_) => 47u128.try_into().unwrap(),
            Self::Id_uplinkUEAssociatedLPPaTransport(_) => 45u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024")]
pub struct InterSystemMeasurementItemFreqBandIndicatorNR(pub u16);
impl entropic::Entropic for InterSystemMeasurementItemFreqBandIndicatorNR {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(InterSystemMeasurementItemFreqBandIndicatorNR(
            source.get_uniform_range(1..=1024)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=1024 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "32")]
pub struct InterSystemMeasurementItemSSBfrequencies(pub u8);
impl entropic::Entropic for InterSystemMeasurementItemSSBfrequencies {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(InterSystemMeasurementItemSSBfrequencies(
            source.get_uniform_range(0..=32)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=32 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct InterSystemMeasurementItemSubcarrierSpacingSSB(pub u8);
impl InterSystemMeasurementItemSubcarrierSpacingSSB {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ60: u8 = 2u8;
    pub const K_HZ120: u8 = 3u8;
    pub const K_HZ240: u8 = 4u8;
}
impl entropic::Entropic for InterSystemMeasurementItemSubcarrierSpacingSSB {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(InterSystemMeasurementItemSubcarrierSpacingSSB(
            source.get_uniform_range(0..=4)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct InterSystemMeasurementItemMaxRSIndexCellQual(pub u8);
impl entropic::Entropic for InterSystemMeasurementItemMaxRSIndexCellQual {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(InterSystemMeasurementItemMaxRSIndexCellQual(
            source.get_uniform_range(1..=16)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=16 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSMTC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemThreshRS_Index_r15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSSBToMeasure(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSSRSSIMeasurement(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemQuantityConfigNR_R15(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemBlackCellsToAddModList(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemMeasurementItemIE_Extensions_Entry {}
impl entropic::Entropic for InterSystemMeasurementItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemMeasurementItemIE_Extensions(
    pub Vec<InterSystemMeasurementItemIE_Extensions_Entry>,
);
impl entropic::Entropic for InterSystemMeasurementItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(InterSystemMeasurementItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(InterSystemMeasurementItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct InterSystemMeasurementParametersMeasurementDuration(pub u8);
impl entropic::Entropic for InterSystemMeasurementParametersMeasurementDuration {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(InterSystemMeasurementParametersMeasurementDuration(
            source.get_uniform_range(1..=100)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=100 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemMeasurementParametersIE_Extensions_Entry {}
impl entropic::Entropic for InterSystemMeasurementParametersIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemMeasurementParametersIE_Extensions(
    pub Vec<InterSystemMeasurementParametersIE_Extensions_Entry>,
);
impl entropic::Entropic for InterSystemMeasurementParametersIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                InterSystemMeasurementParametersIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(InterSystemMeasurementParametersIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationRSRP(pub u8);
impl entropic::Entropic for IntersystemMeasurementConfigurationRSRP {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IntersystemMeasurementConfigurationRSRP(
            source.get_uniform_range(0..=127)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationRSRQ(pub u8);
impl entropic::Entropic for IntersystemMeasurementConfigurationRSRQ {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IntersystemMeasurementConfigurationRSRQ(
            source.get_uniform_range(0..=127)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationSINR(pub u8);
impl entropic::Entropic for IntersystemMeasurementConfigurationSINR {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(IntersystemMeasurementConfigurationSINR(
            source.get_uniform_range(0..=127)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=127 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for IntersystemMeasurementConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemMeasurementConfigurationIE_Extensions(
    pub Vec<IntersystemMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for IntersystemMeasurementConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                IntersystemMeasurementConfigurationIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(IntersystemMeasurementConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum KillRequestProtocolIEs_EntryValue {
    #[asn(key = 191)]
    Id_KillAllWarningMessages(KillAllWarningMessages),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 113)]
    Id_WarningAreaList(WarningAreaList),
}
impl asn1_codecs::Asn1Choice for KillRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_KillAllWarningMessages(_) => 191u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 111u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 112u128.try_into().unwrap(),
            Self::Id_WarningAreaList(_) => 113u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct KillRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: KillRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for KillRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: KillRequestProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct KillRequestProtocolIEs(pub Vec<KillRequestProtocolIEs_Entry>);
impl entropic::Entropic for KillRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(KillRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(KillRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum KillResponseProtocolIEs_EntryValue {
    #[asn(key = 141)]
    Id_BroadcastCancelledAreaList(BroadcastCancelledAreaList),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
}
impl asn1_codecs::Asn1Choice for KillResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BroadcastCancelledAreaList(_) => 141u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 111u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 112u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct KillResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: KillResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for KillResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: KillResponseProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct KillResponseProtocolIEs(pub Vec<KillResponseProtocolIEs_Entry>);
impl entropic::Entropic for KillResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(KillResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(KillResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAIIE_Extensions_Entry {}
impl entropic::Entropic for LAIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LAIIE_Extensions(pub Vec<LAIIE_Extensions_Entry>);
impl entropic::Entropic for LAIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LAIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(LAIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 168)]
    Id_HO_Cause(Cause),
    #[asn(key = 167)]
    Id_Time_UE_StayedInCell_EnhancedGranularity(Time_UE_StayedInCell_EnhancedGranularity),
}
impl asn1_codecs::Asn1Choice for LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_HO_Cause(_) => 168u128.try_into().unwrap(),
            Self::Id_Time_UE_StayedInCell_EnhancedGranularity(_) => 167u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for LastVisitedEUTRANCellInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions(
    pub Vec<LastVisitedEUTRANCellInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for LastVisitedEUTRANCellInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                LastVisitedEUTRANCellInformationIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(LastVisitedEUTRANCellInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct LastVisitedGERANCellInformation_undefined;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ListeningSubframePatternPattern_period(pub u8);
impl ListeningSubframePatternPattern_period {
    pub const MS1280: u8 = 0u8;
    pub const MS2560: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
}
impl entropic::Entropic for ListeningSubframePatternPattern_period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ListeningSubframePatternPattern_period(
            source.get_uniform_range(0..=3)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=3 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239", extensible = true)]
pub struct ListeningSubframePatternPattern_offset(pub u16);
impl entropic::Entropic for ListeningSubframePatternPattern_offset {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ListeningSubframePatternPattern_offset(
            source.get_uniform_range(0..=10239)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=10239 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ListeningSubframePatternIE_Extensions_Entry {}
impl entropic::Entropic for ListeningSubframePatternIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ListeningSubframePatternIE_Extensions(
    pub Vec<ListeningSubframePatternIE_Extensions_Entry>,
);
impl entropic::Entropic for ListeningSubframePatternIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ListeningSubframePatternIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(ListeningSubframePatternIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for LocationReportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_PSCellInformation(_) => 288u128.try_into().unwrap(),
            Self::Id_RequestType(_) => 98u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: LocationReportProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportProtocolIEs(pub Vec<LocationReportProtocolIEs_Entry>);
impl entropic::Entropic for LocationReportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LocationReportProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(LocationReportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingControlProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for LocationReportingControlProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_RequestType(_) => 98u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingControlProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingControlProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportingControlProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: LocationReportingControlProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingControlProtocolIEs(pub Vec<LocationReportingControlProtocolIEs_Entry>);
impl entropic::Entropic for LocationReportingControlProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LocationReportingControlProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(LocationReportingControlProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for LocationReportingFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for LocationReportingFailureIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: LocationReportingFailureIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingFailureIndicationProtocolIEs(
    pub Vec<LocationReportingFailureIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for LocationReportingFailureIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                LocationReportingFailureIndicationProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(LocationReportingFailureIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMBSFNMDTIE_Extensions_Entry {}
impl entropic::Entropic for LoggedMBSFNMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMBSFNMDTIE_Extensions(pub Vec<LoggedMBSFNMDTIE_Extensions_Entry>);
impl entropic::Entropic for LoggedMBSFNMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LoggedMBSFNMDTIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(LoggedMBSFNMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum LoggedMDTIE_Extensions_EntryExtensionValue {
    #[asn(key = 284)]
    Id_BluetoothMeasurementConfiguration(BluetoothMeasurementConfiguration),
    #[asn(key = 285)]
    Id_WLANMeasurementConfiguration(WLANMeasurementConfiguration),
}
impl asn1_codecs::Asn1Choice for LoggedMDTIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BluetoothMeasurementConfiguration(_) => 284u128.try_into().unwrap(),
            Self::Id_WLANMeasurementConfiguration(_) => 285u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LoggedMDTIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for LoggedMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: LoggedMDTIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMDTIE_Extensions(pub Vec<LoggedMDTIE_Extensions_Entry>);
impl entropic::Entropic for LoggedMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(LoggedMDTIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(LoggedMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1PeriodicReportingIE_Extensions_Entry {}
impl entropic::Entropic for M1PeriodicReportingIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1PeriodicReportingIE_Extensions(pub Vec<M1PeriodicReportingIE_Extensions_Entry>);
impl entropic::Entropic for M1PeriodicReportingIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M1PeriodicReportingIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M1PeriodicReportingIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdEventA2IE_Extensions_Entry {}
impl entropic::Entropic for M1ThresholdEventA2IE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ThresholdEventA2IE_Extensions(pub Vec<M1ThresholdEventA2IE_Extensions_Entry>);
impl entropic::Entropic for M1ThresholdEventA2IE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M1ThresholdEventA2IE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M1ThresholdEventA2IE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M3ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M3ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M3ConfigurationIE_Extensions(pub Vec<M3ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M3ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M3ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M3ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M4ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M4ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M4ConfigurationIE_Extensions(pub Vec<M4ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M4ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M4ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M4ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M5ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M5ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M5ConfigurationIE_Extensions(pub Vec<M5ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M5ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M5ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M5ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M6ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M6ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M6ConfigurationIE_Extensions(pub Vec<M6ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M6ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M6ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M6ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M7ConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for M7ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M7ConfigurationIE_Extensions(pub Vec<M7ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for M7ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(M7ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(M7ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct MBSFN_ResultToLogInfoMBSFN_AreaId(pub u8);
impl entropic::Entropic for MBSFN_ResultToLogInfoMBSFN_AreaId {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MBSFN_ResultToLogInfoMBSFN_AreaId(
            source.get_uniform_range(0..=255)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=255 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_ResultToLogInfoIE_Extensions_Entry {}
impl entropic::Entropic for MBSFN_ResultToLogInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MBSFN_ResultToLogInfoIE_Extensions(pub Vec<MBSFN_ResultToLogInfoIE_Extensions_Entry>);
impl entropic::Entropic for MBSFN_ResultToLogInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MBSFN_ResultToLogInfoIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(MBSFN_ResultToLogInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MDT_ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 178)]
    Id_SignallingBasedMDTPLMNList(MDTPLMNList),
}
impl asn1_codecs::Asn1Choice for MDT_ConfigurationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SignallingBasedMDTPLMNList(_) => 178u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: MDT_ConfigurationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for MDT_ConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: MDT_ConfigurationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_ConfigurationIE_Extensions(pub Vec<MDT_ConfigurationIE_Extensions_Entry>);
impl entropic::Entropic for MDT_ConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MDT_ConfigurationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(MDT_ConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MDTMode_ExtensionValue {
    #[asn(key = 197)]
    Id_LoggedMBSFNMDT(LoggedMBSFNMDT),
}
impl asn1_codecs::Asn1Choice for MDTMode_ExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LoggedMBSFNMDT(_) => 197u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMECPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for MMECPRelocationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMECPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMECPRelocationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMECPRelocationIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMECPRelocationIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMECPRelocationIndicationProtocolIEs(
    pub Vec<MMECPRelocationIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for MMECPRelocationIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMECPRelocationIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMECPRelocationIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 295)]
    Id_EN_DCSONConfigurationTransfer_MCT(EN_DCSONConfigurationTransfer),
    #[asn(key = 309)]
    Id_IntersystemSONConfigurationTransferMCT(IntersystemSONConfigurationTransfer),
    #[asn(key = 130)]
    Id_SONConfigurationTransferMCT(SONConfigurationTransfer),
}
impl asn1_codecs::Asn1Choice for MMEConfigurationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EN_DCSONConfigurationTransfer_MCT(_) => 295u128.try_into().unwrap(),
            Self::Id_IntersystemSONConfigurationTransferMCT(_) => 309u128.try_into().unwrap(),
            Self::Id_SONConfigurationTransferMCT(_) => 130u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEConfigurationTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEConfigurationTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationTransferProtocolIEs(pub Vec<MMEConfigurationTransferProtocolIEs_Entry>);
impl entropic::Entropic for MMEConfigurationTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEConfigurationTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMEConfigurationTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 61)]
    Id_MMEname(MMEname),
    #[asn(key = 87)]
    Id_RelativeMMECapacity(RelativeMMECapacity),
    #[asn(key = 247)]
    Id_ServedDCNs(ServedDCNs),
    #[asn(key = 105)]
    Id_ServedGUMMEIs(ServedGUMMEIs),
}
impl asn1_codecs::Asn1Choice for MMEConfigurationUpdateProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MMEname(_) => 61u128.try_into().unwrap(),
            Self::Id_RelativeMMECapacity(_) => 87u128.try_into().unwrap(),
            Self::Id_ServedDCNs(_) => 247u128.try_into().unwrap(),
            Self::Id_ServedGUMMEIs(_) => 105u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEConfigurationUpdateProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEConfigurationUpdateProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateProtocolIEs(pub Vec<MMEConfigurationUpdateProtocolIEs_Entry>);
impl entropic::Entropic for MMEConfigurationUpdateProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEConfigurationUpdateProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMEConfigurationUpdateProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}
impl asn1_codecs::Asn1Choice for MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);
impl entropic::Entropic for MMEConfigurationUpdateAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(MMEConfigurationUpdateAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for MMEConfigurationUpdateFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 65u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEConfigurationUpdateFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEConfigurationUpdateFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateFailureProtocolIEs(
    pub Vec<MMEConfigurationUpdateFailureProtocolIEs_Entry>,
);
impl entropic::Entropic for MMEConfigurationUpdateFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEConfigurationUpdateFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMEConfigurationUpdateFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEDirectInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 122)]
    Id_Inter_SystemInformationTransferTypeMDT(Inter_SystemInformationTransferType),
}
impl asn1_codecs::Asn1Choice for MMEDirectInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Inter_SystemInformationTransferTypeMDT(_) => 122u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEDirectInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEDirectInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEDirectInformationTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEDirectInformationTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEDirectInformationTransferProtocolIEs(
    pub Vec<MMEDirectInformationTransferProtocolIEs_Entry>,
);
impl entropic::Entropic for MMEDirectInformationTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEDirectInformationTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMEDirectInformationTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 321)]
    Id_eNB_EarlyStatusTransfer_TransparentContainer(ENB_EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for MMEEarlyStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_EarlyStatusTransfer_TransparentContainer(_) => 321u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEEarlyStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEEarlyStatusTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEEarlyStatusTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEEarlyStatusTransferProtocolIEs(pub Vec<MMEEarlyStatusTransferProtocolIEs_Entry>);
impl entropic::Entropic for MMEEarlyStatusTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEEarlyStatusTransferProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(MMEEarlyStatusTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum MMEStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 90)]
    Id_eNB_StatusTransfer_TransparentContainer(ENB_StatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for MMEStatusTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_StatusTransfer_TransparentContainer(_) => 90u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEStatusTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for MMEStatusTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: MMEStatusTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEStatusTransferProtocolIEs(pub Vec<MMEStatusTransferProtocolIEs_Entry>);
impl entropic::Entropic for MMEStatusTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MMEStatusTransferProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(MMEStatusTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MultiCellLoadReportingResponse_Item_uTRANResponse(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MultiCellLoadReportingResponse_Item_gERANResponse(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct MutingPatternInformationMuting_pattern_period(pub u8);
impl MutingPatternInformationMuting_pattern_period {
    pub const MS0: u8 = 0u8;
    pub const MS1280: u8 = 1u8;
    pub const MS2560: u8 = 2u8;
    pub const MS5120: u8 = 3u8;
    pub const MS10240: u8 = 4u8;
}
impl entropic::Entropic for MutingPatternInformationMuting_pattern_period {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MutingPatternInformationMuting_pattern_period(
            source.get_uniform_range(0..=4)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "10239", extensible = true)]
pub struct MutingPatternInformationMuting_pattern_offset(pub u16);
impl entropic::Entropic for MutingPatternInformationMuting_pattern_offset {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(MutingPatternInformationMuting_pattern_offset(
            source.get_uniform_range(0..=10239)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=10239 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MutingPatternInformationIE_Extensions_Entry {}
impl entropic::Entropic for MutingPatternInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MutingPatternInformationIE_Extensions(
    pub Vec<MutingPatternInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for MutingPatternInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(MutingPatternInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(MutingPatternInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NASDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for NASDeliveryIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASDeliveryIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for NASDeliveryIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: NASDeliveryIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASDeliveryIndicationProtocolIEs(pub Vec<NASDeliveryIndicationProtocolIEs_Entry>);
impl entropic::Entropic for NASDeliveryIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NASDeliveryIndicationProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(NASDeliveryIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum NASNonDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for NASNonDeliveryIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 26u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASNonDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASNonDeliveryIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for NASNonDeliveryIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: NASNonDeliveryIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASNonDeliveryIndicationProtocolIEs(pub Vec<NASNonDeliveryIndicationProtocolIEs_Entry>);
impl entropic::Entropic for NASNonDeliveryIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NASNonDeliveryIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(NASNonDeliveryIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NB_IoT_Paging_eDRXInformationIE_Extensions_Entry {}
impl entropic::Entropic for NB_IoT_Paging_eDRXInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NB_IoT_Paging_eDRXInformationIE_Extensions(
    pub Vec<NB_IoT_Paging_eDRXInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for NB_IoT_Paging_eDRXInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NB_IoT_Paging_eDRXInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(NB_IoT_Paging_eDRXInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NG_eNBIE_Extensions_Entry {}
impl entropic::Entropic for NG_eNBIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NG_eNBIE_Extensions(pub Vec<NG_eNBIE_Extensions_Entry>);
impl entropic::Entropic for NG_eNBIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NG_eNBIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(NG_eNBIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NR_CGIIE_Extensions_Entry {}
impl entropic::Entropic for NR_CGIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIIE_Extensions(pub Vec<NR_CGIIE_Extensions_Entry>);
impl entropic::Entropic for NR_CGIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NR_CGIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(NR_CGIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESecurityCapabilitiesIE_Extensions_Entry {}
impl entropic::Entropic for NRUESecurityCapabilitiesIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESecurityCapabilitiesIE_Extensions(
    pub Vec<NRUESecurityCapabilitiesIE_Extensions_Entry>,
);
impl entropic::Entropic for NRUESecurityCapabilitiesIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRUESecurityCapabilitiesIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(NRUESecurityCapabilitiesIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl entropic::Entropic for NRUESidelinkAggregateMaximumBitrateIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(NRUESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRV2XServicesAuthorizedIE_Extensions_Entry {}
impl entropic::Entropic for NRV2XServicesAuthorizedIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRV2XServicesAuthorizedIE_Extensions(
    pub Vec<NRV2XServicesAuthorizedIE_Extensions_Entry>,
);
impl entropic::Entropic for NRV2XServicesAuthorizedIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(NRV2XServicesAuthorizedIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(NRV2XServicesAuthorizedIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NotificationCellList_ItemCell_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum OverloadStartProtocolIEs_EntryValue {
    #[asn(key = 154)]
    Id_GUMMEIList(GUMMEIList),
    #[asn(key = 101)]
    Id_OverloadResponse(OverloadResponse),
    #[asn(key = 161)]
    Id_TrafficLoadReductionIndication(TrafficLoadReductionIndication),
}
impl asn1_codecs::Asn1Choice for OverloadStartProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GUMMEIList(_) => 154u128.try_into().unwrap(),
            Self::Id_OverloadResponse(_) => 101u128.try_into().unwrap(),
            Self::Id_TrafficLoadReductionIndication(_) => 161u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStartProtocolIEs_EntryValue,
}
impl entropic::Entropic for OverloadStartProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: OverloadStartProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStartProtocolIEs(pub Vec<OverloadStartProtocolIEs_Entry>);
impl entropic::Entropic for OverloadStartProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(OverloadStartProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(OverloadStartProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum OverloadStopProtocolIEs_EntryValue {
    #[asn(key = 154)]
    Id_GUMMEIList(GUMMEIList),
}
impl asn1_codecs::Asn1Choice for OverloadStopProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GUMMEIList(_) => 154u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStopProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStopProtocolIEs_EntryValue,
}
impl entropic::Entropic for OverloadStopProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: OverloadStopProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStopProtocolIEs(pub Vec<OverloadStopProtocolIEs_Entry>);
impl entropic::Entropic for OverloadStopProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(OverloadStopProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(OverloadStopProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5FlowBitRatesIE_Extensions_Entry {}
impl entropic::Entropic for PC5FlowBitRatesIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5FlowBitRatesIE_Extensions(pub Vec<PC5FlowBitRatesIE_Extensions_Entry>);
impl entropic::Entropic for PC5FlowBitRatesIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5FlowBitRatesIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PC5FlowBitRatesIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSFlowItemIE_Extensions_Entry {}
impl entropic::Entropic for PC5QoSFlowItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSFlowItemIE_Extensions(pub Vec<PC5QoSFlowItemIE_Extensions_Entry>);
impl entropic::Entropic for PC5QoSFlowItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSFlowItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PC5QoSFlowItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSParametersIE_Extensions_Entry {}
impl entropic::Entropic for PC5QoSParametersIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSParametersIE_Extensions(pub Vec<PC5QoSParametersIE_Extensions_Entry>);
impl entropic::Entropic for PC5QoSParametersIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PC5QoSParametersIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PC5QoSParametersIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMNAreaBasedQMCIE_Extensions_Entry {}
impl entropic::Entropic for PLMNAreaBasedQMCIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PLMNAreaBasedQMCIE_Extensions(pub Vec<PLMNAreaBasedQMCIE_Extensions_Entry>);
impl entropic::Entropic for PLMNAreaBasedQMCIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PLMNAreaBasedQMCIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PLMNAreaBasedQMCIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PSCellInformationIE_Extensions_Entry {}
impl entropic::Entropic for PSCellInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PSCellInformationIE_Extensions(pub Vec<PSCellInformationIE_Extensions_Entry>);
impl entropic::Entropic for PSCellInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PSCellInformationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PSCellInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 222)]
    Id_PWSfailedECGIList(PWSfailedECGIList),
}
impl asn1_codecs::Asn1Choice for PWSFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Global_ENB_ID(_) => 59u128.try_into().unwrap(),
            Self::Id_PWSfailedECGIList(_) => 222u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSFailureIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PWSFailureIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSFailureIndicationProtocolIEs(pub Vec<PWSFailureIndicationProtocolIEs_Entry>);
impl entropic::Entropic for PWSFailureIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PWSFailureIndicationProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PWSFailureIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PWSRestartIndicationProtocolIEs_EntryValue {
    #[asn(key = 182)]
    Id_ECGIListForRestart(ECGIListForRestart),
    #[asn(key = 190)]
    Id_EmergencyAreaIDListForRestart(EmergencyAreaIDListForRestart),
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 188)]
    Id_TAIListForRestart(TAIListForRestart),
}
impl asn1_codecs::Asn1Choice for PWSRestartIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ECGIListForRestart(_) => 182u128.try_into().unwrap(),
            Self::Id_EmergencyAreaIDListForRestart(_) => 190u128.try_into().unwrap(),
            Self::Id_Global_ENB_ID(_) => 59u128.try_into().unwrap(),
            Self::Id_TAIListForRestart(_) => 188u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSRestartIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSRestartIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for PWSRestartIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PWSRestartIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSRestartIndicationProtocolIEs(pub Vec<PWSRestartIndicationProtocolIEs_Entry>);
impl entropic::Entropic for PWSRestartIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PWSRestartIndicationProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PWSRestartIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PagingProtocolIEs_EntryValue {
    #[asn(key = 211)]
    Id_AssistanceDataForPaging(AssistanceDataForPaging),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 109)]
    Id_CNDomain(CNDomain),
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 304)]
    Id_DataSize(DataSize),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 239)]
    Id_NB_IoT_Paging_eDRXInformation(NB_IoT_Paging_eDRXInformation),
    #[asn(key = 324)]
    Id_NB_IoT_PagingDRX(NB_IoT_PagingDRX),
    #[asn(key = 244)]
    Id_NB_IoT_UEIdentityIndexValue(NB_IoT_UEIdentityIndexValue),
    #[asn(key = 227)]
    Id_Paging_eDRXInformation(Paging_eDRXInformation),
    #[asn(key = 151)]
    Id_PagingPriority(PagingPriority),
    #[asn(key = 46)]
    Id_TAIList(TAIList),
    #[asn(key = 80)]
    Id_UEIdentityIndexValue(UEIdentityIndexValue),
    #[asn(key = 43)]
    Id_UEPagingID(UEPagingID),
    #[asn(key = 198)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 323)]
    Id_WUS_Assistance_Information(WUS_Assistance_Information),
    #[asn(key = 231)]
    Id_extended_UEIdentityIndexValue(Extended_UEIdentityIndexValue),
    #[asn(key = 44)]
    Id_pagingDRX(PagingDRX),
}
impl asn1_codecs::Asn1Choice for PagingProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AssistanceDataForPaging(_) => 211u128.try_into().unwrap(),
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_CNDomain(_) => 109u128.try_into().unwrap(),
            Self::Id_CSG_IdList(_) => 128u128.try_into().unwrap(),
            Self::Id_DataSize(_) => 304u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_NB_IoT_Paging_eDRXInformation(_) => 239u128.try_into().unwrap(),
            Self::Id_NB_IoT_PagingDRX(_) => 324u128.try_into().unwrap(),
            Self::Id_NB_IoT_UEIdentityIndexValue(_) => 244u128.try_into().unwrap(),
            Self::Id_Paging_eDRXInformation(_) => 227u128.try_into().unwrap(),
            Self::Id_PagingPriority(_) => 151u128.try_into().unwrap(),
            Self::Id_TAIList(_) => 46u128.try_into().unwrap(),
            Self::Id_UEIdentityIndexValue(_) => 80u128.try_into().unwrap(),
            Self::Id_UEPagingID(_) => 43u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 198u128.try_into().unwrap(),
            Self::Id_WUS_Assistance_Information(_) => 323u128.try_into().unwrap(),
            Self::Id_extended_UEIdentityIndexValue(_) => 231u128.try_into().unwrap(),
            Self::Id_pagingDRX(_) => 44u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PagingProtocolIEs_EntryValue,
}
impl entropic::Entropic for PagingProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PagingProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PagingProtocolIEs(pub Vec<PagingProtocolIEs_Entry>);
impl entropic::Entropic for PagingProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PagingProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(PagingProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Paging_eDRXInformationIE_Extensions_Entry {}
impl entropic::Entropic for Paging_eDRXInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Paging_eDRXInformationIE_Extensions(pub Vec<Paging_eDRXInformationIE_Extensions_Entry>);
impl entropic::Entropic for Paging_eDRXInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(Paging_eDRXInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(Paging_eDRXInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAttemptInformationIE_Extensions_Entry {}
impl entropic::Entropic for PagingAttemptInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAttemptInformationIE_Extensions(
    pub Vec<PagingAttemptInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for PagingAttemptInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PagingAttemptInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(PagingAttemptInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestProtocolIEs_EntryValue {
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 22)]
    Id_E_RABToBeSwitchedDLList(E_RABToBeSwitchedDLList),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 245)]
    Id_RRC_Resume_Cause(RRC_Establishment_Cause),
    #[asn(key = 157)]
    Id_SourceMME_GUMMEI(GUMMEI),
    #[asn(key = 88)]
    Id_SourceMME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSG_Id(_) => 127u128.try_into().unwrap(),
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_CellAccessMode(_) => 145u128.try_into().unwrap(),
            Self::Id_E_RABToBeSwitchedDLList(_) => 22u128.try_into().unwrap(),
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_LHN_ID(_) => 186u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_PSCellInformation(_) => 288u128.try_into().unwrap(),
            Self::Id_RRC_Resume_Cause(_) => 245u128.try_into().unwrap(),
            Self::Id_SourceMME_GUMMEI(_) => 157u128.try_into().unwrap(),
            Self::Id_SourceMME_UE_S1AP_ID(_) => 88u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_Tunnel_Information_for_BBF(_) => 176u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 107u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PathSwitchRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestProtocolIEs(pub Vec<PathSwitchRequestProtocolIEs_Entry>);
impl entropic::Entropic for PathSwitchRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PathSwitchRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(PathSwitchRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 33)]
    Id_E_RABToBeReleasedList(E_RABList),
    #[asn(key = 95)]
    Id_E_RABToBeSwitchedULList(E_RABToBeSwitchedULList),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_AerialUEsubscriptionInformation(_) => 277u128.try_into().unwrap(),
            Self::Id_CE_ModeBRestricted(_) => 271u128.try_into().unwrap(),
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABToBeReleasedList(_) => 33u128.try_into().unwrap(),
            Self::Id_E_RABToBeSwitchedULList(_) => 95u128.try_into().unwrap(),
            Self::Id_EnhancedCoverageRestricted(_) => 251u128.try_into().unwrap(),
            Self::Id_HandoverRestrictionList(_) => 41u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID_2(_) => 158u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 306u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 308u128.try_into().unwrap(),
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_ProSeAuthorized(_) => 195u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 40u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_UESidelinkAggregateMaximumBitrate(_) => 248u128.try_into().unwrap(),
            Self::Id_UEUserPlaneCIoTSupportIndicator(_) => 241u128.try_into().unwrap(),
            Self::Id_V2XServicesAuthorized(_) => 240u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs(
    pub Vec<PathSwitchRequestAcknowledgeProtocolIEs_Entry>,
);
impl entropic::Entropic for PathSwitchRequestAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PathSwitchRequestAcknowledgeProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(PathSwitchRequestAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for PathSwitchRequestFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for PathSwitchRequestFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: PathSwitchRequestFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestFailureProtocolIEs(pub Vec<PathSwitchRequestFailureProtocolIEs_Entry>);
impl entropic::Entropic for PathSwitchRequestFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PathSwitchRequestFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(PathSwitchRequestFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct PrivateIE_ID_local(pub u16);
impl entropic::Entropic for PrivateIE_ID_local {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(PrivateIE_ID_local(source.get_uniform_range(0..=65535)?))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=65535 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OBJECT-IDENTIFIER")]
pub struct PrivateIE_ID_global(Vec<u32>);

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PrivateMessagePrivateIEs_Entry {}
impl entropic::Entropic for PrivateMessagePrivateIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PrivateMessagePrivateIEs(pub Vec<PrivateMessagePrivateIEs_Entry>);
impl entropic::Entropic for PrivateMessagePrivateIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(PrivateMessagePrivateIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(PrivateMessagePrivateIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ProSeAuthorizedIE_Extensions_EntryExtensionValue {
    #[asn(key = 216)]
    Id_ProSeUEtoNetworkRelaying(ProSeUEtoNetworkRelaying),
}
impl asn1_codecs::Asn1Choice for ProSeAuthorizedIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ProSeUEtoNetworkRelaying(_) => 216u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProSeAuthorizedIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ProSeAuthorizedIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for ProSeAuthorizedIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: ProSeAuthorizedIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProSeAuthorizedIE_Extensions(pub Vec<ProSeAuthorizedIE_Extensions_Entry>);
impl entropic::Entropic for ProSeAuthorizedIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ProSeAuthorizedIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ProSeAuthorizedIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "16",
    sz_ub = "16"
)]
pub struct RIMRoutingAddress_eHRPD_Sector_ID(pub Vec<u8>);
impl entropic::Entropic for RIMRoutingAddress_eHRPD_Sector_ID {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(16, 16383);
        let vec_len = source.get_bounded_len(16..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(RIMRoutingAddress_eHRPD_Sector_ID(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(16, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(16..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMTransferIE_Extensions_Entry {}
impl entropic::Entropic for RIMTransferIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMTransferIE_Extensions(pub Vec<RIMTransferIE_Extensions_Entry>);
impl entropic::Entropic for RIMTransferIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RIMTransferIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(RIMTransferIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RLFReportInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 313)]
    Id_NB_IoT_RLF_Report_Container(NB_IoT_RLF_Report_Container),
}
impl asn1_codecs::Asn1Choice for RLFReportInformationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_NB_IoT_RLF_Report_Container(_) => 313u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLFReportInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RLFReportInformationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for RLFReportInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: RLFReportInformationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RLFReportInformationIE_Extensions(pub Vec<RLFReportInformationIE_Extensions_Entry>);
impl entropic::Entropic for RLFReportInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RLFReportInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(RLFReportInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RecommendedCellItemTimeStayedInCell(pub u16);
impl entropic::Entropic for RecommendedCellItemTimeStayedInCell {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(RecommendedCellItemTimeStayedInCell(
            source.get_uniform_range(0..=4095)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=4095 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellItemIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedCellItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellItemIE_Extensions(pub Vec<RecommendedCellItemIE_Extensions_Entry>);
impl entropic::Entropic for RecommendedCellItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(RecommendedCellItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RecommendedCellList_EntryValue {
    #[asn(key = 214)]
    Id_RecommendedCellItem(RecommendedCellItem),
}
impl asn1_codecs::Asn1Choice for RecommendedCellList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RecommendedCellItem(_) => 214u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RecommendedCellList_EntryValue,
}
impl entropic::Entropic for RecommendedCellList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: RecommendedCellList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellsForPagingIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedCellsForPagingIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellsForPagingIE_Extensions(
    pub Vec<RecommendedCellsForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for RecommendedCellsForPagingIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedCellsForPagingIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(RecommendedCellsForPagingIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBItemIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedENBItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedENBItemIE_Extensions(pub Vec<RecommendedENBItemIE_Extensions_Entry>);
impl entropic::Entropic for RecommendedENBItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedENBItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(RecommendedENBItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RecommendedENBList_EntryValue {
    #[asn(key = 215)]
    Id_RecommendedENBItem(RecommendedENBItem),
}
impl asn1_codecs::Asn1Choice for RecommendedENBList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RecommendedENBItem(_) => 215u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RecommendedENBList_EntryValue,
}
impl entropic::Entropic for RecommendedENBList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: RecommendedENBList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBsForPagingIE_Extensions_Entry {}
impl entropic::Entropic for RecommendedENBsForPagingIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedENBsForPagingIE_Extensions(
    pub Vec<RecommendedENBsForPagingIE_Extensions_Entry>,
);
impl entropic::Entropic for RecommendedENBsForPagingIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RecommendedENBsForPagingIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(RecommendedENBsForPagingIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RequestTypeIE_Extensions_EntryExtensionValue {
    #[asn(key = 298)]
    Id_RequestTypeAdditionalInfo(RequestTypeAdditionalInfo),
}
impl asn1_codecs::Asn1Choice for RequestTypeIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RequestTypeAdditionalInfo(_) => 298u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RequestTypeIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RequestTypeIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for RequestTypeIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: RequestTypeIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RequestTypeIE_Extensions(pub Vec<RequestTypeIE_Extensions_Entry>);
impl entropic::Entropic for RequestTypeIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RequestTypeIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(RequestTypeIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RerouteNASRequestProtocolIEs_EntryValue {
    #[asn(key = 224)]
    Id_Additional_GUTI(Additional_GUTI),
    #[asn(key = 223)]
    Id_MME_Group_ID(MME_Group_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 230)]
    Id_UE_Usage_Type(UE_Usage_Type),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for RerouteNASRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Additional_GUTI(_) => 224u128.try_into().unwrap(),
            Self::Id_MME_Group_ID(_) => 223u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_UE_Usage_Type(_) => 230u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RerouteNASRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RerouteNASRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for RerouteNASRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: RerouteNASRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RerouteNASRequestProtocolIEs(pub Vec<RerouteNASRequestProtocolIEs_Entry>);
impl entropic::Entropic for RerouteNASRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RerouteNASRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(RerouteNASRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ResetProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 92)]
    Id_ResetType(ResetType),
}
impl asn1_codecs::Asn1Choice for ResetProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_ResetType(_) => 92u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetProtocolIEs_EntryValue,
}
impl entropic::Entropic for ResetProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ResetProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetProtocolIEs(pub Vec<ResetProtocolIEs_Entry>);
impl entropic::Entropic for ResetProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ResetProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(ResetProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ResetAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 93)]
    Id_UE_associatedLogicalS1_ConnectionListResAck(UE_associatedLogicalS1_ConnectionListResAck),
}
impl asn1_codecs::Asn1Choice for ResetAcknowledgeProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_UE_associatedLogicalS1_ConnectionListResAck(_) => 93u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetAcknowledgeProtocolIEs_EntryValue,
}
impl entropic::Entropic for ResetAcknowledgeProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: ResetAcknowledgeProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetAcknowledgeProtocolIEs(pub Vec<ResetAcknowledgeProtocolIEs_Entry>);
impl entropic::Entropic for ResetAcknowledgeProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ResetAcknowledgeProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ResetAcknowledgeProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEInformationProtocolIEs_EntryValue {
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
}
impl asn1_codecs::Asn1Choice for RetrieveUEInformationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_S_TMSI(_) => 96u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEInformationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEInformationProtocolIEs_EntryValue,
}
impl entropic::Entropic for RetrieveUEInformationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: RetrieveUEInformationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEInformationProtocolIEs(pub Vec<RetrieveUEInformationProtocolIEs_Entry>);
impl entropic::Entropic for RetrieveUEInformationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(RetrieveUEInformationProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(RetrieveUEInformationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S_TMSIIE_Extensions_Entry {}
impl entropic::Entropic for S_TMSIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct S_TMSIIE_Extensions(pub Vec<S_TMSIIE_Extensions_Entry>);
impl entropic::Entropic for S_TMSIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(S_TMSIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(S_TMSIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum S1SetupFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}
impl asn1_codecs::Asn1Choice for S1SetupFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_TimeToWait(_) => 65u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for S1SetupFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: S1SetupFailureProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupFailureProtocolIEs(pub Vec<S1SetupFailureProtocolIEs_Entry>);
impl entropic::Entropic for S1SetupFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(S1SetupFailureProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(S1SetupFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum S1SetupRequestProtocolIEs_EntryValue {
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 291)]
    Id_ConnectedengNBList(ConnectedengNBList),
    #[asn(key = 137)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 234)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 64)]
    Id_SupportedTAs(SupportedTAs),
    #[asn(key = 228)]
    Id_UE_RetentionInformation(UE_RetentionInformation),
    #[asn(key = 60)]
    Id_eNBname(ENBname),
}
impl asn1_codecs::Asn1Choice for S1SetupRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSG_IdList(_) => 128u128.try_into().unwrap(),
            Self::Id_ConnectedengNBList(_) => 291u128.try_into().unwrap(),
            Self::Id_DefaultPagingDRX(_) => 137u128.try_into().unwrap(),
            Self::Id_Global_ENB_ID(_) => 59u128.try_into().unwrap(),
            Self::Id_NB_IoT_DefaultPagingDRX(_) => 234u128.try_into().unwrap(),
            Self::Id_SupportedTAs(_) => 64u128.try_into().unwrap(),
            Self::Id_UE_RetentionInformation(_) => 228u128.try_into().unwrap(),
            Self::Id_eNBname(_) => 60u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for S1SetupRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: S1SetupRequestProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupRequestProtocolIEs(pub Vec<S1SetupRequestProtocolIEs_Entry>);
impl entropic::Entropic for S1SetupRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(S1SetupRequestProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(S1SetupRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum S1SetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 303)]
    Id_IAB_Supported(IAB_Supported),
    #[asn(key = 163)]
    Id_MMERelaySupportIndicator(MMERelaySupportIndicator),
    #[asn(key = 61)]
    Id_MMEname(MMEname),
    #[asn(key = 87)]
    Id_RelativeMMECapacity(RelativeMMECapacity),
    #[asn(key = 247)]
    Id_ServedDCNs(ServedDCNs),
    #[asn(key = 105)]
    Id_ServedGUMMEIs(ServedGUMMEIs),
    #[asn(key = 228)]
    Id_UE_RetentionInformation(UE_RetentionInformation),
}
impl asn1_codecs::Asn1Choice for S1SetupResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_IAB_Supported(_) => 303u128.try_into().unwrap(),
            Self::Id_MMERelaySupportIndicator(_) => 163u128.try_into().unwrap(),
            Self::Id_MMEname(_) => 61u128.try_into().unwrap(),
            Self::Id_RelativeMMECapacity(_) => 87u128.try_into().unwrap(),
            Self::Id_ServedDCNs(_) => 247u128.try_into().unwrap(),
            Self::Id_ServedGUMMEIs(_) => 105u128.try_into().unwrap(),
            Self::Id_UE_RetentionInformation(_) => 228u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for S1SetupResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: S1SetupResponseProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupResponseProtocolIEs(pub Vec<S1SetupResponseProtocolIEs_Entry>);
impl entropic::Entropic for S1SetupResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(S1SetupResponseProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(S1SetupResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SONConfigurationTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 209)]
    Id_Synchronisation_Information(SynchronisationInformation),
    #[asn(key = 152)]
    Id_x2TNLConfigurationInfo(X2TNLConfigurationInfo),
}
impl asn1_codecs::Asn1Choice for SONConfigurationTransferIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Synchronisation_Information(_) => 209u128.try_into().unwrap(),
            Self::Id_x2TNLConfigurationInfo(_) => 152u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONConfigurationTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SONConfigurationTransferIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SONConfigurationTransferIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: SONConfigurationTransferIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONConfigurationTransferIE_Extensions(
    pub Vec<SONConfigurationTransferIE_Extensions_Entry>,
);
impl entropic::Entropic for SONConfigurationTransferIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SONConfigurationTransferIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(SONConfigurationTransferIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SONInformation_ExtensionValue {
    #[asn(key = 206)]
    Id_SON_Information_Report(SONInformationReport),
}
impl asn1_codecs::Asn1Choice for SONInformation_ExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SON_Information_Report(_) => 206u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SONInformationReplyIE_Extensions_EntryExtensionValue {
    #[asn(key = 208)]
    Id_Muting_Pattern_Information(MutingPatternInformation),
    #[asn(key = 149)]
    Id_Time_Synchronisation_Info(TimeSynchronisationInfo),
}
impl asn1_codecs::Asn1Choice for SONInformationReplyIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Muting_Pattern_Information(_) => 208u128.try_into().unwrap(),
            Self::Id_Time_Synchronisation_Info(_) => 149u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReplyIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SONInformationReplyIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SONInformationReplyIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: SONInformationReplyIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONInformationReplyIE_Extensions(pub Vec<SONInformationReplyIE_Extensions_Entry>);
impl entropic::Entropic for SONInformationReplyIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SONInformationReplyIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SONInformationReplyIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct SONtransferRequestContainer_cellLoadReporting;

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_hOReporting;

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_energySavingsIndication;

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_failureEventReporting;

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ScheduledCommunicationTimeDayofWeek(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl entropic::Entropic for ScheduledCommunicationTimeDayofWeek {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        let capped_max = std::cmp::min(7, 16383);
        let total_bitlen = source.get_bounded_len(7..=capped_max)?;
        assert!(total_bitlen <= capped_max);
        let bytes = total_bitlen / 8;
        let bits = total_bitlen & 0b111;
        for _ in 0..bytes {
            bv.extend_from_raw_slice(source.entropic::<u8>()?.to_ne_bytes().as_slice())
        }
        for _ in 0..bits {
            bv.push(source.entropic()?);
        }
        Ok(ScheduledCommunicationTimeDayofWeek(bv))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        assert!(self.0.len() >= 7);
        let capped_max = std::cmp::min(7, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(7..=capped_max, self.0.len())?;
        let bytes = self.0.len() / 8;
        let bits = self.0.len() & 0b111;
        for idx in 0..bytes {
            length += sink.put_entropic(&self.0.as_raw_slice()[idx])?;
        }
        for idx in 0..bits {
            length += sink.put_entropic(&self.0[(8 * bytes) + idx])?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayStart(pub u32);
impl entropic::Entropic for ScheduledCommunicationTimeTimeofDayStart {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ScheduledCommunicationTimeTimeofDayStart(
            source.get_uniform_range(0..=86399)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=86399 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayEnd(pub u32);
impl entropic::Entropic for ScheduledCommunicationTimeTimeofDayEnd {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(ScheduledCommunicationTimeTimeofDayEnd(
            source.get_uniform_range(0..=86399)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=86399 as u32, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ScheduledCommunicationTimeIE_Extensions_Entry {}
impl entropic::Entropic for ScheduledCommunicationTimeIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ScheduledCommunicationTimeIE_Extensions(
    pub Vec<ScheduledCommunicationTimeIE_Extensions_Entry>,
);
impl entropic::Entropic for ScheduledCommunicationTimeIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ScheduledCommunicationTimeIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(ScheduledCommunicationTimeIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    #[asn(key = 266)]
    Id_HandoverFlag(HandoverFlag),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_HandoverFlag(_) => 266u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_TimeSinceSecondaryNodeRelease(_) => 297u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportProtocolIEs_EntryValue,
}
impl entropic::Entropic for SecondaryRATDataUsageReportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: SecondaryRATDataUsageReportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportProtocolIEs(
    pub Vec<SecondaryRATDataUsageReportProtocolIEs_Entry>,
);
impl entropic::Entropic for SecondaryRATDataUsageReportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecondaryRATDataUsageReportProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(SecondaryRATDataUsageReportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportItemIE_Extensions_Entry {}
impl entropic::Entropic for SecondaryRATDataUsageReportItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportItemIE_Extensions(
    pub Vec<SecondaryRATDataUsageReportItemIE_Extensions_Entry>,
);
impl entropic::Entropic for SecondaryRATDataUsageReportItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                SecondaryRATDataUsageReportItemIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(SecondaryRATDataUsageReportItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportList_EntryValue {
    #[asn(key = 265)]
    Id_SecondaryRATDataUsageReportItem(SecondaryRATDataUsageReportItem),
}
impl asn1_codecs::Asn1Choice for SecondaryRATDataUsageReportList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_SecondaryRATDataUsageReportItem(_) => 265u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportList_EntryValue,
}
impl entropic::Entropic for SecondaryRATDataUsageReportList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: SecondaryRATDataUsageReportList_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SecurityContextNextHopChainingCount(pub u8);
impl entropic::Entropic for SecurityContextNextHopChainingCount {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(SecurityContextNextHopChainingCount(
            source.get_uniform_range(0..=7)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=7 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityContextIE_Extensions_Entry {}
impl entropic::Entropic for SecurityContextIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityContextIE_Extensions(pub Vec<SecurityContextIE_Extensions_Entry>);
impl entropic::Entropic for SecurityContextIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SecurityContextIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SecurityContextIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedDCNsItemIE_Extensions_Entry {}
impl entropic::Entropic for ServedDCNsItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedDCNsItemIE_Extensions(pub Vec<ServedDCNsItemIE_Extensions_Entry>);
impl entropic::Entropic for ServedDCNsItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedDCNsItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ServedDCNsItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum ServedGUMMEIsItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 170)]
    Id_GUMMEIType(GUMMEIType),
}
impl asn1_codecs::Asn1Choice for ServedGUMMEIsItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_GUMMEIType(_) => 170u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedGUMMEIsItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ServedGUMMEIsItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for ServedGUMMEIsItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: ServedGUMMEIsItemIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGUMMEIsItemIE_Extensions(pub Vec<ServedGUMMEIsItemIE_Extensions_Entry>);
impl entropic::Entropic for ServedGUMMEIsItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(ServedGUMMEIsItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(ServedGUMMEIsItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNgRanNode_IDIE_Extensions_Entry {}
impl entropic::Entropic for SourceNgRanNode_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceNgRanNode_IDIE_Extensions(pub Vec<SourceNgRanNode_IDIE_Extensions_Entry>);
impl entropic::Entropic for SourceNgRanNode_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SourceNgRanNode_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SourceNgRanNode_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceeNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for SourceeNB_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceeNB_IDIE_Extensions(pub Vec<SourceeNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for SourceeNB_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SourceeNB_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SourceeNB_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 300)]
    Id_ContextatSource(ContextatSource),
    #[asn(key = 326)]
    Id_EmergencyIndicator(EmergencyIndicator),
    #[asn(key = 296)]
    Id_IMSvoiceEPSfallbackfrom5G(IMSvoiceEPSfallbackfrom5G),
    #[asn(key = 311)]
    Id_IntersystemMeasurementConfiguration(IntersystemMeasurementConfiguration),
    #[asn(key = 175)]
    Id_MobilityInformation(MobilityInformation),
    #[asn(key = 312)]
    Id_SourceNodeID(SourceNodeID),
    #[asn(key = 194)]
    Id_uE_HistoryInformationFromTheUE(UE_HistoryInformationFromTheUE),
}
impl asn1_codecs::Asn1Choice
    for SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_ContextatSource(_) => 300u128.try_into().unwrap(),
            Self::Id_EmergencyIndicator(_) => 326u128.try_into().unwrap(),
            Self::Id_IMSvoiceEPSfallbackfrom5G(_) => 296u128.try_into().unwrap(),
            Self::Id_IntersystemMeasurementConfiguration(_) => 311u128.try_into().unwrap(),
            Self::Id_MobilityInformation(_) => 175u128.try_into().unwrap(),
            Self::Id_SourceNodeID(_) => 312u128.try_into().unwrap(),
            Self::Id_uE_HistoryInformationFromTheUE(_) => 194u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value : SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue = __entropic_internal_source . entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions(
    pub Vec<SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator(pub u8);
impl Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator {
    pub const PERIODICALLY: u8 = 0u8;
    pub const ONDEMAND: u8 = 1u8;
}
impl entropic::Entropic
    for Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator
{
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(
            Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator(
                source.get_uniform_range(0..=1)?,
            ),
        )
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3600", extensible = true)]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicTime(pub u16);
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoPeriodicTime {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Subscription_Based_UE_DifferentiationInfoPeriodicTime(
            source.get_uniform_range(1..=3600)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(1..=3600 as u16, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoStationaryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoStationaryIndication {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoStationaryIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(
            Subscription_Based_UE_DifferentiationInfoStationaryIndication(
                source.get_uniform_range(0..=1)?,
            ),
        )
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=1 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoTrafficProfile(pub u8);
impl Subscription_Based_UE_DifferentiationInfoTrafficProfile {
    pub const SINGLE_PACKET: u8 = 0u8;
    pub const DUAL_PACKETS: u8 = 1u8;
    pub const MULTIPLE_PACKETS: u8 = 2u8;
}
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoTrafficProfile {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Subscription_Based_UE_DifferentiationInfoTrafficProfile(
            source.get_uniform_range(0..=2)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoBatteryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoBatteryIndication {
    pub const BATTERY_POWERED: u8 = 0u8;
    pub const BATTERY_POWERED_NOT_RECHARGEABLE_OR_REPLACEABLE: u8 = 1u8;
    pub const NOT_BATTERY_POWERED: u8 = 2u8;
}
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoBatteryIndication {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Subscription_Based_UE_DifferentiationInfoBatteryIndication(
            source.get_uniform_range(0..=2)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=2 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry {}
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions(
    pub Vec<Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry>,
);
impl entropic::Entropic for Subscription_Based_UE_DifferentiationInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(Subscription_Based_UE_DifferentiationInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SuccessfulOutcomeValue {
    #[asn(key = 50)]
    Id_E_RABModificationIndication(E_RABModificationConfirm),
    #[asn(key = 6)]
    Id_E_RABModify(E_RABModifyResponse),
    #[asn(key = 7)]
    Id_E_RABRelease(E_RABReleaseResponse),
    #[asn(key = 5)]
    Id_E_RABSetup(E_RABSetupResponse),
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdateAcknowledge),
    #[asn(key = 4)]
    Id_HandoverCancel(HandoverCancelAcknowledge),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverCommand),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverRequestAcknowledge),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupResponse),
    #[asn(key = 43)]
    Id_Kill(KillResponse),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdateAcknowledge),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequestAcknowledge),
    #[asn(key = 14)]
    Id_Reset(ResetAcknowledge),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupResponse),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationResponse),
    #[asn(key = 53)]
    Id_UEContextModificationIndication(UEContextModificationConfirm),
    #[asn(key = 23)]
    Id_UEContextRelease(UEContextReleaseComplete),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeResponse),
    #[asn(key = 55)]
    Id_UEContextSuspend(UEContextSuspendResponse),
    #[asn(key = 63)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingResponse),
    #[asn(key = 48)]
    Id_UERadioCapabilityMatch(UERadioCapabilityMatchResponse),
    #[asn(key = 36)]
    Id_WriteReplaceWarning(WriteReplaceWarningResponse),
}
impl asn1_codecs::Asn1Choice for SuccessfulOutcomeValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABModificationIndication(_) => 50u128.try_into().unwrap(),
            Self::Id_E_RABModify(_) => 6u128.try_into().unwrap(),
            Self::Id_E_RABRelease(_) => 7u128.try_into().unwrap(),
            Self::Id_E_RABSetup(_) => 5u128.try_into().unwrap(),
            Self::Id_ENBConfigurationUpdate(_) => 29u128.try_into().unwrap(),
            Self::Id_HandoverCancel(_) => 4u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 0u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 1u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 9u128.try_into().unwrap(),
            Self::Id_Kill(_) => 43u128.try_into().unwrap(),
            Self::Id_MMEConfigurationUpdate(_) => 30u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 3u128.try_into().unwrap(),
            Self::Id_Reset(_) => 14u128.try_into().unwrap(),
            Self::Id_S1Setup(_) => 17u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 21u128.try_into().unwrap(),
            Self::Id_UEContextModificationIndication(_) => 53u128.try_into().unwrap(),
            Self::Id_UEContextRelease(_) => 23u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 56u128.try_into().unwrap(),
            Self::Id_UEContextSuspend(_) => 55u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityIDMapping(_) => 63u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityMatch(_) => 48u128.try_into().unwrap(),
            Self::Id_WriteReplaceWarning(_) => 36u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum SupportedTAs_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 232)]
    Id_RAT_Type(RAT_Type),
}
impl asn1_codecs::Asn1Choice for SupportedTAs_ItemIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_RAT_Type(_) => 232u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedTAs_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SupportedTAs_ItemIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for SupportedTAs_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: SupportedTAs_ItemIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SupportedTAs_ItemIE_Extensions(pub Vec<SupportedTAs_ItemIE_Extensions_Entry>);
impl entropic::Entropic for SupportedTAs_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SupportedTAs_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(SupportedTAs_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SynchronisationInformationIE_Extensions_Entry {}
impl entropic::Entropic for SynchronisationInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SynchronisationInformationIE_Extensions(
    pub Vec<SynchronisationInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for SynchronisationInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(SynchronisationInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(SynchronisationInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedMDTIE_Extensions_Entry {}
impl entropic::Entropic for TABasedMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedMDTIE_Extensions(pub Vec<TABasedMDTIE_Extensions_Entry>);
impl entropic::Entropic for TABasedMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TABasedMDTIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TABasedMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedQMCIE_Extensions_Entry {}
impl entropic::Entropic for TABasedQMCIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedQMCIE_Extensions(pub Vec<TABasedQMCIE_Extensions_Entry>);
impl entropic::Entropic for TABasedQMCIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TABasedQMCIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TABasedQMCIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIIE_Extensions_Entry {}
impl entropic::Entropic for TAIIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIIE_Extensions(pub Vec<TAIIE_Extensions_Entry>);
impl entropic::Entropic for TAIIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TAIIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAI_Broadcast_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAI_Broadcast_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Broadcast_ItemIE_Extensions(pub Vec<TAI_Broadcast_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAI_Broadcast_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI_Broadcast_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TAI_Broadcast_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAI_Cancelled_ItemIE_Extensions_Entry {}
impl entropic::Entropic for TAI_Cancelled_ItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Cancelled_ItemIE_Extensions(pub Vec<TAI_Cancelled_ItemIE_Extensions_Entry>);
impl entropic::Entropic for TAI_Cancelled_ItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAI_Cancelled_ItemIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TAI_Cancelled_ItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedMDTIE_Extensions_Entry {}
impl entropic::Entropic for TAIBasedMDTIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedMDTIE_Extensions(pub Vec<TAIBasedMDTIE_Extensions_Entry>);
impl entropic::Entropic for TAIBasedMDTIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBasedMDTIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TAIBasedMDTIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedQMCIE_Extensions_Entry {}
impl entropic::Entropic for TAIBasedQMCIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedQMCIE_Extensions(pub Vec<TAIBasedQMCIE_Extensions_Entry>);
impl entropic::Entropic for TAIBasedQMCIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIBasedQMCIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TAIBasedQMCIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIItemIE_Extensions_Entry {}
impl entropic::Entropic for TAIItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIItemIE_Extensions(pub Vec<TAIItemIE_Extensions_Entry>);
impl entropic::Entropic for TAIItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TAIItemIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TAIItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TAIList_EntryValue {
    #[asn(key = 47)]
    Id_TAIItem(TAIItem),
}
impl asn1_codecs::Asn1Choice for TAIList_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_TAIItem(_) => 47u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TAIList_EntryValue,
}
impl entropic::Entropic for TAIList_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: TAIList_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNgRanNode_IDIE_Extensions_Entry {}
impl entropic::Entropic for TargetNgRanNode_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNgRanNode_IDIE_Extensions(pub Vec<TargetNgRanNode_IDIE_Extensions_Entry>);
impl entropic::Entropic for TargetNgRanNode_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargetNgRanNode_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TargetNgRanNode_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRNC_IDIE_Extensions_Entry {}
impl entropic::Entropic for TargetRNC_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRNC_IDIE_Extensions(pub Vec<TargetRNC_IDIE_Extensions_Entry>);
impl entropic::Entropic for TargetRNC_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargetRNC_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TargetRNC_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_IDIE_Extensions_Entry {}
impl entropic::Entropic for TargeteNB_IDIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_IDIE_Extensions(pub Vec<TargeteNB_IDIE_Extensions_Entry>);
impl entropic::Entropic for TargeteNB_IDIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TargeteNB_IDIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TargeteNB_IDIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 318)]
    Id_DAPSResponseInfoList(DAPSResponseInfoList),
}
impl asn1_codecs::Asn1Choice
    for TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue
{
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_DAPSResponseInfoList(_) => 318u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value : TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue = __entropic_internal_source . entropic () ? ;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions(
    pub Vec<TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry>,
);
impl entropic::Entropic for TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TimeSynchronisationInfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 207)]
    Id_Muting_Availability_Indication(MutingAvailabilityIndication),
}
impl asn1_codecs::Asn1Choice for TimeSynchronisationInfoIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Muting_Availability_Indication(_) => 207u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TimeSynchronisationInfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TimeSynchronisationInfoIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for TimeSynchronisationInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: TimeSynchronisationInfoIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TimeSynchronisationInfoIE_Extensions(
    pub Vec<TimeSynchronisationInfoIE_Extensions_Entry>,
);
impl entropic::Entropic for TimeSynchronisationInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TimeSynchronisationInfoIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(TimeSynchronisationInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TooEarlyInterRATHOReportReportFromEUTRANUERLFReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceActivationIE_Extensions_EntryExtensionValue {
    #[asn(key = 162)]
    Id_MDTConfiguration(MDT_Configuration),
    #[asn(key = 316)]
    Id_MDTConfigurationNR(MDT_ConfigurationNR),
    #[asn(key = 325)]
    Id_TraceCollectionEntityURI(URI_Address),
    #[asn(key = 262)]
    Id_UEAppLayerMeasConfig(UEAppLayerMeasConfig),
}
impl asn1_codecs::Asn1Choice for TraceActivationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MDTConfiguration(_) => 162u128.try_into().unwrap(),
            Self::Id_MDTConfigurationNR(_) => 316u128.try_into().unwrap(),
            Self::Id_TraceCollectionEntityURI(_) => 325u128.try_into().unwrap(),
            Self::Id_UEAppLayerMeasConfig(_) => 262u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceActivationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TraceActivationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for TraceActivationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: TraceActivationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TraceActivationIE_Extensions(pub Vec<TraceActivationIE_Extensions_Entry>);
impl entropic::Entropic for TraceActivationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TraceActivationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TraceActivationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for TraceFailureIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_E_UTRAN_Trace_ID(_) => 86u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceFailureIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for TraceFailureIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: TraceFailureIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceFailureIndicationProtocolIEs(pub Vec<TraceFailureIndicationProtocolIEs_Entry>);
impl entropic::Entropic for TraceFailureIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TraceFailureIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(TraceFailureIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum TraceStartProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for TraceStartProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_TraceActivation(_) => 25u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceStartProtocolIEs_EntryValue,
}
impl entropic::Entropic for TraceStartProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: TraceStartProtocolIEs_EntryValue = __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceStartProtocolIEs(pub Vec<TraceStartProtocolIEs_Entry>);
impl entropic::Entropic for TraceStartProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TraceStartProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(TraceStartProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TunnelInformationIE_Extensions_Entry {}
impl entropic::Entropic for TunnelInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TunnelInformationIE_Extensions(pub Vec<TunnelInformationIE_Extensions_Entry>);
impl entropic::Entropic for TunnelInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(TunnelInformationIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(TunnelInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_S1AP_ID_pairIE_Extensions_Entry {}
impl entropic::Entropic for UE_S1AP_ID_pairIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_S1AP_ID_pairIE_Extensions(pub Vec<UE_S1AP_ID_pairIE_Extensions_Entry>);
impl entropic::Entropic for UE_S1AP_ID_pairIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UE_S1AP_ID_pairIE_Extensions_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(UE_S1AP_ID_pairIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry {}
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_associatedLogicalS1_ConnectionItemIE_Extensions(
    pub Vec<UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry>,
);
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionItemIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry::from_finite_entropy(
                    source,
                )?,
            );
        }
        Ok(UE_associatedLogicalS1_ConnectionItemIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UE_associatedLogicalS1_ConnectionListRes_EntryValue {
    #[asn(key = 91)]
    Id_UE_associatedLogicalS1_ConnectionItem(UE_associatedLogicalS1_ConnectionItem),
}
impl asn1_codecs::Asn1Choice for UE_associatedLogicalS1_ConnectionListRes_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UE_associatedLogicalS1_ConnectionItem(_) => 91u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionListRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UE_associatedLogicalS1_ConnectionListRes_EntryValue,
}
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionListRes_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UE_associatedLogicalS1_ConnectionListRes_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UE_associatedLogicalS1_ConnectionListResAck_EntryValue {
    #[asn(key = 91)]
    Id_UE_associatedLogicalS1_ConnectionItem(UE_associatedLogicalS1_ConnectionItem),
}
impl asn1_codecs::Asn1Choice for UE_associatedLogicalS1_ConnectionListResAck_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UE_associatedLogicalS1_ConnectionItem(_) => 91u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionListResAck_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UE_associatedLogicalS1_ConnectionListResAck_EntryValue,
}
impl entropic::Entropic for UE_associatedLogicalS1_ConnectionListResAck_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UE_associatedLogicalS1_ConnectionListResAck_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue {
    #[asn(key = 259)]
    Id_extended_uEaggregateMaximumBitRateDL(ExtendedBitRate),
    #[asn(key = 260)]
    Id_extended_uEaggregateMaximumBitRateUL(ExtendedBitRate),
}
impl asn1_codecs::Asn1Choice for UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_extended_uEaggregateMaximumBitRateDL(_) => 259u128.try_into().unwrap(),
            Self::Id_extended_uEaggregateMaximumBitRateUL(_) => 260u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAggregateMaximumBitrateIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UEAggregateMaximumBitrateIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAggregateMaximumBitrateIE_Extensions(
    pub Vec<UEAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl entropic::Entropic for UEAggregateMaximumBitrateIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEAggregateMaximumBitrateIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(UEAggregateMaximumBitrateIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1000"
)]
pub struct UEAppLayerMeasConfigContainerForAppLayerMeasConfig(pub Vec<u8>);
impl entropic::Entropic for UEAppLayerMeasConfigContainerForAppLayerMeasConfig {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(1, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(u8::from_finite_entropy(source)?);
        }
        Ok(UEAppLayerMeasConfigContainerForAppLayerMeasConfig(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let capped_max = std::cmp::min(1, 16383);
        let mut length = 0;
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        length += sink.put_slice(self.0.as_slice())?;
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue {
    #[asn(key = 276)]
    Id_serviceType(ServiceType),
}
impl asn1_codecs::Asn1Choice for UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_serviceType(_) => 276u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAppLayerMeasConfigIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UEAppLayerMeasConfigIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAppLayerMeasConfigIE_Extensions(pub Vec<UEAppLayerMeasConfigIE_Extensions_Entry>);
impl entropic::Entropic for UEAppLayerMeasConfigIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEAppLayerMeasConfigIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(UEAppLayerMeasConfigIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UECapabilityInfoIndicationProtocolIEs_EntryValue {
    #[asn(key = 272)]
    Id_LTE_M_Indication(LTE_M_Indication),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 263)]
    Id_UE_Application_Layer_Measurement_Capability(UE_Application_Layer_Measurement_Capability),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 315)]
    Id_UERadioCapability_NR_Format(UERadioCapability),
    #[asn(key = 198)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UECapabilityInfoIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LTE_M_Indication(_) => 272u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_UE_Application_Layer_Measurement_Capability(_) => 263u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapability_NR_Format(_) => 315u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityForPaging(_) => 198u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityInfoIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UECapabilityInfoIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for UECapabilityInfoIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UECapabilityInfoIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UECapabilityInfoIndicationProtocolIEs(
    pub Vec<UECapabilityInfoIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for UECapabilityInfoIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UECapabilityInfoIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UECapabilityInfoIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextModificationConfirmProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationConfirmProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationConfirmProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextModificationConfirmProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationConfirmProtocolIEs(
    pub Vec<UEContextModificationConfirmProtocolIEs_Entry>,
);
impl entropic::Entropic for UEContextModificationConfirmProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextModificationConfirmProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextModificationConfirmProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextModificationFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextModificationFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationFailureProtocolIEs(
    pub Vec<UEContextModificationFailureProtocolIEs_Entry>,
);
impl entropic::Entropic for UEContextModificationFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextModificationFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextModificationFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationIndicationProtocolIEs_EntryValue {
    #[asn(key = 226)]
    Id_CSGMembershipInfo(CSGMembershipInfo),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextModificationIndicationProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CSGMembershipInfo(_) => 226u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationIndicationProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationIndicationProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextModificationIndicationProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationIndicationProtocolIEs(
    pub Vec<UEContextModificationIndicationProtocolIEs_Entry>,
);
impl entropic::Entropic for UEContextModificationIndicationProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextModificationIndicationProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextModificationIndicationProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 187)]
    Id_AdditionalCSFallbackIndicator(AdditionalCSFallbackIndicator),
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 108)]
    Id_CSFallbackIndicator(CSFallbackIndicator),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 159)]
    Id_RegisteredLAI(LAI),
    #[asn(key = 243)]
    Id_SRVCCOperationNotPossible(SRVCCOperationNotPossible),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 73)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}
impl asn1_codecs::Asn1Choice for UEContextModificationRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_AdditionalCSFallbackIndicator(_) => 187u128.try_into().unwrap(),
            Self::Id_AdditionalRRMPriorityIndex(_) => 299u128.try_into().unwrap(),
            Self::Id_AerialUEsubscriptionInformation(_) => 277u128.try_into().unwrap(),
            Self::Id_CSFallbackIndicator(_) => 108u128.try_into().unwrap(),
            Self::Id_CSGMembershipStatus(_) => 146u128.try_into().unwrap(),
            Self::Id_IAB_Authorized(_) => 301u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NRUESecurityCapabilities(_) => 269u128.try_into().unwrap(),
            Self::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307u128.try_into().unwrap(),
            Self::Id_NRV2XServicesAuthorized(_) => 306u128.try_into().unwrap(),
            Self::Id_PC5QoSParameters(_) => 308u128.try_into().unwrap(),
            Self::Id_ProSeAuthorized(_) => 195u128.try_into().unwrap(),
            Self::Id_RegisteredLAI(_) => 159u128.try_into().unwrap(),
            Self::Id_SRVCCOperationNotPossible(_) => 243u128.try_into().unwrap(),
            Self::Id_SRVCCOperationPossible(_) => 124u128.try_into().unwrap(),
            Self::Id_SecurityKey(_) => 73u128.try_into().unwrap(),
            Self::Id_SubscriberProfileIDforRFP(_) => 106u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_UESecurityCapabilities(_) => 107u128.try_into().unwrap(),
            Self::Id_UESidelinkAggregateMaximumBitrate(_) => 248u128.try_into().unwrap(),
            Self::Id_V2XServicesAuthorized(_) => 240u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
            Self::Id_uEaggregateMaximumBitrate(_) => 66u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextModificationRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationRequestProtocolIEs(
    pub Vec<UEContextModificationRequestProtocolIEs_Entry>,
);
impl entropic::Entropic for UEContextModificationRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextModificationRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextModificationRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextModificationResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextModificationResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextModificationResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationResponseProtocolIEs(
    pub Vec<UEContextModificationResponseProtocolIEs_Entry>,
);
impl entropic::Entropic for UEContextModificationResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextModificationResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextModificationResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 99)]
    Id_UE_S1AP_IDs(UE_S1AP_IDs),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseCommandProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_UE_S1AP_IDs(_) => 99u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCommandProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseCommandProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextReleaseCommandProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCommandProtocolIEs(pub Vec<UEContextReleaseCommandProtocolIEs_Entry>);
impl entropic::Entropic for UEContextReleaseCommandProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextReleaseCommandProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextReleaseCommandProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCompleteProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_CellIdentifierAndCELevelForCECapableUEs(CellIdentifierAndCELevelForCECapableUEs),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 213)]
    Id_InformationOnRecommendedCellsAndENBsForPaging(InformationOnRecommendedCellsAndENBsForPaging),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseCompleteProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CellIdentifierAndCELevelForCECapableUEs(_) => 212u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_InformationOnRecommendedCellsAndENBsForPaging(_) => {
                213u128.try_into().unwrap()
            }
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_TimeSinceSecondaryNodeRelease(_) => 297u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCompleteProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseCompleteProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextReleaseCompleteProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCompleteProtocolIEs(pub Vec<UEContextReleaseCompleteProtocolIEs_Entry>);
impl entropic::Entropic for UEContextReleaseCompleteProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextReleaseCompleteProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextReleaseCompleteProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 164)]
    Id_GWContextReleaseIndication(GWContextReleaseIndication),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextReleaseRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_GWContextReleaseIndication(_) => 164u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextReleaseRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextReleaseRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseRequestProtocolIEs(pub Vec<UEContextReleaseRequestProtocolIEs_Entry>);
impl entropic::Entropic for UEContextReleaseRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextReleaseRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextReleaseRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextResumeFailureProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_Cause(_) => 2u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeFailureProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeFailureProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextResumeFailureProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeFailureProtocolIEs(pub Vec<UEContextResumeFailureProtocolIEs_Entry>);
impl entropic::Entropic for UEContextResumeFailureProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextResumeFailureProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextResumeFailureProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeRequestProtocolIEs_EntryValue {
    #[asn(key = 235)]
    Id_E_RABFailedToResumeListResumeReq(E_RABFailedToResumeListResumeReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 245)]
    Id_RRC_Resume_Cause(RRC_Establishment_Cause),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextResumeRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_E_RABFailedToResumeListResumeReq(_) => 235u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_RRC_Resume_Cause(_) => 245u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextResumeRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestProtocolIEs(pub Vec<UEContextResumeRequestProtocolIEs_Entry>);
impl entropic::Entropic for UEContextResumeRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextResumeRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextResumeRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 237)]
    Id_E_RABFailedToResumeListResumeRes(E_RABFailedToResumeListResumeRes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextResumeResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_E_RABFailedToResumeListResumeRes(_) => 237u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 40u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextResumeResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextResumeResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseProtocolIEs(pub Vec<UEContextResumeResponseProtocolIEs_Entry>);
impl entropic::Entropic for UEContextResumeResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextResumeResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextResumeResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendRequestProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_CellIdentifierAndCELevelForCECapableUEs(CellIdentifierAndCELevelForCECapableUEs),
    #[asn(key = 213)]
    Id_InformationOnRecommendedCellsAndENBsForPaging(InformationOnRecommendedCellsAndENBsForPaging),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextSuspendRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CellIdentifierAndCELevelForCECapableUEs(_) => 212u128.try_into().unwrap(),
            Self::Id_InformationOnRecommendedCellsAndENBsForPaging(_) => {
                213u128.try_into().unwrap()
            }
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecondaryRATDataUsageReportList(_) => 264u128.try_into().unwrap(),
            Self::Id_TimeSinceSecondaryNodeRelease(_) => 297u128.try_into().unwrap(),
            Self::Id_UserLocationInformation(_) => 189u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextSuspendRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextSuspendRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestProtocolIEs(pub Vec<UEContextSuspendRequestProtocolIEs_Entry>);
impl entropic::Entropic for UEContextSuspendRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextSuspendRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextSuspendRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UEContextSuspendResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_SecurityContext(_) => 40u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEContextSuspendResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEContextSuspendResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendResponseProtocolIEs(pub Vec<UEContextSuspendResponseProtocolIEs_Entry>);
impl entropic::Entropic for UEContextSuspendResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEContextSuspendResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UEContextSuspendResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UEInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 252)]
    Id_UE_Level_QoS_Parameters(E_RABLevelQoSParameters),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
}
impl asn1_codecs::Asn1Choice for UEInformationTransferProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_PendingDataIndication(_) => 283u128.try_into().unwrap(),
            Self::Id_S_TMSI(_) => 96u128.try_into().unwrap(),
            Self::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278u128.try_into().unwrap(),
            Self::Id_UE_Level_QoS_Parameters(_) => 252u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEInformationTransferProtocolIEs_EntryValue,
}
impl entropic::Entropic for UEInformationTransferProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UEInformationTransferProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEInformationTransferProtocolIEs(pub Vec<UEInformationTransferProtocolIEs_Entry>);
impl entropic::Entropic for UEInformationTransferProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UEInformationTransferProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(UEInformationTransferProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingRequestProtocolIEs_Entry>,
);
impl entropic::Entropic for UERadioCapabilityIDMappingRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UERadioCapabilityIDMappingRequestProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(UERadioCapabilityIDMappingRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingResponseProtocolIEs_Entry>,
);
impl entropic::Entropic for UERadioCapabilityIDMappingResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UERadioCapabilityIDMappingResponseProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(UERadioCapabilityIDMappingResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityMatchRequestProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityMatchRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_UERadioCapability(_) => 74u128.try_into().unwrap(),
            Self::Id_UERadioCapabilityID(_) => 314u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityMatchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityMatchRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityMatchRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UERadioCapabilityMatchRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityMatchRequestProtocolIEs(
    pub Vec<UERadioCapabilityMatchRequestProtocolIEs_Entry>,
);
impl entropic::Entropic for UERadioCapabilityMatchRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UERadioCapabilityMatchRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UERadioCapabilityMatchRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityMatchResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 169)]
    Id_VoiceSupportMatchIndicator(VoiceSupportMatchIndicator),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UERadioCapabilityMatchResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_VoiceSupportMatchIndicator(_) => 169u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityMatchResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityMatchResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for UERadioCapabilityMatchResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UERadioCapabilityMatchResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityMatchResponseProtocolIEs(
    pub Vec<UERadioCapabilityMatchResponseProtocolIEs_Entry>,
);
impl entropic::Entropic for UERadioCapabilityMatchResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UERadioCapabilityMatchResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UERadioCapabilityMatchResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESecurityCapabilitiesIE_Extensions_Entry {}
impl entropic::Entropic for UESecurityCapabilitiesIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESecurityCapabilitiesIE_Extensions(pub Vec<UESecurityCapabilitiesIE_Extensions_Entry>);
impl entropic::Entropic for UESecurityCapabilitiesIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UESecurityCapabilitiesIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(UESecurityCapabilitiesIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}
impl entropic::Entropic for UESidelinkAggregateMaximumBitrateIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<UESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl entropic::Entropic for UESidelinkAggregateMaximumBitrateIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UESidelinkAggregateMaximumBitrateIE_Extensions_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(UESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CP_SecurityInformationIE_Extensions_Entry {}
impl entropic::Entropic for UL_CP_SecurityInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_CP_SecurityInformationIE_Extensions(
    pub Vec<UL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for UL_CP_SecurityInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UL_CP_SecurityInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(UL_CP_SecurityInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UnsuccessfulOutcomeValue {
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdateFailure),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverPreparationFailure),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverFailure),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupFailure),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdateFailure),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequestFailure),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupFailure),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationFailure),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeFailure),
}
impl asn1_codecs::Asn1Choice for UnsuccessfulOutcomeValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ENBConfigurationUpdate(_) => 29u128.try_into().unwrap(),
            Self::Id_HandoverPreparation(_) => 0u128.try_into().unwrap(),
            Self::Id_HandoverResourceAllocation(_) => 1u128.try_into().unwrap(),
            Self::Id_InitialContextSetup(_) => 9u128.try_into().unwrap(),
            Self::Id_MMEConfigurationUpdate(_) => 30u128.try_into().unwrap(),
            Self::Id_PathSwitchRequest(_) => 3u128.try_into().unwrap(),
            Self::Id_S1Setup(_) => 17u128.try_into().unwrap(),
            Self::Id_UEContextModification(_) => 21u128.try_into().unwrap(),
            Self::Id_UEContextResume(_) => 56u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 155)]
    Id_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 184)]
    Id_SIPTO_L_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UplinkNASTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRAN_CGI(_) => 100u128.try_into().unwrap(),
            Self::Id_GW_TransportLayerAddress(_) => 155u128.try_into().unwrap(),
            Self::Id_LHN_ID(_) => 186u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_NAS_PDU(_) => 26u128.try_into().unwrap(),
            Self::Id_PSCellInformation(_) => 288u128.try_into().unwrap(),
            Self::Id_SIPTO_L_GW_TransportLayerAddress(_) => 184u128.try_into().unwrap(),
            Self::Id_TAI(_) => 67u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNASTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkNASTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UplinkNASTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNASTransportProtocolIEs(pub Vec<UplinkNASTransportProtocolIEs_Entry>);
impl entropic::Entropic for UplinkNASTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UplinkNASTransportProtocolIEs_Entry::from_finite_entropy(
                source,
            )?);
        }
        Ok(UplinkNASTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
}
impl asn1_codecs::Asn1Choice for UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LPPa_PDU(_) => 147u128.try_into().unwrap(),
            Self::Id_Routing_ID(_) => 148u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNonUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl entropic::Entropic for UplinkNonUEAssociatedLPPaTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(
                UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry::from_finite_entropy(source)?,
            );
        }
        Ok(UplinkNonUEAssociatedLPPaTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    #[asn(key = 140)]
    Id_EUTRANRoundTripDelayEstimationInfo(EUTRANRoundTripDelayEstimationInfo),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 84)]
    Id_cdma2000HORequiredIndication(Cdma2000HORequiredIndication),
    #[asn(key = 97)]
    Id_cdma2000OneXRAND(Cdma2000OneXRAND),
    #[asn(key = 102)]
    Id_cdma2000OneXSRVCCInfo(Cdma2000OneXSRVCCInfo),
    #[asn(key = 70)]
    Id_cdma2000PDU(Cdma2000PDU),
    #[asn(key = 71)]
    Id_cdma2000RATType(Cdma2000RATType),
    #[asn(key = 72)]
    Id_cdma2000SectorID(Cdma2000SectorID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UplinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_EUTRANRoundTripDelayEstimationInfo(_) => 140u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_cdma2000HORequiredIndication(_) => 84u128.try_into().unwrap(),
            Self::Id_cdma2000OneXRAND(_) => 97u128.try_into().unwrap(),
            Self::Id_cdma2000OneXSRVCCInfo(_) => 102u128.try_into().unwrap(),
            Self::Id_cdma2000PDU(_) => 70u128.try_into().unwrap(),
            Self::Id_cdma2000RATType(_) => 71u128.try_into().unwrap(),
            Self::Id_cdma2000SectorID(_) => 72u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkS1cdma2000tunnellingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkS1cdma2000tunnellingProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkS1cdma2000tunnellingProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UplinkS1cdma2000tunnellingProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkS1cdma2000tunnellingProtocolIEs(
    pub Vec<UplinkS1cdma2000tunnellingProtocolIEs_Entry>,
);
impl entropic::Entropic for UplinkS1cdma2000tunnellingProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UplinkS1cdma2000tunnellingProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UplinkS1cdma2000tunnellingProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}
impl asn1_codecs::Asn1Choice for UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_LPPa_PDU(_) => 147u128.try_into().unwrap(),
            Self::Id_MME_UE_S1AP_ID(_) => 0u128.try_into().unwrap(),
            Self::Id_Routing_ID(_) => 148u128.try_into().unwrap(),
            Self::Id_eNB_UE_S1AP_ID(_) => 8u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}
impl entropic::Entropic for UplinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<UplinkUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl entropic::Entropic for UplinkUEAssociatedLPPaTransportProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UplinkUEAssociatedLPPaTransportProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(UplinkUEAssociatedLPPaTransportProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
}
impl asn1_codecs::Asn1Choice for UserLocationInformationIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_PSCellInformation(_) => 288u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for UserLocationInformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: UserLocationInformationIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationIE_Extensions(
    pub Vec<UserLocationInformationIE_Extensions_Entry>,
);
impl entropic::Entropic for UserLocationInformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(UserLocationInformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(UserLocationInformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct V2XServicesAuthorizedIE_Extensions_Entry {}
impl entropic::Entropic for V2XServicesAuthorizedIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct V2XServicesAuthorizedIE_Extensions(pub Vec<V2XServicesAuthorizedIE_Extensions_Entry>);
impl entropic::Entropic for V2XServicesAuthorizedIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(V2XServicesAuthorizedIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(V2XServicesAuthorizedIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rssi(pub u8);
impl WLANMeasurementConfigurationWlan_rssi {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasurementConfigurationWlan_rssi {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(WLANMeasurementConfigurationWlan_rssi(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rtt(pub u8);
impl WLANMeasurementConfigurationWlan_rtt {
    pub const TRUE: u8 = 0u8;
}
impl entropic::Entropic for WLANMeasurementConfigurationWlan_rtt {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(WLANMeasurementConfigurationWlan_rtt(
            source.get_uniform_range(0..=0)?,
        ))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        Ok(sink.put_uniform_range(0..=0 as u8, self.0)?)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasurementConfigurationIE_Extensions_Entry {}
impl entropic::Entropic for WLANMeasurementConfigurationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasurementConfigurationIE_Extensions(
    pub Vec<WLANMeasurementConfigurationIE_Extensions_Entry>,
);
impl entropic::Entropic for WLANMeasurementConfigurationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WLANMeasurementConfigurationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(WLANMeasurementConfigurationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Assistance_InformationIE_Extensions_Entry {}
impl entropic::Entropic for WUS_Assistance_InformationIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        Ok(Self {})
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WUS_Assistance_InformationIE_Extensions(
    pub Vec<WUS_Assistance_InformationIE_Extensions_Entry>,
);
impl entropic::Entropic for WUS_Assistance_InformationIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WUS_Assistance_InformationIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(WUS_Assistance_InformationIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningRequestProtocolIEs_EntryValue {
    #[asn(key = 142)]
    Id_ConcurrentWarningMessageIndicator(ConcurrentWarningMessageIndicator),
    #[asn(key = 118)]
    Id_DataCodingScheme(DataCodingScheme),
    #[asn(key = 144)]
    Id_ExtendedRepetitionPeriod(ExtendedRepetitionPeriod),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 115)]
    Id_NumberofBroadcastRequest(NumberofBroadcastRequest),
    #[asn(key = 114)]
    Id_RepetitionPeriod(RepetitionPeriod),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 286)]
    Id_WarningAreaCoordinates(WarningAreaCoordinates),
    #[asn(key = 113)]
    Id_WarningAreaList(WarningAreaList),
    #[asn(key = 119)]
    Id_WarningMessageContents(WarningMessageContents),
    #[asn(key = 117)]
    Id_WarningSecurityInfo(WarningSecurityInfo),
    #[asn(key = 116)]
    Id_WarningType(WarningType),
}
impl asn1_codecs::Asn1Choice for WriteReplaceWarningRequestProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_ConcurrentWarningMessageIndicator(_) => 142u128.try_into().unwrap(),
            Self::Id_DataCodingScheme(_) => 118u128.try_into().unwrap(),
            Self::Id_ExtendedRepetitionPeriod(_) => 144u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 111u128.try_into().unwrap(),
            Self::Id_NumberofBroadcastRequest(_) => 115u128.try_into().unwrap(),
            Self::Id_RepetitionPeriod(_) => 114u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 112u128.try_into().unwrap(),
            Self::Id_WarningAreaCoordinates(_) => 286u128.try_into().unwrap(),
            Self::Id_WarningAreaList(_) => 113u128.try_into().unwrap(),
            Self::Id_WarningMessageContents(_) => 119u128.try_into().unwrap(),
            Self::Id_WarningSecurityInfo(_) => 117u128.try_into().unwrap(),
            Self::Id_WarningType(_) => 116u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningRequestProtocolIEs_EntryValue,
}
impl entropic::Entropic for WriteReplaceWarningRequestProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: WriteReplaceWarningRequestProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningRequestProtocolIEs(
    pub Vec<WriteReplaceWarningRequestProtocolIEs_Entry>,
);
impl entropic::Entropic for WriteReplaceWarningRequestProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WriteReplaceWarningRequestProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(WriteReplaceWarningRequestProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningResponseProtocolIEs_EntryValue {
    #[asn(key = 120)]
    Id_BroadcastCompletedAreaList(BroadcastCompletedAreaList),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
}
impl asn1_codecs::Asn1Choice for WriteReplaceWarningResponseProtocolIEs_EntryValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_BroadcastCompletedAreaList(_) => 120u128.try_into().unwrap(),
            Self::Id_CriticalityDiagnostics(_) => 58u128.try_into().unwrap(),
            Self::Id_MessageIdentifier(_) => 111u128.try_into().unwrap(),
            Self::Id_SerialNumber(_) => 112u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningResponseProtocolIEs_EntryValue,
}
impl entropic::Entropic for WriteReplaceWarningResponseProtocolIEs_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let value: WriteReplaceWarningResponseProtocolIEs_EntryValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolIE_ID = ProtocolIE_ID(value.choice_key());
        Ok(Self {
            id,
            criticality,
            value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self.value.to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningResponseProtocolIEs(
    pub Vec<WriteReplaceWarningResponseProtocolIEs_Entry>,
);
impl entropic::Entropic for WriteReplaceWarningResponseProtocolIEs {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(0..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(WriteReplaceWarningResponseProtocolIEs_Entry::from_finite_entropy(source)?);
        }
        Ok(WriteReplaceWarningResponseProtocolIEs(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(0..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, entropic :: Entropic, Debug)]
#[asn(type = "OPEN")]
pub enum X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 193)]
    Id_eNBIndirectX2TransportLayerAddresses(ENBIndirectX2TransportLayerAddresses),
    #[asn(key = 153)]
    Id_eNBX2ExtendedTransportLayerAddresses(ENBX2ExtTLAs),
}
impl asn1_codecs::Asn1Choice for X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue {
    fn choice_key<K: TryFrom<u128>>(&self) -> K
    where
        <K as TryFrom<u128>>::Error: std::fmt::Debug,
    {
        match self {
            Self::Id_eNBIndirectX2TransportLayerAddresses(_) => 193u128.try_into().unwrap(),
            Self::Id_eNBX2ExtendedTransportLayerAddresses(_) => 153u128.try_into().unwrap(),
        }
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2TNLConfigurationInfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue,
}
impl entropic::Entropic for X2TNLConfigurationInfoIE_Extensions_Entry {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        __entropic_internal_source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let criticality: Criticality = __entropic_internal_source.entropic()?;
        let extension_value: X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue =
            __entropic_internal_source.entropic()?;
        let id: ProtocolExtensionID = ProtocolExtensionID(extension_value.choice_key());
        Ok(Self {
            id,
            criticality,
            extension_value,
        })
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        __entropic_internal_sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut __entropic_internal_length = 0;
        __entropic_internal_length += self
            .criticality
            .to_finite_entropy(__entropic_internal_sink)?;
        __entropic_internal_length += self
            .extension_value
            .to_finite_entropy(__entropic_internal_sink)?;
        Ok(__entropic_internal_length)
    }
}

#[derive(asn1_codecs_derive :: AperCodec, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct X2TNLConfigurationInfoIE_Extensions(pub Vec<X2TNLConfigurationInfoIE_Extensions_Entry>);
impl entropic::Entropic for X2TNLConfigurationInfoIE_Extensions {
    fn from_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a u8>>(
        source: &mut entropic::FiniteEntropySource<'a, S, I>,
    ) -> Result<Self, entropic::Error> {
        let capped_max = std::cmp::min(65535, 16383);
        let vec_len = source.get_bounded_len(1..=capped_max)?;
        let mut v = Vec::new();
        for _ in 0..vec_len {
            v.push(X2TNLConfigurationInfoIE_Extensions_Entry::from_finite_entropy(source)?);
        }
        Ok(X2TNLConfigurationInfoIE_Extensions(v))
    }
    fn to_finite_entropy<'a, S: EntropyScheme, I: Iterator<Item = &'a mut u8>>(
        &self,
        sink: &mut FiniteEntropySink<'a, S, I>,
    ) -> Result<usize, Error> {
        let mut length = 0;
        let capped_max = std::cmp::min(65535, 16383);
        length += sink.put_bounded_len(1..=capped_max, self.0.len())?;
        for item in self.0.iter() {
            length += sink.put_entropic(item)?;
        }
        Ok(length)
    }
}
